
/*** <<< INCLUDES [AlaCarte] >>> ***/

#include "DSRCmsgID.h"
#include "AllInclusive.h"
#include "MsgCRC.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [AlaCarte] >>> ***/

typedef struct AlaCarte {
	DSRCmsgID_t	 msgID;
	AllInclusive_t	 data;
	MsgCRC_t	*crc	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} AlaCarte_t;

/*** <<< FUNC-DECLS [AlaCarte] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AlaCarte;

/*** <<< STAT-DEFS [AlaCarte] >>> ***/

static asn_TYPE_member_t asn_MBR_AlaCarte_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct AlaCarte, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct AlaCarte, data),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AllInclusive,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "data"
		},
	{ ATF_POINTER, 1, offsetof(struct AlaCarte, crc),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crc"
		},
};
static ber_tlv_tag_t asn_DEF_AlaCarte_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_AlaCarte_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* data */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* crc */
};
static asn_SEQUENCE_specifics_t asn_SPC_AlaCarte_specs_1 = {
	sizeof(struct AlaCarte),
	offsetof(struct AlaCarte, _asn_ctx),
	asn_MAP_AlaCarte_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	2,	/* Start extensions */
	4	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_AlaCarte = {
	"AlaCarte",
	"AlaCarte",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AlaCarte_tags_1,
	sizeof(asn_DEF_AlaCarte_tags_1)
		/sizeof(asn_DEF_AlaCarte_tags_1[0]), /* 1 */
	asn_DEF_AlaCarte_tags_1,	/* Same as above */
	sizeof(asn_DEF_AlaCarte_tags_1)
		/sizeof(asn_DEF_AlaCarte_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_AlaCarte_1,
	3,	/* Elements count */
	&asn_SPC_AlaCarte_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [BasicSafetyMessage] >>> ***/

#include "DSRCmsgID.h"
#include "BSMblob.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [BasicSafetyMessage] >>> ***/

struct VehicleSafetyExtension;
struct VehicleStatus;

/*** <<< TYPE-DECLS [BasicSafetyMessage] >>> ***/

typedef struct BasicSafetyMessage {
	DSRCmsgID_t	 msgID;
	BSMblob_t	 blob1;
	struct VehicleSafetyExtension	*safetyExt	/* OPTIONAL */;
	struct VehicleStatus	*status	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} BasicSafetyMessage_t;

/*** <<< FUNC-DECLS [BasicSafetyMessage] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage;

/*** <<< POST-INCLUDE [BasicSafetyMessage] >>> ***/

#include "VehicleSafetyExtension.h"
#include "VehicleStatus.h"

/*** <<< STAT-DEFS [BasicSafetyMessage] >>> ***/

static asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessage, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessage, blob1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BSMblob,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "blob1"
		},
	{ ATF_POINTER, 2, offsetof(struct BasicSafetyMessage, safetyExt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleSafetyExtension,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "safetyExt"
		},
	{ ATF_POINTER, 1, offsetof(struct BasicSafetyMessage, status),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "status"
		},
};
static ber_tlv_tag_t asn_DEF_BasicSafetyMessage_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_BasicSafetyMessage_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* blob1 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* safetyExt */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* status */
};
static asn_SEQUENCE_specifics_t asn_SPC_BasicSafetyMessage_specs_1 = {
	sizeof(struct BasicSafetyMessage),
	offsetof(struct BasicSafetyMessage, _asn_ctx),
	asn_MAP_BasicSafetyMessage_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage = {
	"BasicSafetyMessage",
	"BasicSafetyMessage",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BasicSafetyMessage_tags_1,
	sizeof(asn_DEF_BasicSafetyMessage_tags_1)
		/sizeof(asn_DEF_BasicSafetyMessage_tags_1[0]), /* 1 */
	asn_DEF_BasicSafetyMessage_tags_1,	/* Same as above */
	sizeof(asn_DEF_BasicSafetyMessage_tags_1)
		/sizeof(asn_DEF_BasicSafetyMessage_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_BasicSafetyMessage_1,
	4,	/* Elements count */
	&asn_SPC_BasicSafetyMessage_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [BasicSafetyMessageVerbose] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "TemporaryID.h"
#include "DSecond.h"
#include "Latitude.h"
#include "Longitude.h"
#include "Elevation.h"
#include "PositionalAccuracy.h"
#include "TransmissionAndSpeed.h"
#include "Heading.h"
#include "SteeringWheelAngle.h"
#include "AccelerationSet4Way.h"
#include "BrakeSystemStatus.h"
#include "VehicleSize.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [BasicSafetyMessageVerbose] >>> ***/

struct VehicleSafetyExtension;
struct VehicleStatus;

/*** <<< TYPE-DECLS [BasicSafetyMessageVerbose] >>> ***/

typedef struct BasicSafetyMessageVerbose {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	TemporaryID_t	 id;
	DSecond_t	 secMark;
	Latitude_t	 lat;
	Longitude_t	 Long;
	Elevation_t	 elev;
	PositionalAccuracy_t	 accuracy;
	TransmissionAndSpeed_t	 speed;
	Heading_t	 heading;
	SteeringWheelAngle_t	 angle;
	AccelerationSet4Way_t	 accelSet;
	BrakeSystemStatus_t	 brakes;
	VehicleSize_t	 size;
	struct VehicleSafetyExtension	*safetyExt	/* OPTIONAL */;
	struct VehicleStatus	*status	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} BasicSafetyMessageVerbose_t;

/*** <<< FUNC-DECLS [BasicSafetyMessageVerbose] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessageVerbose;

/*** <<< POST-INCLUDE [BasicSafetyMessageVerbose] >>> ***/

#include "VehicleSafetyExtension.h"
#include "VehicleStatus.h"

/*** <<< STAT-DEFS [BasicSafetyMessageVerbose] >>> ***/

static asn_TYPE_member_t asn_MBR_BasicSafetyMessageVerbose_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TemporaryID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, secMark),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSecond,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "secMark"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, lat),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Latitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lat"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, Long),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Longitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "long"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, elev),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Elevation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "elev"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, accuracy),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionalAccuracy,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "accuracy"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, speed),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransmissionAndSpeed,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speed"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, heading),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Heading,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "heading"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, angle),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "angle"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, accelSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelerationSet4Way,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "accelSet"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, brakes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeSystemStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "brakes"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BasicSafetyMessageVerbose, size),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleSize,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "size"
		},
	{ ATF_POINTER, 2, offsetof(struct BasicSafetyMessageVerbose, safetyExt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleSafetyExtension,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "safetyExt"
		},
	{ ATF_POINTER, 1, offsetof(struct BasicSafetyMessageVerbose, status),
		.tag = (ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "status"
		},
};
static ber_tlv_tag_t asn_DEF_BasicSafetyMessageVerbose_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_BasicSafetyMessageVerbose_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* secMark */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* lat */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* long */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* elev */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* accuracy */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* speed */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* heading */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* angle */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* accelSet */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* brakes */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* size */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* safetyExt */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 } /* status */
};
static asn_SEQUENCE_specifics_t asn_SPC_BasicSafetyMessageVerbose_specs_1 = {
	sizeof(struct BasicSafetyMessageVerbose),
	offsetof(struct BasicSafetyMessageVerbose, _asn_ctx),
	asn_MAP_BasicSafetyMessageVerbose_tag2el_1,
	16,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	15,	/* Start extensions */
	17	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessageVerbose = {
	"BasicSafetyMessageVerbose",
	"BasicSafetyMessageVerbose",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BasicSafetyMessageVerbose_tags_1,
	sizeof(asn_DEF_BasicSafetyMessageVerbose_tags_1)
		/sizeof(asn_DEF_BasicSafetyMessageVerbose_tags_1[0]), /* 1 */
	asn_DEF_BasicSafetyMessageVerbose_tags_1,	/* Same as above */
	sizeof(asn_DEF_BasicSafetyMessageVerbose_tags_1)
		/sizeof(asn_DEF_BasicSafetyMessageVerbose_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_BasicSafetyMessageVerbose_1,
	16,	/* Elements count */
	&asn_SPC_BasicSafetyMessageVerbose_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [CommonSafetyRequest] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "TemporaryID.h"
#include "RequestedItem.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [CommonSafetyRequest] >>> ***/

typedef struct CommonSafetyRequest {
	DSRCmsgID_t	 msgID;
	MsgCount_t	*msgCnt	/* OPTIONAL */;
	TemporaryID_t	*id	/* OPTIONAL */;
	struct requests {
		A_SEQUENCE_OF(RequestedItem_t) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} requests;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} CommonSafetyRequest_t;

/*** <<< FUNC-DECLS [CommonSafetyRequest] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_CommonSafetyRequest;

/*** <<< CODE [CommonSafetyRequest] >>> ***/

static int
memb_requests_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [CommonSafetyRequest] >>> ***/

static asn_TYPE_member_t asn_MBR_requests_5[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_RequestedItem,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_requests_tags_5[] = {
	(ASN_TAG_CLASS_CONTEXT | (3 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_requests_specs_5 = {
	sizeof(struct requests),
	offsetof(struct requests, _asn_ctx),
	1,	/* XER encoding is XMLValueList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_requests_5 = {
	"requests",
	"requests",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_requests_tags_5,
	sizeof(asn_DEF_requests_tags_5)
		/sizeof(asn_DEF_requests_tags_5[0]) - 1, /* 1 */
	asn_DEF_requests_tags_5,	/* Same as above */
	sizeof(asn_DEF_requests_tags_5)
		/sizeof(asn_DEF_requests_tags_5[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_requests_5,
	1,	/* Single element */
	&asn_SPC_requests_specs_5	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CommonSafetyRequest, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_POINTER, 2, offsetof(struct CommonSafetyRequest, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_POINTER, 1, offsetof(struct CommonSafetyRequest, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TemporaryID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CommonSafetyRequest, requests),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_requests_5,
		.memb_constraints = memb_requests_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "requests"
		},
};
static ber_tlv_tag_t asn_DEF_CommonSafetyRequest_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_CommonSafetyRequest_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* requests */
};
static asn_SEQUENCE_specifics_t asn_SPC_CommonSafetyRequest_specs_1 = {
	sizeof(struct CommonSafetyRequest),
	offsetof(struct CommonSafetyRequest, _asn_ctx),
	asn_MAP_CommonSafetyRequest_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_CommonSafetyRequest = {
	"CommonSafetyRequest",
	"CommonSafetyRequest",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CommonSafetyRequest_tags_1,
	sizeof(asn_DEF_CommonSafetyRequest_tags_1)
		/sizeof(asn_DEF_CommonSafetyRequest_tags_1[0]), /* 1 */
	asn_DEF_CommonSafetyRequest_tags_1,	/* Same as above */
	sizeof(asn_DEF_CommonSafetyRequest_tags_1)
		/sizeof(asn_DEF_CommonSafetyRequest_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_CommonSafetyRequest_1,
	4,	/* Elements count */
	&asn_SPC_CommonSafetyRequest_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [EmergencyVehicleAlert] >>> ***/

#include "DSRCmsgID.h"
#include "TemporaryID.h"
#include "RoadSideAlert.h"
#include "ResponseType.h"
#include "EmergencyDetails.h"
#include "VehicleMass.h"
#include "VehicleType.h"
#include "VehicleGroupAffected.h"
#include "IncidentResponseEquipment.h"
#include "ResponderGroupAffected.h"
#include "MsgCRC.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [EmergencyVehicleAlert] >>> ***/

typedef struct EmergencyVehicleAlert {
	DSRCmsgID_t	 msgID;
	TemporaryID_t	*id	/* OPTIONAL */;
	RoadSideAlert_t	 rsaMsg;
	ResponseType_t	*responseType	/* OPTIONAL */;
	EmergencyDetails_t	*details	/* OPTIONAL */;
	VehicleMass_t	*mass	/* OPTIONAL */;
	VehicleType_t	*basicType	/* OPTIONAL */;
	VehicleGroupAffected_t	*vehicleType	/* OPTIONAL */;
	IncidentResponseEquipment_t	*responseEquip	/* OPTIONAL */;
	ResponderGroupAffected_t	*responderType	/* OPTIONAL */;
	MsgCRC_t	 crc;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} EmergencyVehicleAlert_t;

/*** <<< FUNC-DECLS [EmergencyVehicleAlert] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EmergencyVehicleAlert;

/*** <<< STAT-DEFS [EmergencyVehicleAlert] >>> ***/

static asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct EmergencyVehicleAlert, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_POINTER, 1, offsetof(struct EmergencyVehicleAlert, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TemporaryID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct EmergencyVehicleAlert, rsaMsg),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RoadSideAlert,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rsaMsg"
		},
	{ ATF_POINTER, 7, offsetof(struct EmergencyVehicleAlert, responseType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ResponseType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "responseType"
		},
	{ ATF_POINTER, 6, offsetof(struct EmergencyVehicleAlert, details),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EmergencyDetails,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "details"
		},
	{ ATF_POINTER, 5, offsetof(struct EmergencyVehicleAlert, mass),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleMass,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "mass"
		},
	{ ATF_POINTER, 4, offsetof(struct EmergencyVehicleAlert, basicType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "basicType"
		},
	{ ATF_POINTER, 3, offsetof(struct EmergencyVehicleAlert, vehicleType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleGroupAffected,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleType"
		},
	{ ATF_POINTER, 2, offsetof(struct EmergencyVehicleAlert, responseEquip),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IncidentResponseEquipment,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "responseEquip"
		},
	{ ATF_POINTER, 1, offsetof(struct EmergencyVehicleAlert, responderType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ResponderGroupAffected,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "responderType"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct EmergencyVehicleAlert, crc),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crc"
		},
};
static ber_tlv_tag_t asn_DEF_EmergencyVehicleAlert_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_EmergencyVehicleAlert_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* rsaMsg */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* responseType */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* details */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* mass */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* basicType */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* vehicleType */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* responseEquip */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* responderType */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 } /* crc */
};
static asn_SEQUENCE_specifics_t asn_SPC_EmergencyVehicleAlert_specs_1 = {
	sizeof(struct EmergencyVehicleAlert),
	offsetof(struct EmergencyVehicleAlert, _asn_ctx),
	asn_MAP_EmergencyVehicleAlert_tag2el_1,
	11,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	10,	/* Start extensions */
	12	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_EmergencyVehicleAlert = {
	"EmergencyVehicleAlert",
	"EmergencyVehicleAlert",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EmergencyVehicleAlert_tags_1,
	sizeof(asn_DEF_EmergencyVehicleAlert_tags_1)
		/sizeof(asn_DEF_EmergencyVehicleAlert_tags_1[0]), /* 1 */
	asn_DEF_EmergencyVehicleAlert_tags_1,	/* Same as above */
	sizeof(asn_DEF_EmergencyVehicleAlert_tags_1)
		/sizeof(asn_DEF_EmergencyVehicleAlert_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_EmergencyVehicleAlert_1,
	11,	/* Elements count */
	&asn_SPC_EmergencyVehicleAlert_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [IntersectionCollision] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "TemporaryID.h"
#include "DSecond.h"
#include "PathHistory.h"
#include "IntersectionID.h"
#include "LaneNumber.h"
#include "EventFlags.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [IntersectionCollision] >>> ***/

typedef struct IntersectionCollision {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	TemporaryID_t	 id;
	DSecond_t	*secMark	/* OPTIONAL */;
	PathHistory_t	 path;
	IntersectionID_t	 intersetionID;
	LaneNumber_t	 laneNumber;
	EventFlags_t	 eventFlag;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} IntersectionCollision_t;

/*** <<< FUNC-DECLS [IntersectionCollision] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_IntersectionCollision;

/*** <<< STAT-DEFS [IntersectionCollision] >>> ***/

static asn_TYPE_member_t asn_MBR_IntersectionCollision_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TemporaryID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_POINTER, 1, offsetof(struct IntersectionCollision, secMark),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSecond,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "secMark"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, path),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistory,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "path"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, intersetionID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "intersetionID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, laneNumber),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneNumber"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionCollision, eventFlag),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EventFlags,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "eventFlag"
		},
};
static ber_tlv_tag_t asn_DEF_IntersectionCollision_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_IntersectionCollision_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* secMark */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* path */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* intersetionID */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* laneNumber */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 } /* eventFlag */
};
static asn_SEQUENCE_specifics_t asn_SPC_IntersectionCollision_specs_1 = {
	sizeof(struct IntersectionCollision),
	offsetof(struct IntersectionCollision, _asn_ctx),
	asn_MAP_IntersectionCollision_tag2el_1,
	8,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	7,	/* Start extensions */
	9	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_IntersectionCollision = {
	"IntersectionCollision",
	"IntersectionCollision",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_IntersectionCollision_tags_1,
	sizeof(asn_DEF_IntersectionCollision_tags_1)
		/sizeof(asn_DEF_IntersectionCollision_tags_1[0]), /* 1 */
	asn_DEF_IntersectionCollision_tags_1,	/* Same as above */
	sizeof(asn_DEF_IntersectionCollision_tags_1)
		/sizeof(asn_DEF_IntersectionCollision_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_IntersectionCollision_1,
	8,	/* Elements count */
	&asn_SPC_IntersectionCollision_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [MapData] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "DescriptiveName.h"
#include "LayerType.h"
#include "LayerID.h"
#include "MsgCRC.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [MapData] >>> ***/

struct DataParameters;
struct Intersection;

/*** <<< TYPE-DECLS [MapData] >>> ***/

typedef struct MapData {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	DescriptiveName_t	*name	/* OPTIONAL */;
	LayerType_t	*layerType	/* OPTIONAL */;
	LayerID_t	*layerID	/* OPTIONAL */;
	struct intersections {
		A_SEQUENCE_OF(struct Intersection) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *intersections;
	struct DataParameters	*dataParameters	/* OPTIONAL */;
	MsgCRC_t	 crc;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} MapData_t;

/*** <<< FUNC-DECLS [MapData] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MapData;

/*** <<< POST-INCLUDE [MapData] >>> ***/

#include "DataParameters.h"
#include "Intersection.h"

/*** <<< CODE [MapData] >>> ***/

static int
memb_intersections_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [MapData] >>> ***/

static asn_TYPE_member_t asn_MBR_intersections_7[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Intersection,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_intersections_tags_7[] = {
	(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_intersections_specs_7 = {
	sizeof(struct intersections),
	offsetof(struct intersections, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_intersections_7 = {
	"intersections",
	"intersections",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_intersections_tags_7,
	sizeof(asn_DEF_intersections_tags_7)
		/sizeof(asn_DEF_intersections_tags_7[0]) - 1, /* 1 */
	asn_DEF_intersections_tags_7,	/* Same as above */
	sizeof(asn_DEF_intersections_tags_7)
		/sizeof(asn_DEF_intersections_tags_7[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_intersections_7,
	1,	/* Single element */
	&asn_SPC_intersections_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_MapData_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct MapData, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct MapData, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_POINTER, 5, offsetof(struct MapData, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_POINTER, 4, offsetof(struct MapData, layerType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LayerType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "layerType"
		},
	{ ATF_POINTER, 3, offsetof(struct MapData, layerID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LayerID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "layerID"
		},
	{ ATF_POINTER, 2, offsetof(struct MapData, intersections),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_intersections_7,
		.memb_constraints = memb_intersections_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "intersections"
		},
	{ ATF_POINTER, 1, offsetof(struct MapData, dataParameters),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DataParameters,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "dataParameters"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct MapData, crc),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crc"
		},
};
static ber_tlv_tag_t asn_DEF_MapData_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_MapData_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* layerType */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* layerID */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* intersections */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* dataParameters */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 } /* crc */
};
static asn_SEQUENCE_specifics_t asn_SPC_MapData_specs_1 = {
	sizeof(struct MapData),
	offsetof(struct MapData, _asn_ctx),
	asn_MAP_MapData_tag2el_1,
	8,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	7,	/* Start extensions */
	9	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_MapData = {
	"MapData",
	"MapData",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MapData_tags_1,
	sizeof(asn_DEF_MapData_tags_1)
		/sizeof(asn_DEF_MapData_tags_1[0]), /* 1 */
	asn_DEF_MapData_tags_1,	/* Same as above */
	sizeof(asn_DEF_MapData_tags_1)
		/sizeof(asn_DEF_MapData_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_MapData_1,
	8,	/* Elements count */
	&asn_SPC_MapData_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NMEA-Corrections] >>> ***/

#include "DSRCmsgID.h"
#include "NMEA-Revision.h"
#include "NMEA-MsgType.h"
#include <NativeInteger.h>
#include "NMEA-Payload.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [NMEA-Corrections] >>> ***/

typedef struct NMEA_Corrections {
	DSRCmsgID_t	 msgID;
	NMEA_Revision_t	 rev;
	NMEA_MsgType_t	 msg;
	long	 wdCount;
	NMEA_Payload_t	 payload;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} NMEA_Corrections_t;

/*** <<< FUNC-DECLS [NMEA-Corrections] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NMEA_Corrections;

/*** <<< CODE [NMEA-Corrections] >>> ***/

static int
memb_wdCount_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 1023)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [NMEA-Corrections] >>> ***/

static asn_TYPE_member_t asn_MBR_NMEA_Corrections_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct NMEA_Corrections, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct NMEA_Corrections, rev),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NMEA_Revision,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rev"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct NMEA_Corrections, msg),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NMEA_MsgType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct NMEA_Corrections, wdCount),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_wdCount_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "wdCount"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct NMEA_Corrections, payload),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NMEA_Payload,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "payload"
		},
};
static ber_tlv_tag_t asn_DEF_NMEA_Corrections_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_NMEA_Corrections_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rev */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* msg */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* wdCount */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* payload */
};
static asn_SEQUENCE_specifics_t asn_SPC_NMEA_Corrections_specs_1 = {
	sizeof(struct NMEA_Corrections),
	offsetof(struct NMEA_Corrections, _asn_ctx),
	asn_MAP_NMEA_Corrections_tag2el_1,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	4,	/* Start extensions */
	6	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_NMEA_Corrections = {
	"NMEA-Corrections",
	"NMEA-Corrections",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_NMEA_Corrections_tags_1,
	sizeof(asn_DEF_NMEA_Corrections_tags_1)
		/sizeof(asn_DEF_NMEA_Corrections_tags_1[0]), /* 1 */
	asn_DEF_NMEA_Corrections_tags_1,	/* Same as above */
	sizeof(asn_DEF_NMEA_Corrections_tags_1)
		/sizeof(asn_DEF_NMEA_Corrections_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_NMEA_Corrections_1,
	5,	/* Elements count */
	&asn_SPC_NMEA_Corrections_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ProbeDataManagement] >>> ***/

#include "DSRCmsgID.h"
#include "Sample.h"
#include "HeadingSlice.h"
#include "TxTime.h"
#include "Count.h"
#include "TermTime.h"
#include "TermDistance.h"
#include <constr_CHOICE.h>
#include "SnapshotTime.h"
#include "SnapshotDistance.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< DEPS [ProbeDataManagement] >>> ***/

typedef enum term_PR {
	term_PR_NOTHING,	/* No components present */
	term_PR_termtime,
	term_PR_termDistance
} term_PR;
typedef enum snapshot_PR {
	snapshot_PR_NOTHING,	/* No components present */
	snapshot_PR_snapshotTime,
	snapshot_PR_snapshotDistance
} snapshot_PR;

/*** <<< FWD-DECLS [ProbeDataManagement] >>> ***/

struct VehicleStatusRequest;

/*** <<< TYPE-DECLS [ProbeDataManagement] >>> ***/

typedef struct ProbeDataManagement {
	DSRCmsgID_t	 msgID;
	Sample_t	 sample;
	HeadingSlice_t	 directions;
	struct term {
		term_PR present;
		union ProbeDataManagement__term_u {
			TermTime_t	 termtime;
			TermDistance_t	 termDistance;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} term;
	struct snapshot {
		snapshot_PR present;
		union ProbeDataManagement__snapshot_u {
			SnapshotTime_t	 snapshotTime;
			SnapshotDistance_t	 snapshotDistance;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} snapshot;
	TxTime_t	 txInterval;
	Count_t	 cntTthreshold;
	struct dataElements {
		A_SEQUENCE_OF(struct VehicleStatusRequest) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} dataElements;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ProbeDataManagement_t;

/*** <<< FUNC-DECLS [ProbeDataManagement] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ProbeDataManagement;

/*** <<< POST-INCLUDE [ProbeDataManagement] >>> ***/

#include "VehicleStatusRequest.h"

/*** <<< CODE [ProbeDataManagement] >>> ***/

static int
memb_dataElements_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [ProbeDataManagement] >>> ***/

static asn_TYPE_member_t asn_MBR_term_5[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct term, choice.termtime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TermTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "termtime"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct term, choice.termDistance),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TermDistance,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "termDistance"
		},
};
static asn_TYPE_tag2member_t asn_MAP_term_tag2el_5[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* termtime */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* termDistance */
};
static asn_CHOICE_specifics_t asn_SPC_term_specs_5 = {
	sizeof(struct term),
	offsetof(struct term, _asn_ctx),
	offsetof(struct term, present),
	sizeof(((struct term *)0)->present),
	asn_MAP_term_tag2el_5,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_term_5 = {
	"term",
	"term",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_term_5,
	2,	/* Elements count */
	&asn_SPC_term_specs_5	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_snapshot_8[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct snapshot, choice.snapshotTime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SnapshotTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "snapshotTime"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct snapshot, choice.snapshotDistance),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SnapshotDistance,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "snapshotDistance"
		},
};
static asn_TYPE_tag2member_t asn_MAP_snapshot_tag2el_8[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* snapshotTime */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* snapshotDistance */
};
static asn_CHOICE_specifics_t asn_SPC_snapshot_specs_8 = {
	sizeof(struct snapshot),
	offsetof(struct snapshot, _asn_ctx),
	offsetof(struct snapshot, present),
	sizeof(((struct snapshot *)0)->present),
	asn_MAP_snapshot_tag2el_8,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_snapshot_8 = {
	"snapshot",
	"snapshot",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_snapshot_8,
	2,	/* Elements count */
	&asn_SPC_snapshot_specs_8	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_dataElements_13[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_VehicleStatusRequest,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_dataElements_tags_13[] = {
	(ASN_TAG_CLASS_CONTEXT | (7 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_dataElements_specs_13 = {
	sizeof(struct dataElements),
	offsetof(struct dataElements, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_dataElements_13 = {
	"dataElements",
	"dataElements",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_dataElements_tags_13,
	sizeof(asn_DEF_dataElements_tags_13)
		/sizeof(asn_DEF_dataElements_tags_13[0]) - 1, /* 1 */
	asn_DEF_dataElements_tags_13,	/* Same as above */
	sizeof(asn_DEF_dataElements_tags_13)
		/sizeof(asn_DEF_dataElements_tags_13[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_dataElements_13,
	1,	/* Single element */
	&asn_SPC_dataElements_specs_13	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, sample),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Sample,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sample"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, directions),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_HeadingSlice,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "directions"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, term),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_term_5,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "term"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, snapshot),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_snapshot_8,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "snapshot"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, txInterval),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TxTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "txInterval"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, cntTthreshold),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Count,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "cntTthreshold"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeDataManagement, dataElements),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_dataElements_13,
		.memb_constraints = memb_dataElements_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "dataElements"
		},
};
static ber_tlv_tag_t asn_DEF_ProbeDataManagement_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ProbeDataManagement_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* sample */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* directions */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* term */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* snapshot */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* txInterval */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* cntTthreshold */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 } /* dataElements */
};
static asn_SEQUENCE_specifics_t asn_SPC_ProbeDataManagement_specs_1 = {
	sizeof(struct ProbeDataManagement),
	offsetof(struct ProbeDataManagement, _asn_ctx),
	asn_MAP_ProbeDataManagement_tag2el_1,
	8,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	7,	/* Start extensions */
	9	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProbeDataManagement = {
	"ProbeDataManagement",
	"ProbeDataManagement",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ProbeDataManagement_tags_1,
	sizeof(asn_DEF_ProbeDataManagement_tags_1)
		/sizeof(asn_DEF_ProbeDataManagement_tags_1[0]), /* 1 */
	asn_DEF_ProbeDataManagement_tags_1,	/* Same as above */
	sizeof(asn_DEF_ProbeDataManagement_tags_1)
		/sizeof(asn_DEF_ProbeDataManagement_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProbeDataManagement_1,
	8,	/* Elements count */
	&asn_SPC_ProbeDataManagement_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ProbeVehicleData] >>> ***/

#include "DSRCmsgID.h"
#include "ProbeSegmentNumber.h"
#include "FullPositionVector.h"
#include "VehicleType.h"
#include "Count.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [ProbeVehicleData] >>> ***/

struct VehicleIdent;
struct Snapshot;

/*** <<< TYPE-DECLS [ProbeVehicleData] >>> ***/

typedef struct ProbeVehicleData {
	DSRCmsgID_t	 msgID;
	ProbeSegmentNumber_t	*segNum	/* OPTIONAL */;
	struct VehicleIdent	*probeID	/* OPTIONAL */;
	FullPositionVector_t	 startVector;
	VehicleType_t	 vehicleType;
	Count_t	*cntSnapshots	/* OPTIONAL */;
	struct snapshots {
		A_SEQUENCE_OF(struct Snapshot) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} snapshots;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ProbeVehicleData_t;

/*** <<< FUNC-DECLS [ProbeVehicleData] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ProbeVehicleData;

/*** <<< POST-INCLUDE [ProbeVehicleData] >>> ***/

#include "VehicleIdent.h"
#include "Snapshot.h"

/*** <<< CODE [ProbeVehicleData] >>> ***/

static int
memb_snapshots_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [ProbeVehicleData] >>> ***/

static asn_TYPE_member_t asn_MBR_snapshots_8[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Snapshot,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_snapshots_tags_8[] = {
	(ASN_TAG_CLASS_CONTEXT | (6 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_snapshots_specs_8 = {
	sizeof(struct snapshots),
	offsetof(struct snapshots, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_snapshots_8 = {
	"snapshots",
	"snapshots",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_snapshots_tags_8,
	sizeof(asn_DEF_snapshots_tags_8)
		/sizeof(asn_DEF_snapshots_tags_8[0]) - 1, /* 1 */
	asn_DEF_snapshots_tags_8,	/* Same as above */
	sizeof(asn_DEF_snapshots_tags_8)
		/sizeof(asn_DEF_snapshots_tags_8[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_snapshots_8,
	1,	/* Single element */
	&asn_SPC_snapshots_specs_8	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeVehicleData, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_POINTER, 2, offsetof(struct ProbeVehicleData, segNum),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ProbeSegmentNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "segNum"
		},
	{ ATF_POINTER, 1, offsetof(struct ProbeVehicleData, probeID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleIdent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "probeID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeVehicleData, startVector),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "startVector"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeVehicleData, vehicleType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleType"
		},
	{ ATF_POINTER, 1, offsetof(struct ProbeVehicleData, cntSnapshots),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Count,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "cntSnapshots"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProbeVehicleData, snapshots),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_snapshots_8,
		.memb_constraints = memb_snapshots_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "snapshots"
		},
};
static ber_tlv_tag_t asn_DEF_ProbeVehicleData_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ProbeVehicleData_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* segNum */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* probeID */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* startVector */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* vehicleType */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* cntSnapshots */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 } /* snapshots */
};
static asn_SEQUENCE_specifics_t asn_SPC_ProbeVehicleData_specs_1 = {
	sizeof(struct ProbeVehicleData),
	offsetof(struct ProbeVehicleData, _asn_ctx),
	asn_MAP_ProbeVehicleData_tag2el_1,
	7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	6,	/* Start extensions */
	8	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProbeVehicleData = {
	"ProbeVehicleData",
	"ProbeVehicleData",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ProbeVehicleData_tags_1,
	sizeof(asn_DEF_ProbeVehicleData_tags_1)
		/sizeof(asn_DEF_ProbeVehicleData_tags_1[0]), /* 1 */
	asn_DEF_ProbeVehicleData_tags_1,	/* Same as above */
	sizeof(asn_DEF_ProbeVehicleData_tags_1)
		/sizeof(asn_DEF_ProbeVehicleData_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProbeVehicleData_1,
	7,	/* Elements count */
	&asn_SPC_ProbeVehicleData_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RoadSideAlert] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "ITIScodes.h"
#include "Priority.h"
#include "HeadingSlice.h"
#include "Extent.h"
#include "FurtherInfoID.h"
#include "MsgCRC.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [RoadSideAlert] >>> ***/

struct FullPositionVector;

/*** <<< TYPE-DECLS [RoadSideAlert] >>> ***/

typedef struct RoadSideAlert {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	ITIScodes_t	 typeEvent;
	struct description {
		A_SEQUENCE_OF(ITIScodes_t) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *description;
	Priority_t	*priority	/* OPTIONAL */;
	HeadingSlice_t	*heading	/* OPTIONAL */;
	Extent_t	*extent	/* OPTIONAL */;
	struct FullPositionVector	*positon	/* OPTIONAL */;
	FurtherInfoID_t	*furtherInfoID	/* OPTIONAL */;
	MsgCRC_t	 crc;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RoadSideAlert_t;

/*** <<< FUNC-DECLS [RoadSideAlert] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RoadSideAlert;

/*** <<< POST-INCLUDE [RoadSideAlert] >>> ***/

#include "FullPositionVector.h"

/*** <<< CODE [RoadSideAlert] >>> ***/

static int
memb_description_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 8)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [RoadSideAlert] >>> ***/

static asn_TYPE_member_t asn_MBR_description_5[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_description_tags_5[] = {
	(ASN_TAG_CLASS_CONTEXT | (3 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_description_specs_5 = {
	sizeof(struct description),
	offsetof(struct description, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_description_5 = {
	"description",
	"description",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_description_tags_5,
	sizeof(asn_DEF_description_tags_5)
		/sizeof(asn_DEF_description_tags_5[0]) - 1, /* 1 */
	asn_DEF_description_tags_5,	/* Same as above */
	sizeof(asn_DEF_description_tags_5)
		/sizeof(asn_DEF_description_tags_5[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_description_5,
	1,	/* Single element */
	&asn_SPC_description_specs_5	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RoadSideAlert_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RoadSideAlert, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RoadSideAlert, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RoadSideAlert, typeEvent),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "typeEvent"
		},
	{ ATF_POINTER, 6, offsetof(struct RoadSideAlert, description),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_description_5,
		.memb_constraints = memb_description_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "description"
		},
	{ ATF_POINTER, 5, offsetof(struct RoadSideAlert, priority),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Priority,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "priority"
		},
	{ ATF_POINTER, 4, offsetof(struct RoadSideAlert, heading),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_HeadingSlice,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "heading"
		},
	{ ATF_POINTER, 3, offsetof(struct RoadSideAlert, extent),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Extent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "extent"
		},
	{ ATF_POINTER, 2, offsetof(struct RoadSideAlert, positon),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "positon"
		},
	{ ATF_POINTER, 1, offsetof(struct RoadSideAlert, furtherInfoID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FurtherInfoID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "furtherInfoID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RoadSideAlert, crc),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crc"
		},
};
static ber_tlv_tag_t asn_DEF_RoadSideAlert_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RoadSideAlert_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* typeEvent */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* description */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* priority */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* heading */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* extent */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* positon */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* furtherInfoID */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 } /* crc */
};
static asn_SEQUENCE_specifics_t asn_SPC_RoadSideAlert_specs_1 = {
	sizeof(struct RoadSideAlert),
	offsetof(struct RoadSideAlert, _asn_ctx),
	asn_MAP_RoadSideAlert_tag2el_1,
	10,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RoadSideAlert = {
	"RoadSideAlert",
	"RoadSideAlert",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RoadSideAlert_tags_1,
	sizeof(asn_DEF_RoadSideAlert_tags_1)
		/sizeof(asn_DEF_RoadSideAlert_tags_1[0]), /* 1 */
	asn_DEF_RoadSideAlert_tags_1,	/* Same as above */
	sizeof(asn_DEF_RoadSideAlert_tags_1)
		/sizeof(asn_DEF_RoadSideAlert_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RoadSideAlert_1,
	10,	/* Elements count */
	&asn_SPC_RoadSideAlert_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RTCM-Corrections] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "RTCM-Revision.h"
#include "RTCMHeader.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [RTCM-Corrections] >>> ***/

struct FullPositionVector;
struct RTCMmsg;

/*** <<< TYPE-DECLS [RTCM-Corrections] >>> ***/

typedef struct RTCM_Corrections {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	RTCM_Revision_t	 rev;
	struct FullPositionVector	*anchorPoint	/* OPTIONAL */;
	RTCMHeader_t	 rtcmHeader;
	struct rtcmSets {
		A_SEQUENCE_OF(struct RTCMmsg) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} rtcmSets;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RTCM_Corrections_t;

/*** <<< FUNC-DECLS [RTCM-Corrections] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCM_Corrections;

/*** <<< POST-INCLUDE [RTCM-Corrections] >>> ***/

#include "FullPositionVector.h"
#include "RTCMmsg.h"

/*** <<< CODE [RTCM-Corrections] >>> ***/

static int
memb_rtcmSets_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 5)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [RTCM-Corrections] >>> ***/

static asn_TYPE_member_t asn_MBR_rtcmSets_7[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_RTCMmsg,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_rtcmSets_tags_7[] = {
	(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_rtcmSets_specs_7 = {
	sizeof(struct rtcmSets),
	offsetof(struct rtcmSets, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_rtcmSets_7 = {
	"rtcmSets",
	"rtcmSets",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_rtcmSets_tags_7,
	sizeof(asn_DEF_rtcmSets_tags_7)
		/sizeof(asn_DEF_rtcmSets_tags_7[0]) - 1, /* 1 */
	asn_DEF_rtcmSets_tags_7,	/* Same as above */
	sizeof(asn_DEF_rtcmSets_tags_7)
		/sizeof(asn_DEF_rtcmSets_tags_7[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_rtcmSets_7,
	1,	/* Single element */
	&asn_SPC_rtcmSets_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RTCM_Corrections_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RTCM_Corrections, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RTCM_Corrections, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RTCM_Corrections, rev),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_Revision,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rev"
		},
	{ ATF_POINTER, 1, offsetof(struct RTCM_Corrections, anchorPoint),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "anchorPoint"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RTCM_Corrections, rtcmHeader),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCMHeader,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rtcmHeader"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RTCM_Corrections, rtcmSets),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_rtcmSets_7,
		.memb_constraints = memb_rtcmSets_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rtcmSets"
		},
};
static ber_tlv_tag_t asn_DEF_RTCM_Corrections_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RTCM_Corrections_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* rev */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* anchorPoint */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* rtcmHeader */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* rtcmSets */
};
static asn_SEQUENCE_specifics_t asn_SPC_RTCM_Corrections_specs_1 = {
	sizeof(struct RTCM_Corrections),
	offsetof(struct RTCM_Corrections, _asn_ctx),
	asn_MAP_RTCM_Corrections_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RTCM_Corrections = {
	"RTCM-Corrections",
	"RTCM-Corrections",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCM_Corrections_tags_1,
	sizeof(asn_DEF_RTCM_Corrections_tags_1)
		/sizeof(asn_DEF_RTCM_Corrections_tags_1[0]), /* 1 */
	asn_DEF_RTCM_Corrections_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCM_Corrections_tags_1)
		/sizeof(asn_DEF_RTCM_Corrections_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RTCM_Corrections_1,
	6,	/* Elements count */
	&asn_SPC_RTCM_Corrections_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SignalRequestMsg] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "SignalRequest.h"
#include "TransitStatus.h"
#include "BSMblob.h"
#include "VehicleRequestStatus.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [SignalRequestMsg] >>> ***/

struct DTime;
struct VehicleIdent;

/*** <<< TYPE-DECLS [SignalRequestMsg] >>> ***/

typedef struct SignalRequestMsg {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	SignalRequest_t	 request;
	struct DTime	*timeOfService	/* OPTIONAL */;
	struct DTime	*endOfService	/* OPTIONAL */;
	TransitStatus_t	*transitStatus	/* OPTIONAL */;
	struct VehicleIdent	*vehicleVIN	/* OPTIONAL */;
	BSMblob_t	 vehicleData;
	VehicleRequestStatus_t	*status	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SignalRequestMsg_t;

/*** <<< FUNC-DECLS [SignalRequestMsg] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalRequestMsg;

/*** <<< POST-INCLUDE [SignalRequestMsg] >>> ***/

#include "DTime.h"
#include "VehicleIdent.h"

/*** <<< STAT-DEFS [SignalRequestMsg] >>> ***/

static asn_TYPE_member_t asn_MBR_SignalRequestMsg_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SignalRequestMsg, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalRequestMsg, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalRequestMsg, request),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalRequest,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "request"
		},
	{ ATF_POINTER, 4, offsetof(struct SignalRequestMsg, timeOfService),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "timeOfService"
		},
	{ ATF_POINTER, 3, offsetof(struct SignalRequestMsg, endOfService),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "endOfService"
		},
	{ ATF_POINTER, 2, offsetof(struct SignalRequestMsg, transitStatus),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransitStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "transitStatus"
		},
	{ ATF_POINTER, 1, offsetof(struct SignalRequestMsg, vehicleVIN),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleIdent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleVIN"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalRequestMsg, vehicleData),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BSMblob,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleData"
		},
	{ ATF_POINTER, 1, offsetof(struct SignalRequestMsg, status),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleRequestStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "status"
		},
};
static ber_tlv_tag_t asn_DEF_SignalRequestMsg_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SignalRequestMsg_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* request */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* timeOfService */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* endOfService */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* transitStatus */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* vehicleVIN */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* vehicleData */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 } /* status */
};
static asn_SEQUENCE_specifics_t asn_SPC_SignalRequestMsg_specs_1 = {
	sizeof(struct SignalRequestMsg),
	offsetof(struct SignalRequestMsg, _asn_ctx),
	asn_MAP_SignalRequestMsg_tag2el_1,
	9,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	8,	/* Start extensions */
	10	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SignalRequestMsg = {
	"SignalRequestMsg",
	"SignalRequestMsg",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalRequestMsg_tags_1,
	sizeof(asn_DEF_SignalRequestMsg_tags_1)
		/sizeof(asn_DEF_SignalRequestMsg_tags_1[0]), /* 1 */
	asn_DEF_SignalRequestMsg_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalRequestMsg_tags_1)
		/sizeof(asn_DEF_SignalRequestMsg_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SignalRequestMsg_1,
	9,	/* Elements count */
	&asn_SPC_SignalRequestMsg_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SignalStatusMessage] >>> ***/

#include "DSRCmsgID.h"
#include "MsgCount.h"
#include "IntersectionID.h"
#include "IntersectionStatusObject.h"
#include "TransitStatus.h"
#include "SignalState.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [SignalStatusMessage] >>> ***/

struct VehicleIdent;

/*** <<< TYPE-DECLS [SignalStatusMessage] >>> ***/

typedef struct SignalStatusMessage {
	DSRCmsgID_t	 msgID;
	MsgCount_t	 msgCnt;
	IntersectionID_t	 id;
	IntersectionStatusObject_t	 status;
	struct priority {
		A_SEQUENCE_OF(SignalState_t) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *priority;
	struct VehicleIdent	*priorityCause	/* OPTIONAL */;
	struct prempt {
		A_SEQUENCE_OF(SignalState_t) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *prempt;
	struct VehicleIdent	*preemptCause	/* OPTIONAL */;
	TransitStatus_t	*transitStatus	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SignalStatusMessage_t;

/*** <<< FUNC-DECLS [SignalStatusMessage] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalStatusMessage;

/*** <<< POST-INCLUDE [SignalStatusMessage] >>> ***/

#include "VehicleIdent.h"

/*** <<< CODE [SignalStatusMessage] >>> ***/

static int
memb_priority_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 7)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_prempt_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 7)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [SignalStatusMessage] >>> ***/

static asn_TYPE_member_t asn_MBR_priority_6[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_SignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_priority_tags_6[] = {
	(ASN_TAG_CLASS_CONTEXT | (4 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_priority_specs_6 = {
	sizeof(struct priority),
	offsetof(struct priority, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_priority_6 = {
	"priority",
	"priority",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_priority_tags_6,
	sizeof(asn_DEF_priority_tags_6)
		/sizeof(asn_DEF_priority_tags_6[0]) - 1, /* 1 */
	asn_DEF_priority_tags_6,	/* Same as above */
	sizeof(asn_DEF_priority_tags_6)
		/sizeof(asn_DEF_priority_tags_6[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_priority_6,
	1,	/* Single element */
	&asn_SPC_priority_specs_6	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_prempt_9[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_SignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_prempt_tags_9[] = {
	(ASN_TAG_CLASS_CONTEXT | (6 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_prempt_specs_9 = {
	sizeof(struct prempt),
	offsetof(struct prempt, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_prempt_9 = {
	"prempt",
	"prempt",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_prempt_tags_9,
	sizeof(asn_DEF_prempt_tags_9)
		/sizeof(asn_DEF_prempt_tags_9[0]) - 1, /* 1 */
	asn_DEF_prempt_tags_9,	/* Same as above */
	sizeof(asn_DEF_prempt_tags_9)
		/sizeof(asn_DEF_prempt_tags_9[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_prempt_9,
	1,	/* Single element */
	&asn_SPC_prempt_specs_9	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_SignalStatusMessage_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SignalStatusMessage, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalStatusMessage, msgCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalStatusMessage, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalStatusMessage, status),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionStatusObject,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "status"
		},
	{ ATF_POINTER, 5, offsetof(struct SignalStatusMessage, priority),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_priority_6,
		.memb_constraints = memb_priority_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "priority"
		},
	{ ATF_POINTER, 4, offsetof(struct SignalStatusMessage, priorityCause),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleIdent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "priorityCause"
		},
	{ ATF_POINTER, 3, offsetof(struct SignalStatusMessage, prempt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_prempt_9,
		.memb_constraints = memb_prempt_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "prempt"
		},
	{ ATF_POINTER, 2, offsetof(struct SignalStatusMessage, preemptCause),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleIdent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "preemptCause"
		},
	{ ATF_POINTER, 1, offsetof(struct SignalStatusMessage, transitStatus),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransitStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "transitStatus"
		},
};
static ber_tlv_tag_t asn_DEF_SignalStatusMessage_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SignalStatusMessage_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* status */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* priority */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* priorityCause */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* prempt */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* preemptCause */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 } /* transitStatus */
};
static asn_SEQUENCE_specifics_t asn_SPC_SignalStatusMessage_specs_1 = {
	sizeof(struct SignalStatusMessage),
	offsetof(struct SignalStatusMessage, _asn_ctx),
	asn_MAP_SignalStatusMessage_tag2el_1,
	9,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	8,	/* Start extensions */
	10	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SignalStatusMessage = {
	"SignalStatusMessage",
	"SignalStatusMessage",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalStatusMessage_tags_1,
	sizeof(asn_DEF_SignalStatusMessage_tags_1)
		/sizeof(asn_DEF_SignalStatusMessage_tags_1[0]), /* 1 */
	asn_DEF_SignalStatusMessage_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalStatusMessage_tags_1)
		/sizeof(asn_DEF_SignalStatusMessage_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SignalStatusMessage_1,
	9,	/* Elements count */
	&asn_SPC_SignalStatusMessage_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SPAT] >>> ***/

#include "DSRCmsgID.h"
#include "DescriptiveName.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [SPAT] >>> ***/

struct IntersectionState;

/*** <<< TYPE-DECLS [SPAT] >>> ***/

typedef struct SPAT {
	DSRCmsgID_t	 msgID;
	DescriptiveName_t	*name	/* OPTIONAL */;
	struct intersections {
		A_SEQUENCE_OF(struct IntersectionState) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} intersections;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SPAT_t;

/*** <<< FUNC-DECLS [SPAT] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SPAT;

/*** <<< POST-INCLUDE [SPAT] >>> ***/

#include "IntersectionState.h"

/*** <<< CODE [SPAT] >>> ***/

static int
memb_intersections_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [SPAT] >>> ***/

static asn_TYPE_member_t asn_MBR_intersections_4[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_IntersectionState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_intersections_tags_4[] = {
	(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_intersections_specs_4 = {
	sizeof(struct intersections),
	offsetof(struct intersections, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_intersections_4 = {
	"intersections",
	"intersections",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_intersections_tags_4,
	sizeof(asn_DEF_intersections_tags_4)
		/sizeof(asn_DEF_intersections_tags_4[0]) - 1, /* 1 */
	asn_DEF_intersections_tags_4,	/* Same as above */
	sizeof(asn_DEF_intersections_tags_4)
		/sizeof(asn_DEF_intersections_tags_4[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_intersections_4,
	1,	/* Single element */
	&asn_SPC_intersections_specs_4	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_SPAT_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SPAT, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_POINTER, 1, offsetof(struct SPAT, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SPAT, intersections),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_intersections_4,
		.memb_constraints = memb_intersections_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "intersections"
		},
};
static ber_tlv_tag_t asn_DEF_SPAT_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SPAT_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* intersections */
};
static asn_SEQUENCE_specifics_t asn_SPC_SPAT_specs_1 = {
	sizeof(struct SPAT),
	offsetof(struct SPAT, _asn_ctx),
	asn_MAP_SPAT_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	2,	/* Start extensions */
	4	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SPAT = {
	"SPAT",
	"SPAT",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SPAT_tags_1,
	sizeof(asn_DEF_SPAT_tags_1)
		/sizeof(asn_DEF_SPAT_tags_1[0]), /* 1 */
	asn_DEF_SPAT_tags_1,	/* Same as above */
	sizeof(asn_DEF_SPAT_tags_1)
		/sizeof(asn_DEF_SPAT_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SPAT_1,
	3,	/* Elements count */
	&asn_SPC_SPAT_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TravelerInformation] >>> ***/

#include "DSRCmsgID.h"
#include "UniqueMSGID.h"
#include "URL-Base.h"
#include "Count.h"
#include "MsgCRC.h"
#include <asn_SEQUENCE_OF.h>
#include "TravelerInfoType.h"
#include "DYear.h"
#include "MinuteOfTheYear.h"
#include "MinutesDuration.h"
#include "SignPrority.h"
#include "LaneWidth.h"
#include "DirectionOfUse.h"
#include "URL-Short.h"
#include "FurtherInfoID.h"
#include "RoadSignID.h"
#include <constr_CHOICE.h>
#include <constr_SEQUENCE_OF.h>
#include "ITIScodesAndText.h"
#include "WorkZone.h"
#include "GenericSignage.h"
#include "SpeedLimit.h"
#include "ExitService.h"
#include <constr_SEQUENCE.h>

/*** <<< DEPS [TravelerInformation] >>> ***/

typedef enum msgId_PR {
	msgId_PR_NOTHING,	/* No components present */
	msgId_PR_furtherInfoID,
	msgId_PR_roadSignID
} msgId_PR;
typedef enum content_PR {
	content_PR_NOTHING,	/* No components present */
	content_PR_advisory,
	content_PR_workZone,
	content_PR_genericSign,
	content_PR_speedLimit,
	content_PR_exitService
} content_PR;

/*** <<< FWD-DECLS [TravelerInformation] >>> ***/

struct Position3D;
struct ValidRegion;

/*** <<< TYPE-DECLS [TravelerInformation] >>> ***/

typedef struct TravelerInformation {
	DSRCmsgID_t	 msgID;
	UniqueMSGID_t	*packetID	/* OPTIONAL */;
	URL_Base_t	*urlB	/* OPTIONAL */;
	Count_t	*dataFrameCount	/* OPTIONAL */;
	struct dataFrames {
		A_SEQUENCE_OF(struct Member {
			TravelerInfoType_t	 frameType;
			struct msgId {
				msgId_PR present;
				union msgId_u {
					FurtherInfoID_t	 furtherInfoID;
					RoadSignID_t	 roadSignID;
				} choice;
				
				/* Context for parsing across buffer boundaries */
				asn_struct_ctx_t _asn_ctx;
			} msgId;
			DYear_t	*startYear	/* OPTIONAL */;
			MinuteOfTheYear_t	 startTime;
			MinutesDuration_t	 duratonTime;
			SignPrority_t	 priority;
			struct Position3D	*commonAnchor	/* OPTIONAL */;
			LaneWidth_t	*commonLaneWidth	/* OPTIONAL */;
			DirectionOfUse_t	*commonDirectionality	/* OPTIONAL */;
			struct regions {
				A_SEQUENCE_OF(struct ValidRegion) list;
				
				/* Context for parsing across buffer boundaries */
				asn_struct_ctx_t _asn_ctx;
			} regions;
			struct content {
				content_PR present;
				union content_u {
					ITIScodesAndText_t	 advisory;
					WorkZone_t	 workZone;
					GenericSignage_t	 genericSign;
					SpeedLimit_t	 speedLimit;
					ExitService_t	 exitService;
				} choice;
				
				/* Context for parsing across buffer boundaries */
				asn_struct_ctx_t _asn_ctx;
			} content;
			URL_Short_t	*url	/* OPTIONAL */;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} ) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} dataFrames;
	MsgCRC_t	 crc;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} TravelerInformation_t;

/*** <<< FUNC-DECLS [TravelerInformation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TravelerInformation;

/*** <<< POST-INCLUDE [TravelerInformation] >>> ***/

#include "Position3D.h"
#include "ValidRegion.h"

/*** <<< CODE [TravelerInformation] >>> ***/

static int
memb_regions_constraint_7(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 16)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_dataFrames_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 8)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [TravelerInformation] >>> ***/

static asn_TYPE_member_t asn_MBR_msgId_9[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct msgId, choice.furtherInfoID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FurtherInfoID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "furtherInfoID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct msgId, choice.roadSignID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RoadSignID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "roadSignID"
		},
};
static asn_TYPE_tag2member_t asn_MAP_msgId_tag2el_9[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* furtherInfoID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* roadSignID */
};
static asn_CHOICE_specifics_t asn_SPC_msgId_specs_9 = {
	sizeof(struct msgId),
	offsetof(struct msgId, _asn_ctx),
	offsetof(struct msgId, present),
	sizeof(((struct msgId *)0)->present),
	asn_MAP_msgId_tag2el_9,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_msgId_9 = {
	"msgId",
	"msgId",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_msgId_9,
	2,	/* Elements count */
	&asn_SPC_msgId_specs_9	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_regions_19[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_ValidRegion,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_regions_tags_19[] = {
	(ASN_TAG_CLASS_CONTEXT | (9 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_regions_specs_19 = {
	sizeof(struct regions),
	offsetof(struct regions, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_regions_19 = {
	"regions",
	"regions",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_regions_tags_19,
	sizeof(asn_DEF_regions_tags_19)
		/sizeof(asn_DEF_regions_tags_19[0]) - 1, /* 1 */
	asn_DEF_regions_tags_19,	/* Same as above */
	sizeof(asn_DEF_regions_tags_19)
		/sizeof(asn_DEF_regions_tags_19[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_regions_19,
	1,	/* Single element */
	&asn_SPC_regions_specs_19	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_content_21[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct content, choice.advisory),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodesAndText,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "advisory"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct content, choice.workZone),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WorkZone,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "workZone"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct content, choice.genericSign),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_GenericSignage,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "genericSign"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct content, choice.speedLimit),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedLimit,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speedLimit"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct content, choice.exitService),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExitService,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "exitService"
		},
};
static asn_TYPE_tag2member_t asn_MAP_content_tag2el_21[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* advisory */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* workZone */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* genericSign */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* speedLimit */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* exitService */
};
static asn_CHOICE_specifics_t asn_SPC_content_specs_21 = {
	sizeof(struct content),
	offsetof(struct content, _asn_ctx),
	offsetof(struct content, present),
	sizeof(((struct content *)0)->present),
	asn_MAP_content_tag2el_21,
	5,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_content_21 = {
	"content",
	"content",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_content_21,
	5,	/* Elements count */
	&asn_SPC_content_specs_21	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_7[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, frameType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TravelerInfoType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "frameType"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, msgId),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_msgId_9,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgId"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, startYear),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "startYear"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, startTime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MinuteOfTheYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "startTime"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, duratonTime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MinutesDuration,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "duratonTime"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, priority),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignPrority,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "priority"
		},
	{ ATF_POINTER, 3, offsetof(struct Member, commonAnchor),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "commonAnchor"
		},
	{ ATF_POINTER, 2, offsetof(struct Member, commonLaneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "commonLaneWidth"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, commonDirectionality),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DirectionOfUse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "commonDirectionality"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, regions),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_regions_19,
		.memb_constraints = memb_regions_constraint_7,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "regions"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, content),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_content_21,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "content"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, url),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_URL_Short,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "url"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_7[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_7[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* frameType */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* msgId */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* startYear */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* startTime */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* duratonTime */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* priority */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* commonAnchor */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* commonLaneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* commonDirectionality */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* regions */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* content */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 } /* url */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_7 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_7,
	12,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_7 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_7,
	sizeof(asn_DEF_Member_tags_7)
		/sizeof(asn_DEF_Member_tags_7[0]), /* 1 */
	asn_DEF_Member_tags_7,	/* Same as above */
	sizeof(asn_DEF_Member_tags_7)
		/sizeof(asn_DEF_Member_tags_7[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_7,
	12,	/* Elements count */
	&asn_SPC_Member_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_dataFrames_6[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_7,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_dataFrames_tags_6[] = {
	(ASN_TAG_CLASS_CONTEXT | (4 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_dataFrames_specs_6 = {
	sizeof(struct dataFrames),
	offsetof(struct dataFrames, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_dataFrames_6 = {
	"dataFrames",
	"dataFrames",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_dataFrames_tags_6,
	sizeof(asn_DEF_dataFrames_tags_6)
		/sizeof(asn_DEF_dataFrames_tags_6[0]) - 1, /* 1 */
	asn_DEF_dataFrames_tags_6,	/* Same as above */
	sizeof(asn_DEF_dataFrames_tags_6)
		/sizeof(asn_DEF_dataFrames_tags_6[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_dataFrames_6,
	1,	/* Single element */
	&asn_SPC_dataFrames_specs_6	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_TravelerInformation_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct TravelerInformation, msgID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msgID"
		},
	{ ATF_POINTER, 3, offsetof(struct TravelerInformation, packetID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniqueMSGID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "packetID"
		},
	{ ATF_POINTER, 2, offsetof(struct TravelerInformation, urlB),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_URL_Base,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "urlB"
		},
	{ ATF_POINTER, 1, offsetof(struct TravelerInformation, dataFrameCount),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Count,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "dataFrameCount"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct TravelerInformation, dataFrames),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_dataFrames_6,
		.memb_constraints = memb_dataFrames_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "dataFrames"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct TravelerInformation, crc),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crc"
		},
};
static ber_tlv_tag_t asn_DEF_TravelerInformation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_TravelerInformation_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* msgID */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* packetID */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* urlB */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* dataFrameCount */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* dataFrames */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* crc */
};
static asn_SEQUENCE_specifics_t asn_SPC_TravelerInformation_specs_1 = {
	sizeof(struct TravelerInformation),
	offsetof(struct TravelerInformation, _asn_ctx),
	asn_MAP_TravelerInformation_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_TravelerInformation = {
	"TravelerInformation",
	"TravelerInformation",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TravelerInformation_tags_1,
	sizeof(asn_DEF_TravelerInformation_tags_1)
		/sizeof(asn_DEF_TravelerInformation_tags_1[0]), /* 1 */
	asn_DEF_TravelerInformation_tags_1,	/* Same as above */
	sizeof(asn_DEF_TravelerInformation_tags_1)
		/sizeof(asn_DEF_TravelerInformation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_TravelerInformation_1,
	6,	/* Elements count */
	&asn_SPC_TravelerInformation_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [AccelerationSet4Way] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [AccelerationSet4Way] >>> ***/

typedef OCTET_STRING_t	 AccelerationSet4Way_t;

/*** <<< FUNC-DECLS [AccelerationSet4Way] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AccelerationSet4Way;
asn_struct_free_f AccelerationSet4Way_free;
asn_struct_print_f AccelerationSet4Way_print;
asn_constr_check_f AccelerationSet4Way_constraint;
ber_type_decoder_f AccelerationSet4Way_decode_ber;
der_type_encoder_f AccelerationSet4Way_encode_der;
xer_type_decoder_f AccelerationSet4Way_decode_xer;
xer_type_encoder_f AccelerationSet4Way_encode_xer;

/*** <<< CODE [AccelerationSet4Way] >>> ***/

int
AccelerationSet4Way_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 7)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
AccelerationSet4Way_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
AccelerationSet4Way_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AccelerationSet4Way_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AccelerationSet4Way_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AccelerationSet4Way_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AccelerationSet4Way_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AccelerationSet4Way_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AccelerationSet4Way_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AccelerationSet4Way_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AccelerationSet4Way_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AccelerationSet4Way_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AccelerationSet4Way_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AccelerationSet4Way_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AccelerationSet4Way] >>> ***/

static ber_tlv_tag_t asn_DEF_AccelerationSet4Way_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AccelerationSet4Way = {
	"AccelerationSet4Way",
	"AccelerationSet4Way",
	AccelerationSet4Way_free,
	AccelerationSet4Way_print,
	AccelerationSet4Way_constraint,
	AccelerationSet4Way_decode_ber,
	AccelerationSet4Way_encode_der,
	AccelerationSet4Way_decode_xer,
	AccelerationSet4Way_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AccelerationSet4Way_tags_1,
	sizeof(asn_DEF_AccelerationSet4Way_tags_1)
		/sizeof(asn_DEF_AccelerationSet4Way_tags_1[0]), /* 1 */
	asn_DEF_AccelerationSet4Way_tags_1,	/* Same as above */
	sizeof(asn_DEF_AccelerationSet4Way_tags_1)
		/sizeof(asn_DEF_AccelerationSet4Way_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [AccelSteerYawRateConfidence] >>> ***/

#include "YawRateConfidence.h"
#include "AccelerationConfidence.h"
#include "SteeringWheelAngleConfidence.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [AccelSteerYawRateConfidence] >>> ***/

typedef struct AccelSteerYawRateConfidence {
	YawRateConfidence_t	 yawRate;
	AccelerationConfidence_t	 acceleration;
	SteeringWheelAngleConfidence_t	 steeringWheelAngle;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} AccelSteerYawRateConfidence_t;

/*** <<< FUNC-DECLS [AccelSteerYawRateConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AccelSteerYawRateConfidence;

/*** <<< STAT-DEFS [AccelSteerYawRateConfidence] >>> ***/

static asn_TYPE_member_t asn_MBR_AccelSteerYawRateConfidence_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct AccelSteerYawRateConfidence, yawRate),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_YawRateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yawRate"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct AccelSteerYawRateConfidence, acceleration),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelerationConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "acceleration"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct AccelSteerYawRateConfidence, steeringWheelAngle),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "steeringWheelAngle"
		},
};
static ber_tlv_tag_t asn_DEF_AccelSteerYawRateConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_AccelSteerYawRateConfidence_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* yawRate */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* acceleration */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* steeringWheelAngle */
};
static asn_SEQUENCE_specifics_t asn_SPC_AccelSteerYawRateConfidence_specs_1 = {
	sizeof(struct AccelSteerYawRateConfidence),
	offsetof(struct AccelSteerYawRateConfidence, _asn_ctx),
	asn_MAP_AccelSteerYawRateConfidence_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_AccelSteerYawRateConfidence = {
	"AccelSteerYawRateConfidence",
	"AccelSteerYawRateConfidence",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AccelSteerYawRateConfidence_tags_1,
	sizeof(asn_DEF_AccelSteerYawRateConfidence_tags_1)
		/sizeof(asn_DEF_AccelSteerYawRateConfidence_tags_1[0]), /* 1 */
	asn_DEF_AccelSteerYawRateConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_AccelSteerYawRateConfidence_tags_1)
		/sizeof(asn_DEF_AccelSteerYawRateConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_AccelSteerYawRateConfidence_1,
	3,	/* Elements count */
	&asn_SPC_AccelSteerYawRateConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [AllInclusive] >>> ***/

#include "AccelerationSet4Way.h"
#include "AntennaOffsetSet.h"
#include "BrakeSystemStatus.h"
#include "BSMblob.h"
#include "ConnectsTo.h"
#include "Offsets.h"
#include "PathHistoryPointType-02.h"
#include "PathHistoryPointType-03.h"
#include "PathHistoryPointType-04.h"
#include "PathHistoryPointType-05.h"
#include "PathHistoryPointType-06.h"
#include "PathHistoryPointType-07.h"
#include "PathHistoryPointType-08.h"
#include "PathHistoryPointType-09.h"
#include "PathHistoryPointType-10.h"
#include "PositionalAccuracy.h"
#include "PositionConfidenceSet.h"
#include "RTCMHeader.h"
#include "SpeedandHeadingandThrottleConfidence.h"
#include "TransmissionAndSpeed.h"
#include "Acceleration.h"
#include "AccelerationConfidence.h"
#include "AmbientAirPressure.h"
#include "AmbientAirTemperature.h"
#include "AntiLockBrakeStatus.h"
#include "ApproachNumber.h"
#include "AuxiliaryBrakeStatus.h"
#include "BarrierAttributes.h"
#include "BrakeAppliedPressure.h"
#include "BrakeAppliedStatus.h"
#include "BrakeBoostApplied.h"
#include "BumperHeightFront.h"
#include "BumperHeightRear.h"
#include "CodeWord.h"
#include "CoefficientOfFriction.h"
#include "ColorState.h"
#include "Count.h"
#include "CrosswalkLaneAttributes.h"
#include "DDay.h"
#include "DescriptiveName.h"
#include "DHour.h"
#include "DirectionOfUse.h"
#include "DMinute.h"
#include "DMonth.h"
#include "DOffset.h"
#include "DrivenLineOffset.h"
#include "DrivingWheelAngle.h"
#include "DSecond.h"
#include "DSignalSeconds.h"
#include "DSRCmsgID.h"
#include "DYear.h"
#include "ElevationConfidence.h"
#include "Elevation.h"
#include "EmergencyDetails.h"
#include "EventFlags.h"
#include "Extent.h"
#include "ExteriorLights.h"
#include "FurtherInfoID.h"
#include "GPSstatus.h"
#include "HeadingConfidence.h"
#include "Heading.h"
#include "HeadingSlice.h"
#include "IntersectionStatusObject.h"
#include "IntersectionID.h"
#include "AxleLocation.h"
#include "AxleWeight.h"
#include "CargoWeight.h"
#include "DriveAxleLiftAirPressure.h"
#include "DriveAxleLocation.h"
#include "DriveAxleLubePressure.h"
#include "DriveAxleTemperature.h"
#include "SteeringAxleLubePressure.h"
#include "SteeringAxleTemperature.h"
#include "TireLeakageRate.h"
#include "TireLocation.h"
#include "TirePressureThresholdDetection.h"
#include "TirePressure.h"
#include "TireTemp.h"
#include "TrailerWeight.h"
#include "WheelEndElectFault.h"
#include "WheelSensorStatus.h"
#include "LaneCount.h"
#include "LaneManeuverCode.h"
#include "LaneNumber.h"
#include "LaneSet.h"
#include "LaneWidth.h"
#include "Latitude.h"
#include "LayerID.h"
#include "LayerType.h"
#include "LightbarInUse.h"
#include "Longitude.h"
#include "Location-quality.h"
#include "Location-tech.h"
#include "MinuteOfTheYear.h"
#include "MinutesDuration.h"
#include "MsgCount.h"
#include "MsgCRC.h"
#include "MultiVehicleResponse.h"
#include "MUTCDCode.h"
#include "NMEA-MsgType.h"
#include "NMEA-Payload.h"
#include "NMEA-Revision.h"
#include "NTCIPVehicleclass.h"
#include "ObjectCount.h"
#include "ObstacleDirection.h"
#include "ObstacleDistance.h"
#include "PayloadData.h"
#include "Payload.h"
#include "PedestrianDetect.h"
#include "PedestrianSignalState.h"
#include "PositionConfidence.h"
#include "PreemptState.h"
#include "Priority.h"
#include "PriorityState.h"
#include "ProbeSegmentNumber.h"
#include "RainSensor.h"
#include "RequestedItem.h"
#include "ResponseType.h"
#include "RTCM-ID.h"
#include "RTCM-Payload.h"
#include "RTCM-Revision.h"
#include "SignalLightState.h"
#include "SignalReqScheme.h"
#include "SignalState.h"
#include "SignPrority.h"
#include "SirenInUse.h"
#include "SpecialLaneAttributes.h"
#include "SpecialSignalState.h"
#include "SpeedConfidence.h"
#include "Speed.h"
#include "StabilityControlStatus.h"
#include "StateConfidence.h"
#include "SteeringWheelAngleConfidence.h"
#include "SteeringWheelAngleRateOfChange.h"
#include "SteeringWheelAngle.h"
#include "SunSensor.h"
#include "TemporaryID.h"
#include "TermDistance.h"
#include "TermTime.h"
#include "ThrottleConfidence.h"
#include "ThrottlePosition.h"
#include "TimeConfidence.h"
#include "TimeMark.h"
#include "TractionControlState.h"
#include "TransitPreEmptionRequest.h"
#include "TransitStatus.h"
#include "TransmissionState.h"
#include "TxTime.h"
#include "TravelerInfoType.h"
#include "UniqueMSGID.h"
#include "URL-Base.h"
#include "URL-Link.h"
#include "URL-Short.h"
#include "VehicleHeight.h"
#include "VehicleLaneAttributes.h"
#include "VehicleLength.h"
#include "VehicleMass.h"
#include "VehicleRequestStatus.h"
#include "VehicleStatusDeviceTypeTag.h"
#include "VehicleType.h"
#include "VehicleWidth.h"
#include "VerticalAccelerationThreshold.h"
#include "VerticalAcceleration.h"
#include "VINstring.h"
#include "WiperRate.h"
#include "WiperStatusFront.h"
#include "WiperStatusRear.h"
#include "YawRateConfidence.h"
#include "YawRate.h"
#include "IncidentResponseEquipment.h"
#include "ITIStext.h"
#include "ResponderGroupAffected.h"
#include "VehicleGroupAffected.h"
#include "EssMobileFriction.h"
#include "EssPrecipRate.h"
#include "EssPrecipSituation.h"
#include "EssPrecipYesNo.h"
#include "EssSolarRadiation.h"
#include "ITIScodes.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [AllInclusive] >>> ***/

struct AccelSteerYawRateConfidence;
struct Approach;
struct ApproachObject;
struct BarrierLane;
struct BumperHeights;
struct Circle;
struct ConfidenceSet;
struct CrosswalkLane;
struct DataParameters;
struct DDate;
struct DDateTime;
struct DFullTime;
struct DMonthDay;
struct DTime;
struct DYearMonth;
struct FullPositionVector;
struct Intersection;
struct IntersectionState;
struct ExitService;
struct GenericSignage;
struct SpeedLimit;
struct WorkZone;
struct J1939data;
struct MovementState;
struct NodeList;
struct PathHistory;
struct PathHistoryPointType_01;
struct PathPrediction;
struct Position3D;
struct RegionList;
struct RegionOffsets;
struct RegionPointSet;
struct RoadSignID;
struct RTCMmsg;
struct RTCMPackage;
struct Sample;
struct ShapePointSet;
struct SignalControlZone;
struct SignalRequest;
struct SnapshotDistance;
struct Snapshot;
struct SnapshotTime;
struct SpecialLane;
struct ValidRegion;
struct VehicleComputedLane;
struct VehicleIdent;
struct VehicleReferenceLane;
struct VehicleSafetyExtension;
struct VehicleSize;
struct VehicleStatusRequest;
struct VehicleStatus;
struct WiperStatus;
struct ITIScodesAndText;

/*** <<< TYPE-DECLS [AllInclusive] >>> ***/

typedef struct AllInclusive {
	AccelerationSet4Way_t	*item6_1	/* OPTIONAL */;
	struct AccelSteerYawRateConfidence	*item6_2	/* OPTIONAL */;
	AntennaOffsetSet_t	*item6_4	/* OPTIONAL */;
	struct Approach	*item6_5	/* OPTIONAL */;
	struct ApproachObject	*item6_6	/* OPTIONAL */;
	struct BarrierLane	*item6_7	/* OPTIONAL */;
	BrakeSystemStatus_t	*item6_8	/* OPTIONAL */;
	BSMblob_t	*item6_9	/* OPTIONAL */;
	struct BumperHeights	*item6_10	/* OPTIONAL */;
	struct Circle	*item6_11	/* OPTIONAL */;
	struct ConfidenceSet	*item6_12	/* OPTIONAL */;
	ConnectsTo_t	*item6_13	/* OPTIONAL */;
	struct CrosswalkLane	*item6_14	/* OPTIONAL */;
	struct DataParameters	*item6_15	/* OPTIONAL */;
	struct DDate	*item6_16	/* OPTIONAL */;
	struct DDateTime	*item6_17	/* OPTIONAL */;
	struct DFullTime	*item6_18	/* OPTIONAL */;
	struct DMonthDay	*item6_19	/* OPTIONAL */;
	struct DTime	*item6_20	/* OPTIONAL */;
	struct DYearMonth	*item6_21	/* OPTIONAL */;
	struct FullPositionVector	*item6_22	/* OPTIONAL */;
	struct Intersection	*item6_23	/* OPTIONAL */;
	struct IntersectionState	*item6_24	/* OPTIONAL */;
	struct ExitService	*item6_25	/* OPTIONAL */;
	struct GenericSignage	*item6_26	/* OPTIONAL */;
	struct SpeedLimit	*item6_27	/* OPTIONAL */;
	struct WorkZone	*item6_28	/* OPTIONAL */;
	struct J1939data	*item6_29	/* OPTIONAL */;
	struct MovementState	*item6_30	/* OPTIONAL */;
	struct NodeList	*item6_31	/* OPTIONAL */;
	Offsets_t	*item6_32	/* OPTIONAL */;
	struct PathHistory	*item6_33	/* OPTIONAL */;
	struct PathHistoryPointType_01	*item6_34	/* OPTIONAL */;
	PathHistoryPointType_02_t	*item6_35	/* OPTIONAL */;
	PathHistoryPointType_03_t	*item6_36	/* OPTIONAL */;
	PathHistoryPointType_04_t	*item6_37	/* OPTIONAL */;
	PathHistoryPointType_05_t	*item6_38	/* OPTIONAL */;
	PathHistoryPointType_06_t	*item6_39	/* OPTIONAL */;
	PathHistoryPointType_07_t	*item6_40	/* OPTIONAL */;
	PathHistoryPointType_08_t	*item6_41	/* OPTIONAL */;
	PathHistoryPointType_09_t	*item6_42	/* OPTIONAL */;
	PathHistoryPointType_10_t	*item6_43	/* OPTIONAL */;
	struct PathPrediction	*item6_44	/* OPTIONAL */;
	struct Position3D	*item6_45	/* OPTIONAL */;
	PositionalAccuracy_t	*item6_46	/* OPTIONAL */;
	PositionConfidenceSet_t	*item6_47	/* OPTIONAL */;
	struct RegionList	*item6_48	/* OPTIONAL */;
	struct RegionOffsets	*item6_49	/* OPTIONAL */;
	struct RegionPointSet	*item6_50	/* OPTIONAL */;
	struct RoadSignID	*item6_51	/* OPTIONAL */;
	RTCMHeader_t	*item6_52	/* OPTIONAL */;
	struct RTCMmsg	*item6_53	/* OPTIONAL */;
	struct RTCMPackage	*item6_54	/* OPTIONAL */;
	struct Sample	*item6_55	/* OPTIONAL */;
	struct ShapePointSet	*item6_56	/* OPTIONAL */;
	struct SignalControlZone	*item6_57	/* OPTIONAL */;
	struct SignalRequest	*item6_58	/* OPTIONAL */;
	struct SnapshotDistance	*item6_59	/* OPTIONAL */;
	struct Snapshot	*item6_60	/* OPTIONAL */;
	struct SnapshotTime	*item6_61	/* OPTIONAL */;
	struct SpecialLane	*item6_62	/* OPTIONAL */;
	SpeedandHeadingandThrottleConfidence_t	*item6_63	/* OPTIONAL */;
	TransmissionAndSpeed_t	*item6_64	/* OPTIONAL */;
	struct ValidRegion	*item6_65	/* OPTIONAL */;
	struct VehicleComputedLane	*item6_66	/* OPTIONAL */;
	struct VehicleIdent	*item6_67	/* OPTIONAL */;
	struct VehicleReferenceLane	*item6_68	/* OPTIONAL */;
	struct VehicleSafetyExtension	*item6_69	/* OPTIONAL */;
	struct VehicleSize	*item6_70	/* OPTIONAL */;
	struct VehicleStatusRequest	*item6_71	/* OPTIONAL */;
	struct VehicleStatus	*item6_72	/* OPTIONAL */;
	struct WiperStatus	*item6_73	/* OPTIONAL */;
	Acceleration_t	*item7_1	/* OPTIONAL */;
	AccelerationConfidence_t	*item7_2	/* OPTIONAL */;
	AmbientAirPressure_t	*item7_3	/* OPTIONAL */;
	AmbientAirTemperature_t	*item7_4	/* OPTIONAL */;
	AntiLockBrakeStatus_t	*item7_5	/* OPTIONAL */;
	ApproachNumber_t	*item7_6	/* OPTIONAL */;
	AuxiliaryBrakeStatus_t	*item7_7	/* OPTIONAL */;
	BarrierAttributes_t	*item7_8	/* OPTIONAL */;
	BrakeAppliedPressure_t	*item7_9	/* OPTIONAL */;
	BrakeAppliedStatus_t	*item7_10	/* OPTIONAL */;
	BrakeBoostApplied_t	*item7_11	/* OPTIONAL */;
	BumperHeightFront_t	*item7_12	/* OPTIONAL */;
	BumperHeightRear_t	*item7_13	/* OPTIONAL */;
	CodeWord_t	*item7_14	/* OPTIONAL */;
	CoefficientOfFriction_t	*item7_15	/* OPTIONAL */;
	ColorState_t	*item7_16	/* OPTIONAL */;
	Count_t	*item7_17	/* OPTIONAL */;
	CrosswalkLaneAttributes_t	*item7_18	/* OPTIONAL */;
	DDay_t	*item7_19	/* OPTIONAL */;
	DescriptiveName_t	*item7_20	/* OPTIONAL */;
	DHour_t	*item7_21	/* OPTIONAL */;
	DirectionOfUse_t	*item7_22	/* OPTIONAL */;
	DMinute_t	*item7_23	/* OPTIONAL */;
	DMonth_t	*item7_24	/* OPTIONAL */;
	DOffset_t	*item7_25	/* OPTIONAL */;
	DrivenLineOffset_t	*item7_26	/* OPTIONAL */;
	DrivingWheelAngle_t	*item7_27	/* OPTIONAL */;
	DSecond_t	*item7_28	/* OPTIONAL */;
	DSignalSeconds_t	*item7_29	/* OPTIONAL */;
	DSRCmsgID_t	*item7_30	/* OPTIONAL */;
	DYear_t	*item7_31	/* OPTIONAL */;
	ElevationConfidence_t	*item7_32	/* OPTIONAL */;
	Elevation_t	*item7_33	/* OPTIONAL */;
	EmergencyDetails_t	*item7_34	/* OPTIONAL */;
	EventFlags_t	*item7_35	/* OPTIONAL */;
	Extent_t	*item7_36	/* OPTIONAL */;
	ExteriorLights_t	*item7_37	/* OPTIONAL */;
	FurtherInfoID_t	*item7_38	/* OPTIONAL */;
	GPSstatus_t	*item7_39	/* OPTIONAL */;
	HeadingConfidence_t	*item7_40	/* OPTIONAL */;
	Heading_t	*item7_41	/* OPTIONAL */;
	HeadingSlice_t	*item7_42	/* OPTIONAL */;
	IntersectionStatusObject_t	*item7_43	/* OPTIONAL */;
	IntersectionID_t	*item7_44	/* OPTIONAL */;
	AxleLocation_t	*item7_45	/* OPTIONAL */;
	AxleWeight_t	*item7_46	/* OPTIONAL */;
	CargoWeight_t	*item7_47	/* OPTIONAL */;
	DriveAxleLiftAirPressure_t	*item7_48	/* OPTIONAL */;
	DriveAxleLocation_t	*item7_49	/* OPTIONAL */;
	DriveAxleLubePressure_t	*item7_50	/* OPTIONAL */;
	DriveAxleTemperature_t	*item7_51	/* OPTIONAL */;
	SteeringAxleLubePressure_t	*item7_52	/* OPTIONAL */;
	SteeringAxleTemperature_t	*item7_53	/* OPTIONAL */;
	TireLeakageRate_t	*item7_54	/* OPTIONAL */;
	TireLocation_t	*item7_55	/* OPTIONAL */;
	TirePressureThresholdDetection_t	*item7_56	/* OPTIONAL */;
	TirePressure_t	*item7_57	/* OPTIONAL */;
	TireTemp_t	*item7_58	/* OPTIONAL */;
	TrailerWeight_t	*item7_59	/* OPTIONAL */;
	WheelEndElectFault_t	*item7_60	/* OPTIONAL */;
	WheelSensorStatus_t	*item7_61	/* OPTIONAL */;
	LaneCount_t	*item7_62	/* OPTIONAL */;
	LaneManeuverCode_t	*item7_63	/* OPTIONAL */;
	LaneNumber_t	*item7_64	/* OPTIONAL */;
	LaneSet_t	*item7_65	/* OPTIONAL */;
	LaneWidth_t	*item7_66	/* OPTIONAL */;
	Latitude_t	*item7_67	/* OPTIONAL */;
	LayerID_t	*item7_68	/* OPTIONAL */;
	LayerType_t	*item7_69	/* OPTIONAL */;
	LightbarInUse_t	*item7_70	/* OPTIONAL */;
	Longitude_t	*item7_71	/* OPTIONAL */;
	Location_quality_t	*item7_72	/* OPTIONAL */;
	Location_tech_t	*item7_73	/* OPTIONAL */;
	MinuteOfTheYear_t	*item7_74	/* OPTIONAL */;
	MinutesDuration_t	*item7_75	/* OPTIONAL */;
	MsgCount_t	*item7_76	/* OPTIONAL */;
	MsgCRC_t	*item7_77	/* OPTIONAL */;
	MultiVehicleResponse_t	*item7_78	/* OPTIONAL */;
	MUTCDCode_t	*item7_79	/* OPTIONAL */;
	NMEA_MsgType_t	*item7_80	/* OPTIONAL */;
	NMEA_Payload_t	*item7_81	/* OPTIONAL */;
	NMEA_Revision_t	*item7_82	/* OPTIONAL */;
	NTCIPVehicleclass_t	*item7_83	/* OPTIONAL */;
	ObjectCount_t	*item7_84	/* OPTIONAL */;
	ObstacleDirection_t	*item7_85	/* OPTIONAL */;
	ObstacleDistance_t	*item7_86	/* OPTIONAL */;
	PayloadData_t	*item7_87	/* OPTIONAL */;
	Payload_t	*item7_88	/* OPTIONAL */;
	PedestrianDetect_t	*item7_89	/* OPTIONAL */;
	PedestrianSignalState_t	*item7_90	/* OPTIONAL */;
	PositionConfidence_t	*item7_91	/* OPTIONAL */;
	PreemptState_t	*item7_92	/* OPTIONAL */;
	Priority_t	*item7_93	/* OPTIONAL */;
	PriorityState_t	*item7_94	/* OPTIONAL */;
	ProbeSegmentNumber_t	*item7_95	/* OPTIONAL */;
	RainSensor_t	*item7_96	/* OPTIONAL */;
	RequestedItem_t	*item7_97	/* OPTIONAL */;
	ResponseType_t	*item7_98	/* OPTIONAL */;
	RTCM_ID_t	*item7_99	/* OPTIONAL */;
	RTCM_Payload_t	*item7_100	/* OPTIONAL */;
	RTCM_Revision_t	*item7_101	/* OPTIONAL */;
	SignalLightState_t	*item7_102	/* OPTIONAL */;
	SignalReqScheme_t	*item7_103	/* OPTIONAL */;
	SignalState_t	*item7_104	/* OPTIONAL */;
	SignPrority_t	*item7_105	/* OPTIONAL */;
	SirenInUse_t	*item7_106	/* OPTIONAL */;
	SpecialLaneAttributes_t	*item7_107	/* OPTIONAL */;
	SpecialSignalState_t	*item7_108	/* OPTIONAL */;
	SpeedConfidence_t	*item7_109	/* OPTIONAL */;
	Speed_t	*item7_110	/* OPTIONAL */;
	StabilityControlStatus_t	*item7_111	/* OPTIONAL */;
	StateConfidence_t	*item7_112	/* OPTIONAL */;
	SteeringWheelAngleConfidence_t	*item7_113	/* OPTIONAL */;
	SteeringWheelAngleRateOfChange_t	*item7_114	/* OPTIONAL */;
	SteeringWheelAngle_t	*item7_115	/* OPTIONAL */;
	SunSensor_t	*item7_116	/* OPTIONAL */;
	TemporaryID_t	*item7_117	/* OPTIONAL */;
	TermDistance_t	*item7_118	/* OPTIONAL */;
	TermTime_t	*item7_119	/* OPTIONAL */;
	ThrottleConfidence_t	*item7_120	/* OPTIONAL */;
	ThrottlePosition_t	*item7_121	/* OPTIONAL */;
	TimeConfidence_t	*item7_122	/* OPTIONAL */;
	TimeMark_t	*item7_123	/* OPTIONAL */;
	TractionControlState_t	*item7_124	/* OPTIONAL */;
	TransitPreEmptionRequest_t	*item7_125	/* OPTIONAL */;
	TransitStatus_t	*item7_126	/* OPTIONAL */;
	TransmissionState_t	*item7_127	/* OPTIONAL */;
	TxTime_t	*item7_128	/* OPTIONAL */;
	TravelerInfoType_t	*item7_129	/* OPTIONAL */;
	UniqueMSGID_t	*item7_130	/* OPTIONAL */;
	URL_Base_t	*item7_131	/* OPTIONAL */;
	URL_Link_t	*item7_132	/* OPTIONAL */;
	URL_Short_t	*item7_133	/* OPTIONAL */;
	VehicleHeight_t	*item7_134	/* OPTIONAL */;
	VehicleLaneAttributes_t	*item7_135	/* OPTIONAL */;
	VehicleLength_t	*item7_136	/* OPTIONAL */;
	VehicleMass_t	*item7_137	/* OPTIONAL */;
	VehicleRequestStatus_t	*item7_138	/* OPTIONAL */;
	VehicleStatusDeviceTypeTag_t	*item7_139	/* OPTIONAL */;
	VehicleType_t	*item7_140	/* OPTIONAL */;
	VehicleWidth_t	*item7_141	/* OPTIONAL */;
	VerticalAccelerationThreshold_t	*item7_142	/* OPTIONAL */;
	VerticalAcceleration_t	*item7_143	/* OPTIONAL */;
	VINstring_t	*item7_144	/* OPTIONAL */;
	WiperRate_t	*item7_145	/* OPTIONAL */;
	WiperStatusFront_t	*item7_146	/* OPTIONAL */;
	WiperStatusRear_t	*item7_147	/* OPTIONAL */;
	YawRateConfidence_t	*item7_148	/* OPTIONAL */;
	YawRate_t	*item7_149	/* OPTIONAL */;
	IncidentResponseEquipment_t	*item8_1	/* OPTIONAL */;
	ITIStext_t	*item8_2	/* OPTIONAL */;
	ResponderGroupAffected_t	*item8_3	/* OPTIONAL */;
	VehicleGroupAffected_t	*item8_4	/* OPTIONAL */;
	struct ITIScodesAndText	*item8_5	/* OPTIONAL */;
	EssMobileFriction_t	*item8_6	/* OPTIONAL */;
	EssPrecipRate_t	*item8_7	/* OPTIONAL */;
	EssPrecipSituation_t	*item8_8	/* OPTIONAL */;
	EssPrecipYesNo_t	*item8_9	/* OPTIONAL */;
	EssSolarRadiation_t	*item8_10	/* OPTIONAL */;
	ITIScodes_t	*item8_11	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} AllInclusive_t;

/*** <<< FUNC-DECLS [AllInclusive] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AllInclusive;

/*** <<< POST-INCLUDE [AllInclusive] >>> ***/

#include "AccelSteerYawRateConfidence.h"
#include "Approach.h"
#include "ApproachObject.h"
#include "BarrierLane.h"
#include "BumperHeights.h"
#include "Circle.h"
#include "ConfidenceSet.h"
#include "CrosswalkLane.h"
#include "DataParameters.h"
#include "DDate.h"
#include "DDateTime.h"
#include "DFullTime.h"
#include "DMonthDay.h"
#include "DTime.h"
#include "DYearMonth.h"
#include "FullPositionVector.h"
#include "Intersection.h"
#include "IntersectionState.h"
#include "ExitService.h"
#include "GenericSignage.h"
#include "SpeedLimit.h"
#include "WorkZone.h"
#include "J1939data.h"
#include "MovementState.h"
#include "NodeList.h"
#include "PathHistory.h"
#include "PathHistoryPointType-01.h"
#include "PathPrediction.h"
#include "Position3D.h"
#include "RegionList.h"
#include "RegionOffsets.h"
#include "RegionPointSet.h"
#include "RoadSignID.h"
#include "RTCMmsg.h"
#include "RTCMPackage.h"
#include "Sample.h"
#include "ShapePointSet.h"
#include "SignalControlZone.h"
#include "SignalRequest.h"
#include "SnapshotDistance.h"
#include "Snapshot.h"
#include "SnapshotTime.h"
#include "SpecialLane.h"
#include "ValidRegion.h"
#include "VehicleComputedLane.h"
#include "VehicleIdent.h"
#include "VehicleReferenceLane.h"
#include "VehicleSafetyExtension.h"
#include "VehicleSize.h"
#include "VehicleStatusRequest.h"
#include "VehicleStatus.h"
#include "WiperStatus.h"
#include "ITIScodesAndText.h"

/*** <<< STAT-DEFS [AllInclusive] >>> ***/

static asn_TYPE_member_t asn_MBR_AllInclusive_1[] = {
	{ ATF_POINTER, 232, offsetof(struct AllInclusive, item6_1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelerationSet4Way,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-1"
		},
	{ ATF_POINTER, 231, offsetof(struct AllInclusive, item6_2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelSteerYawRateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-2"
		},
	{ ATF_POINTER, 230, offsetof(struct AllInclusive, item6_4),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AntennaOffsetSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-4"
		},
	{ ATF_POINTER, 229, offsetof(struct AllInclusive, item6_5),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Approach,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-5"
		},
	{ ATF_POINTER, 228, offsetof(struct AllInclusive, item6_6),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ApproachObject,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-6"
		},
	{ ATF_POINTER, 227, offsetof(struct AllInclusive, item6_7),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BarrierLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-7"
		},
	{ ATF_POINTER, 226, offsetof(struct AllInclusive, item6_8),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeSystemStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-8"
		},
	{ ATF_POINTER, 225, offsetof(struct AllInclusive, item6_9),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BSMblob,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-9"
		},
	{ ATF_POINTER, 224, offsetof(struct AllInclusive, item6_10),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BumperHeights,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-10"
		},
	{ ATF_POINTER, 223, offsetof(struct AllInclusive, item6_11),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Circle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-11"
		},
	{ ATF_POINTER, 222, offsetof(struct AllInclusive, item6_12),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConfidenceSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-12"
		},
	{ ATF_POINTER, 221, offsetof(struct AllInclusive, item6_13),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConnectsTo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-13"
		},
	{ ATF_POINTER, 220, offsetof(struct AllInclusive, item6_14),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CrosswalkLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-14"
		},
	{ ATF_POINTER, 219, offsetof(struct AllInclusive, item6_15),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DataParameters,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-15"
		},
	{ ATF_POINTER, 218, offsetof(struct AllInclusive, item6_16),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-16"
		},
	{ ATF_POINTER, 217, offsetof(struct AllInclusive, item6_17),
		.tag = (ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDateTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-17"
		},
	{ ATF_POINTER, 216, offsetof(struct AllInclusive, item6_18),
		.tag = (ASN_TAG_CLASS_CONTEXT | (16 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DFullTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-18"
		},
	{ ATF_POINTER, 215, offsetof(struct AllInclusive, item6_19),
		.tag = (ASN_TAG_CLASS_CONTEXT | (17 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonthDay,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-19"
		},
	{ ATF_POINTER, 214, offsetof(struct AllInclusive, item6_20),
		.tag = (ASN_TAG_CLASS_CONTEXT | (18 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-20"
		},
	{ ATF_POINTER, 213, offsetof(struct AllInclusive, item6_21),
		.tag = (ASN_TAG_CLASS_CONTEXT | (19 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYearMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-21"
		},
	{ ATF_POINTER, 212, offsetof(struct AllInclusive, item6_22),
		.tag = (ASN_TAG_CLASS_CONTEXT | (20 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-22"
		},
	{ ATF_POINTER, 211, offsetof(struct AllInclusive, item6_23),
		.tag = (ASN_TAG_CLASS_CONTEXT | (21 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Intersection,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-23"
		},
	{ ATF_POINTER, 210, offsetof(struct AllInclusive, item6_24),
		.tag = (ASN_TAG_CLASS_CONTEXT | (22 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-24"
		},
	{ ATF_POINTER, 209, offsetof(struct AllInclusive, item6_25),
		.tag = (ASN_TAG_CLASS_CONTEXT | (23 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExitService,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-25"
		},
	{ ATF_POINTER, 208, offsetof(struct AllInclusive, item6_26),
		.tag = (ASN_TAG_CLASS_CONTEXT | (24 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_GenericSignage,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-26"
		},
	{ ATF_POINTER, 207, offsetof(struct AllInclusive, item6_27),
		.tag = (ASN_TAG_CLASS_CONTEXT | (25 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedLimit,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-27"
		},
	{ ATF_POINTER, 206, offsetof(struct AllInclusive, item6_28),
		.tag = (ASN_TAG_CLASS_CONTEXT | (26 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WorkZone,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-28"
		},
	{ ATF_POINTER, 205, offsetof(struct AllInclusive, item6_29),
		.tag = (ASN_TAG_CLASS_CONTEXT | (27 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_J1939data,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-29"
		},
	{ ATF_POINTER, 204, offsetof(struct AllInclusive, item6_30),
		.tag = (ASN_TAG_CLASS_CONTEXT | (28 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MovementState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-30"
		},
	{ ATF_POINTER, 203, offsetof(struct AllInclusive, item6_31),
		.tag = (ASN_TAG_CLASS_CONTEXT | (29 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-31"
		},
	{ ATF_POINTER, 202, offsetof(struct AllInclusive, item6_32),
		.tag = (ASN_TAG_CLASS_CONTEXT | (30 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Offsets,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-32"
		},
	{ ATF_POINTER, 201, offsetof(struct AllInclusive, item6_33),
		.tag = (ASN_TAG_CLASS_CONTEXT | (31 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistory,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-33"
		},
	{ ATF_POINTER, 200, offsetof(struct AllInclusive, item6_34),
		.tag = (ASN_TAG_CLASS_CONTEXT | (32 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_01,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-34"
		},
	{ ATF_POINTER, 199, offsetof(struct AllInclusive, item6_35),
		.tag = (ASN_TAG_CLASS_CONTEXT | (33 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_02,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-35"
		},
	{ ATF_POINTER, 198, offsetof(struct AllInclusive, item6_36),
		.tag = (ASN_TAG_CLASS_CONTEXT | (34 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_03,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-36"
		},
	{ ATF_POINTER, 197, offsetof(struct AllInclusive, item6_37),
		.tag = (ASN_TAG_CLASS_CONTEXT | (35 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_04,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-37"
		},
	{ ATF_POINTER, 196, offsetof(struct AllInclusive, item6_38),
		.tag = (ASN_TAG_CLASS_CONTEXT | (36 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_05,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-38"
		},
	{ ATF_POINTER, 195, offsetof(struct AllInclusive, item6_39),
		.tag = (ASN_TAG_CLASS_CONTEXT | (37 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_06,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-39"
		},
	{ ATF_POINTER, 194, offsetof(struct AllInclusive, item6_40),
		.tag = (ASN_TAG_CLASS_CONTEXT | (38 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_07,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-40"
		},
	{ ATF_POINTER, 193, offsetof(struct AllInclusive, item6_41),
		.tag = (ASN_TAG_CLASS_CONTEXT | (39 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_08,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-41"
		},
	{ ATF_POINTER, 192, offsetof(struct AllInclusive, item6_42),
		.tag = (ASN_TAG_CLASS_CONTEXT | (40 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_09,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-42"
		},
	{ ATF_POINTER, 191, offsetof(struct AllInclusive, item6_43),
		.tag = (ASN_TAG_CLASS_CONTEXT | (41 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistoryPointType_10,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-43"
		},
	{ ATF_POINTER, 190, offsetof(struct AllInclusive, item6_44),
		.tag = (ASN_TAG_CLASS_CONTEXT | (42 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathPrediction,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-44"
		},
	{ ATF_POINTER, 189, offsetof(struct AllInclusive, item6_45),
		.tag = (ASN_TAG_CLASS_CONTEXT | (43 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-45"
		},
	{ ATF_POINTER, 188, offsetof(struct AllInclusive, item6_46),
		.tag = (ASN_TAG_CLASS_CONTEXT | (44 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionalAccuracy,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-46"
		},
	{ ATF_POINTER, 187, offsetof(struct AllInclusive, item6_47),
		.tag = (ASN_TAG_CLASS_CONTEXT | (45 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionConfidenceSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-47"
		},
	{ ATF_POINTER, 186, offsetof(struct AllInclusive, item6_48),
		.tag = (ASN_TAG_CLASS_CONTEXT | (46 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RegionList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-48"
		},
	{ ATF_POINTER, 185, offsetof(struct AllInclusive, item6_49),
		.tag = (ASN_TAG_CLASS_CONTEXT | (47 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RegionOffsets,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-49"
		},
	{ ATF_POINTER, 184, offsetof(struct AllInclusive, item6_50),
		.tag = (ASN_TAG_CLASS_CONTEXT | (48 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RegionPointSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-50"
		},
	{ ATF_POINTER, 183, offsetof(struct AllInclusive, item6_51),
		.tag = (ASN_TAG_CLASS_CONTEXT | (49 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RoadSignID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-51"
		},
	{ ATF_POINTER, 182, offsetof(struct AllInclusive, item6_52),
		.tag = (ASN_TAG_CLASS_CONTEXT | (50 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCMHeader,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-52"
		},
	{ ATF_POINTER, 181, offsetof(struct AllInclusive, item6_53),
		.tag = (ASN_TAG_CLASS_CONTEXT | (51 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCMmsg,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-53"
		},
	{ ATF_POINTER, 180, offsetof(struct AllInclusive, item6_54),
		.tag = (ASN_TAG_CLASS_CONTEXT | (52 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCMPackage,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-54"
		},
	{ ATF_POINTER, 179, offsetof(struct AllInclusive, item6_55),
		.tag = (ASN_TAG_CLASS_CONTEXT | (53 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Sample,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-55"
		},
	{ ATF_POINTER, 178, offsetof(struct AllInclusive, item6_56),
		.tag = (ASN_TAG_CLASS_CONTEXT | (54 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ShapePointSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-56"
		},
	{ ATF_POINTER, 177, offsetof(struct AllInclusive, item6_57),
		.tag = (ASN_TAG_CLASS_CONTEXT | (55 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalControlZone,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-57"
		},
	{ ATF_POINTER, 176, offsetof(struct AllInclusive, item6_58),
		.tag = (ASN_TAG_CLASS_CONTEXT | (56 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalRequest,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-58"
		},
	{ ATF_POINTER, 175, offsetof(struct AllInclusive, item6_59),
		.tag = (ASN_TAG_CLASS_CONTEXT | (57 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SnapshotDistance,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-59"
		},
	{ ATF_POINTER, 174, offsetof(struct AllInclusive, item6_60),
		.tag = (ASN_TAG_CLASS_CONTEXT | (58 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Snapshot,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-60"
		},
	{ ATF_POINTER, 173, offsetof(struct AllInclusive, item6_61),
		.tag = (ASN_TAG_CLASS_CONTEXT | (59 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SnapshotTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-61"
		},
	{ ATF_POINTER, 172, offsetof(struct AllInclusive, item6_62),
		.tag = (ASN_TAG_CLASS_CONTEXT | (60 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpecialLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-62"
		},
	{ ATF_POINTER, 171, offsetof(struct AllInclusive, item6_63),
		.tag = (ASN_TAG_CLASS_CONTEXT | (61 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedandHeadingandThrottleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-63"
		},
	{ ATF_POINTER, 170, offsetof(struct AllInclusive, item6_64),
		.tag = (ASN_TAG_CLASS_CONTEXT | (62 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransmissionAndSpeed,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-64"
		},
	{ ATF_POINTER, 169, offsetof(struct AllInclusive, item6_65),
		.tag = (ASN_TAG_CLASS_CONTEXT | (63 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ValidRegion,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-65"
		},
	{ ATF_POINTER, 168, offsetof(struct AllInclusive, item6_66),
		.tag = (ASN_TAG_CLASS_CONTEXT | (64 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleComputedLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-66"
		},
	{ ATF_POINTER, 167, offsetof(struct AllInclusive, item6_67),
		.tag = (ASN_TAG_CLASS_CONTEXT | (65 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleIdent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-67"
		},
	{ ATF_POINTER, 166, offsetof(struct AllInclusive, item6_68),
		.tag = (ASN_TAG_CLASS_CONTEXT | (66 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleReferenceLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-68"
		},
	{ ATF_POINTER, 165, offsetof(struct AllInclusive, item6_69),
		.tag = (ASN_TAG_CLASS_CONTEXT | (67 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleSafetyExtension,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-69"
		},
	{ ATF_POINTER, 164, offsetof(struct AllInclusive, item6_70),
		.tag = (ASN_TAG_CLASS_CONTEXT | (68 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleSize,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-70"
		},
	{ ATF_POINTER, 163, offsetof(struct AllInclusive, item6_71),
		.tag = (ASN_TAG_CLASS_CONTEXT | (69 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatusRequest,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-71"
		},
	{ ATF_POINTER, 162, offsetof(struct AllInclusive, item6_72),
		.tag = (ASN_TAG_CLASS_CONTEXT | (70 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-72"
		},
	{ ATF_POINTER, 161, offsetof(struct AllInclusive, item6_73),
		.tag = (ASN_TAG_CLASS_CONTEXT | (71 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item6-73"
		},
	{ ATF_POINTER, 160, offsetof(struct AllInclusive, item7_1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (72 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Acceleration,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-1"
		},
	{ ATF_POINTER, 159, offsetof(struct AllInclusive, item7_2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (73 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelerationConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-2"
		},
	{ ATF_POINTER, 158, offsetof(struct AllInclusive, item7_3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (74 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AmbientAirPressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-3"
		},
	{ ATF_POINTER, 157, offsetof(struct AllInclusive, item7_4),
		.tag = (ASN_TAG_CLASS_CONTEXT | (75 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AmbientAirTemperature,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-4"
		},
	{ ATF_POINTER, 156, offsetof(struct AllInclusive, item7_5),
		.tag = (ASN_TAG_CLASS_CONTEXT | (76 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AntiLockBrakeStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-5"
		},
	{ ATF_POINTER, 155, offsetof(struct AllInclusive, item7_6),
		.tag = (ASN_TAG_CLASS_CONTEXT | (77 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ApproachNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-6"
		},
	{ ATF_POINTER, 154, offsetof(struct AllInclusive, item7_7),
		.tag = (ASN_TAG_CLASS_CONTEXT | (78 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AuxiliaryBrakeStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-7"
		},
	{ ATF_POINTER, 153, offsetof(struct AllInclusive, item7_8),
		.tag = (ASN_TAG_CLASS_CONTEXT | (79 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BarrierAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-8"
		},
	{ ATF_POINTER, 152, offsetof(struct AllInclusive, item7_9),
		.tag = (ASN_TAG_CLASS_CONTEXT | (80 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeAppliedPressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-9"
		},
	{ ATF_POINTER, 151, offsetof(struct AllInclusive, item7_10),
		.tag = (ASN_TAG_CLASS_CONTEXT | (81 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeAppliedStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-10"
		},
	{ ATF_POINTER, 150, offsetof(struct AllInclusive, item7_11),
		.tag = (ASN_TAG_CLASS_CONTEXT | (82 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeBoostApplied,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-11"
		},
	{ ATF_POINTER, 149, offsetof(struct AllInclusive, item7_12),
		.tag = (ASN_TAG_CLASS_CONTEXT | (83 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BumperHeightFront,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-12"
		},
	{ ATF_POINTER, 148, offsetof(struct AllInclusive, item7_13),
		.tag = (ASN_TAG_CLASS_CONTEXT | (84 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BumperHeightRear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-13"
		},
	{ ATF_POINTER, 147, offsetof(struct AllInclusive, item7_14),
		.tag = (ASN_TAG_CLASS_CONTEXT | (85 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CodeWord,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-14"
		},
	{ ATF_POINTER, 146, offsetof(struct AllInclusive, item7_15),
		.tag = (ASN_TAG_CLASS_CONTEXT | (86 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CoefficientOfFriction,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-15"
		},
	{ ATF_POINTER, 145, offsetof(struct AllInclusive, item7_16),
		.tag = (ASN_TAG_CLASS_CONTEXT | (87 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ColorState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-16"
		},
	{ ATF_POINTER, 144, offsetof(struct AllInclusive, item7_17),
		.tag = (ASN_TAG_CLASS_CONTEXT | (88 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Count,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-17"
		},
	{ ATF_POINTER, 143, offsetof(struct AllInclusive, item7_18),
		.tag = (ASN_TAG_CLASS_CONTEXT | (89 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CrosswalkLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-18"
		},
	{ ATF_POINTER, 142, offsetof(struct AllInclusive, item7_19),
		.tag = (ASN_TAG_CLASS_CONTEXT | (90 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDay,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-19"
		},
	{ ATF_POINTER, 141, offsetof(struct AllInclusive, item7_20),
		.tag = (ASN_TAG_CLASS_CONTEXT | (91 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-20"
		},
	{ ATF_POINTER, 140, offsetof(struct AllInclusive, item7_21),
		.tag = (ASN_TAG_CLASS_CONTEXT | (92 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DHour,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-21"
		},
	{ ATF_POINTER, 139, offsetof(struct AllInclusive, item7_22),
		.tag = (ASN_TAG_CLASS_CONTEXT | (93 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DirectionOfUse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-22"
		},
	{ ATF_POINTER, 138, offsetof(struct AllInclusive, item7_23),
		.tag = (ASN_TAG_CLASS_CONTEXT | (94 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMinute,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-23"
		},
	{ ATF_POINTER, 137, offsetof(struct AllInclusive, item7_24),
		.tag = (ASN_TAG_CLASS_CONTEXT | (95 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-24"
		},
	{ ATF_POINTER, 136, offsetof(struct AllInclusive, item7_25),
		.tag = (ASN_TAG_CLASS_CONTEXT | (96 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DOffset,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-25"
		},
	{ ATF_POINTER, 135, offsetof(struct AllInclusive, item7_26),
		.tag = (ASN_TAG_CLASS_CONTEXT | (97 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DrivenLineOffset,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-26"
		},
	{ ATF_POINTER, 134, offsetof(struct AllInclusive, item7_27),
		.tag = (ASN_TAG_CLASS_CONTEXT | (98 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DrivingWheelAngle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-27"
		},
	{ ATF_POINTER, 133, offsetof(struct AllInclusive, item7_28),
		.tag = (ASN_TAG_CLASS_CONTEXT | (99 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSecond,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-28"
		},
	{ ATF_POINTER, 132, offsetof(struct AllInclusive, item7_29),
		.tag = (ASN_TAG_CLASS_CONTEXT | (100 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSignalSeconds,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-29"
		},
	{ ATF_POINTER, 131, offsetof(struct AllInclusive, item7_30),
		.tag = (ASN_TAG_CLASS_CONTEXT | (101 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSRCmsgID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-30"
		},
	{ ATF_POINTER, 130, offsetof(struct AllInclusive, item7_31),
		.tag = (ASN_TAG_CLASS_CONTEXT | (102 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-31"
		},
	{ ATF_POINTER, 129, offsetof(struct AllInclusive, item7_32),
		.tag = (ASN_TAG_CLASS_CONTEXT | (103 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ElevationConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-32"
		},
	{ ATF_POINTER, 128, offsetof(struct AllInclusive, item7_33),
		.tag = (ASN_TAG_CLASS_CONTEXT | (104 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Elevation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-33"
		},
	{ ATF_POINTER, 127, offsetof(struct AllInclusive, item7_34),
		.tag = (ASN_TAG_CLASS_CONTEXT | (105 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EmergencyDetails,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-34"
		},
	{ ATF_POINTER, 126, offsetof(struct AllInclusive, item7_35),
		.tag = (ASN_TAG_CLASS_CONTEXT | (106 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EventFlags,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-35"
		},
	{ ATF_POINTER, 125, offsetof(struct AllInclusive, item7_36),
		.tag = (ASN_TAG_CLASS_CONTEXT | (107 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Extent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-36"
		},
	{ ATF_POINTER, 124, offsetof(struct AllInclusive, item7_37),
		.tag = (ASN_TAG_CLASS_CONTEXT | (108 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExteriorLights,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-37"
		},
	{ ATF_POINTER, 123, offsetof(struct AllInclusive, item7_38),
		.tag = (ASN_TAG_CLASS_CONTEXT | (109 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FurtherInfoID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-38"
		},
	{ ATF_POINTER, 122, offsetof(struct AllInclusive, item7_39),
		.tag = (ASN_TAG_CLASS_CONTEXT | (110 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_GPSstatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-39"
		},
	{ ATF_POINTER, 121, offsetof(struct AllInclusive, item7_40),
		.tag = (ASN_TAG_CLASS_CONTEXT | (111 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_HeadingConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-40"
		},
	{ ATF_POINTER, 120, offsetof(struct AllInclusive, item7_41),
		.tag = (ASN_TAG_CLASS_CONTEXT | (112 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Heading,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-41"
		},
	{ ATF_POINTER, 119, offsetof(struct AllInclusive, item7_42),
		.tag = (ASN_TAG_CLASS_CONTEXT | (113 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_HeadingSlice,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-42"
		},
	{ ATF_POINTER, 118, offsetof(struct AllInclusive, item7_43),
		.tag = (ASN_TAG_CLASS_CONTEXT | (114 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionStatusObject,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-43"
		},
	{ ATF_POINTER, 117, offsetof(struct AllInclusive, item7_44),
		.tag = (ASN_TAG_CLASS_CONTEXT | (115 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-44"
		},
	{ ATF_POINTER, 116, offsetof(struct AllInclusive, item7_45),
		.tag = (ASN_TAG_CLASS_CONTEXT | (116 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AxleLocation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-45"
		},
	{ ATF_POINTER, 115, offsetof(struct AllInclusive, item7_46),
		.tag = (ASN_TAG_CLASS_CONTEXT | (117 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AxleWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-46"
		},
	{ ATF_POINTER, 114, offsetof(struct AllInclusive, item7_47),
		.tag = (ASN_TAG_CLASS_CONTEXT | (118 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CargoWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-47"
		},
	{ ATF_POINTER, 113, offsetof(struct AllInclusive, item7_48),
		.tag = (ASN_TAG_CLASS_CONTEXT | (119 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleLiftAirPressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-48"
		},
	{ ATF_POINTER, 112, offsetof(struct AllInclusive, item7_49),
		.tag = (ASN_TAG_CLASS_CONTEXT | (120 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleLocation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-49"
		},
	{ ATF_POINTER, 111, offsetof(struct AllInclusive, item7_50),
		.tag = (ASN_TAG_CLASS_CONTEXT | (121 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleLubePressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-50"
		},
	{ ATF_POINTER, 110, offsetof(struct AllInclusive, item7_51),
		.tag = (ASN_TAG_CLASS_CONTEXT | (122 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleTemperature,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-51"
		},
	{ ATF_POINTER, 109, offsetof(struct AllInclusive, item7_52),
		.tag = (ASN_TAG_CLASS_CONTEXT | (123 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringAxleLubePressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-52"
		},
	{ ATF_POINTER, 108, offsetof(struct AllInclusive, item7_53),
		.tag = (ASN_TAG_CLASS_CONTEXT | (124 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringAxleTemperature,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-53"
		},
	{ ATF_POINTER, 107, offsetof(struct AllInclusive, item7_54),
		.tag = (ASN_TAG_CLASS_CONTEXT | (125 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TireLeakageRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-54"
		},
	{ ATF_POINTER, 106, offsetof(struct AllInclusive, item7_55),
		.tag = (ASN_TAG_CLASS_CONTEXT | (126 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TireLocation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-55"
		},
	{ ATF_POINTER, 105, offsetof(struct AllInclusive, item7_56),
		.tag = (ASN_TAG_CLASS_CONTEXT | (127 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TirePressureThresholdDetection,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-56"
		},
	{ ATF_POINTER, 104, offsetof(struct AllInclusive, item7_57),
		.tag = (ASN_TAG_CLASS_CONTEXT | (128 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TirePressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-57"
		},
	{ ATF_POINTER, 103, offsetof(struct AllInclusive, item7_58),
		.tag = (ASN_TAG_CLASS_CONTEXT | (129 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TireTemp,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-58"
		},
	{ ATF_POINTER, 102, offsetof(struct AllInclusive, item7_59),
		.tag = (ASN_TAG_CLASS_CONTEXT | (130 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TrailerWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-59"
		},
	{ ATF_POINTER, 101, offsetof(struct AllInclusive, item7_60),
		.tag = (ASN_TAG_CLASS_CONTEXT | (131 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WheelEndElectFault,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-60"
		},
	{ ATF_POINTER, 100, offsetof(struct AllInclusive, item7_61),
		.tag = (ASN_TAG_CLASS_CONTEXT | (132 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WheelSensorStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-61"
		},
	{ ATF_POINTER, 99, offsetof(struct AllInclusive, item7_62),
		.tag = (ASN_TAG_CLASS_CONTEXT | (133 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-62"
		},
	{ ATF_POINTER, 98, offsetof(struct AllInclusive, item7_63),
		.tag = (ASN_TAG_CLASS_CONTEXT | (134 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneManeuverCode,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-63"
		},
	{ ATF_POINTER, 97, offsetof(struct AllInclusive, item7_64),
		.tag = (ASN_TAG_CLASS_CONTEXT | (135 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-64"
		},
	{ ATF_POINTER, 96, offsetof(struct AllInclusive, item7_65),
		.tag = (ASN_TAG_CLASS_CONTEXT | (136 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-65"
		},
	{ ATF_POINTER, 95, offsetof(struct AllInclusive, item7_66),
		.tag = (ASN_TAG_CLASS_CONTEXT | (137 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-66"
		},
	{ ATF_POINTER, 94, offsetof(struct AllInclusive, item7_67),
		.tag = (ASN_TAG_CLASS_CONTEXT | (138 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Latitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-67"
		},
	{ ATF_POINTER, 93, offsetof(struct AllInclusive, item7_68),
		.tag = (ASN_TAG_CLASS_CONTEXT | (139 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LayerID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-68"
		},
	{ ATF_POINTER, 92, offsetof(struct AllInclusive, item7_69),
		.tag = (ASN_TAG_CLASS_CONTEXT | (140 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LayerType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-69"
		},
	{ ATF_POINTER, 91, offsetof(struct AllInclusive, item7_70),
		.tag = (ASN_TAG_CLASS_CONTEXT | (141 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LightbarInUse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-70"
		},
	{ ATF_POINTER, 90, offsetof(struct AllInclusive, item7_71),
		.tag = (ASN_TAG_CLASS_CONTEXT | (142 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Longitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-71"
		},
	{ ATF_POINTER, 89, offsetof(struct AllInclusive, item7_72),
		.tag = (ASN_TAG_CLASS_CONTEXT | (143 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Location_quality,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-72"
		},
	{ ATF_POINTER, 88, offsetof(struct AllInclusive, item7_73),
		.tag = (ASN_TAG_CLASS_CONTEXT | (144 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Location_tech,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-73"
		},
	{ ATF_POINTER, 87, offsetof(struct AllInclusive, item7_74),
		.tag = (ASN_TAG_CLASS_CONTEXT | (145 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MinuteOfTheYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-74"
		},
	{ ATF_POINTER, 86, offsetof(struct AllInclusive, item7_75),
		.tag = (ASN_TAG_CLASS_CONTEXT | (146 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MinutesDuration,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-75"
		},
	{ ATF_POINTER, 85, offsetof(struct AllInclusive, item7_76),
		.tag = (ASN_TAG_CLASS_CONTEXT | (147 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-76"
		},
	{ ATF_POINTER, 84, offsetof(struct AllInclusive, item7_77),
		.tag = (ASN_TAG_CLASS_CONTEXT | (148 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-77"
		},
	{ ATF_POINTER, 83, offsetof(struct AllInclusive, item7_78),
		.tag = (ASN_TAG_CLASS_CONTEXT | (149 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MultiVehicleResponse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-78"
		},
	{ ATF_POINTER, 82, offsetof(struct AllInclusive, item7_79),
		.tag = (ASN_TAG_CLASS_CONTEXT | (150 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MUTCDCode,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-79"
		},
	{ ATF_POINTER, 81, offsetof(struct AllInclusive, item7_80),
		.tag = (ASN_TAG_CLASS_CONTEXT | (151 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NMEA_MsgType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-80"
		},
	{ ATF_POINTER, 80, offsetof(struct AllInclusive, item7_81),
		.tag = (ASN_TAG_CLASS_CONTEXT | (152 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NMEA_Payload,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-81"
		},
	{ ATF_POINTER, 79, offsetof(struct AllInclusive, item7_82),
		.tag = (ASN_TAG_CLASS_CONTEXT | (153 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NMEA_Revision,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-82"
		},
	{ ATF_POINTER, 78, offsetof(struct AllInclusive, item7_83),
		.tag = (ASN_TAG_CLASS_CONTEXT | (154 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NTCIPVehicleclass,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-83"
		},
	{ ATF_POINTER, 77, offsetof(struct AllInclusive, item7_84),
		.tag = (ASN_TAG_CLASS_CONTEXT | (155 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObjectCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-84"
		},
	{ ATF_POINTER, 76, offsetof(struct AllInclusive, item7_85),
		.tag = (ASN_TAG_CLASS_CONTEXT | (156 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObstacleDirection,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-85"
		},
	{ ATF_POINTER, 75, offsetof(struct AllInclusive, item7_86),
		.tag = (ASN_TAG_CLASS_CONTEXT | (157 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObstacleDistance,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-86"
		},
	{ ATF_POINTER, 74, offsetof(struct AllInclusive, item7_87),
		.tag = (ASN_TAG_CLASS_CONTEXT | (158 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PayloadData,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-87"
		},
	{ ATF_POINTER, 73, offsetof(struct AllInclusive, item7_88),
		.tag = (ASN_TAG_CLASS_CONTEXT | (159 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Payload,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-88"
		},
	{ ATF_POINTER, 72, offsetof(struct AllInclusive, item7_89),
		.tag = (ASN_TAG_CLASS_CONTEXT | (160 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PedestrianDetect,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-89"
		},
	{ ATF_POINTER, 71, offsetof(struct AllInclusive, item7_90),
		.tag = (ASN_TAG_CLASS_CONTEXT | (161 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PedestrianSignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-90"
		},
	{ ATF_POINTER, 70, offsetof(struct AllInclusive, item7_91),
		.tag = (ASN_TAG_CLASS_CONTEXT | (162 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-91"
		},
	{ ATF_POINTER, 69, offsetof(struct AllInclusive, item7_92),
		.tag = (ASN_TAG_CLASS_CONTEXT | (163 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PreemptState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-92"
		},
	{ ATF_POINTER, 68, offsetof(struct AllInclusive, item7_93),
		.tag = (ASN_TAG_CLASS_CONTEXT | (164 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Priority,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-93"
		},
	{ ATF_POINTER, 67, offsetof(struct AllInclusive, item7_94),
		.tag = (ASN_TAG_CLASS_CONTEXT | (165 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PriorityState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-94"
		},
	{ ATF_POINTER, 66, offsetof(struct AllInclusive, item7_95),
		.tag = (ASN_TAG_CLASS_CONTEXT | (166 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ProbeSegmentNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-95"
		},
	{ ATF_POINTER, 65, offsetof(struct AllInclusive, item7_96),
		.tag = (ASN_TAG_CLASS_CONTEXT | (167 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RainSensor,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-96"
		},
	{ ATF_POINTER, 64, offsetof(struct AllInclusive, item7_97),
		.tag = (ASN_TAG_CLASS_CONTEXT | (168 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RequestedItem,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-97"
		},
	{ ATF_POINTER, 63, offsetof(struct AllInclusive, item7_98),
		.tag = (ASN_TAG_CLASS_CONTEXT | (169 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ResponseType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-98"
		},
	{ ATF_POINTER, 62, offsetof(struct AllInclusive, item7_99),
		.tag = (ASN_TAG_CLASS_CONTEXT | (170 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_ID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-99"
		},
	{ ATF_POINTER, 61, offsetof(struct AllInclusive, item7_100),
		.tag = (ASN_TAG_CLASS_CONTEXT | (171 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_Payload,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-100"
		},
	{ ATF_POINTER, 60, offsetof(struct AllInclusive, item7_101),
		.tag = (ASN_TAG_CLASS_CONTEXT | (172 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_Revision,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-101"
		},
	{ ATF_POINTER, 59, offsetof(struct AllInclusive, item7_102),
		.tag = (ASN_TAG_CLASS_CONTEXT | (173 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalLightState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-102"
		},
	{ ATF_POINTER, 58, offsetof(struct AllInclusive, item7_103),
		.tag = (ASN_TAG_CLASS_CONTEXT | (174 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalReqScheme,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-103"
		},
	{ ATF_POINTER, 57, offsetof(struct AllInclusive, item7_104),
		.tag = (ASN_TAG_CLASS_CONTEXT | (175 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-104"
		},
	{ ATF_POINTER, 56, offsetof(struct AllInclusive, item7_105),
		.tag = (ASN_TAG_CLASS_CONTEXT | (176 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignPrority,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-105"
		},
	{ ATF_POINTER, 55, offsetof(struct AllInclusive, item7_106),
		.tag = (ASN_TAG_CLASS_CONTEXT | (177 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SirenInUse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-106"
		},
	{ ATF_POINTER, 54, offsetof(struct AllInclusive, item7_107),
		.tag = (ASN_TAG_CLASS_CONTEXT | (178 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpecialLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-107"
		},
	{ ATF_POINTER, 53, offsetof(struct AllInclusive, item7_108),
		.tag = (ASN_TAG_CLASS_CONTEXT | (179 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpecialSignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-108"
		},
	{ ATF_POINTER, 52, offsetof(struct AllInclusive, item7_109),
		.tag = (ASN_TAG_CLASS_CONTEXT | (180 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-109"
		},
	{ ATF_POINTER, 51, offsetof(struct AllInclusive, item7_110),
		.tag = (ASN_TAG_CLASS_CONTEXT | (181 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Speed,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-110"
		},
	{ ATF_POINTER, 50, offsetof(struct AllInclusive, item7_111),
		.tag = (ASN_TAG_CLASS_CONTEXT | (182 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_StabilityControlStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-111"
		},
	{ ATF_POINTER, 49, offsetof(struct AllInclusive, item7_112),
		.tag = (ASN_TAG_CLASS_CONTEXT | (183 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_StateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-112"
		},
	{ ATF_POINTER, 48, offsetof(struct AllInclusive, item7_113),
		.tag = (ASN_TAG_CLASS_CONTEXT | (184 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-113"
		},
	{ ATF_POINTER, 47, offsetof(struct AllInclusive, item7_114),
		.tag = (ASN_TAG_CLASS_CONTEXT | (185 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngleRateOfChange,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-114"
		},
	{ ATF_POINTER, 46, offsetof(struct AllInclusive, item7_115),
		.tag = (ASN_TAG_CLASS_CONTEXT | (186 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-115"
		},
	{ ATF_POINTER, 45, offsetof(struct AllInclusive, item7_116),
		.tag = (ASN_TAG_CLASS_CONTEXT | (187 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SunSensor,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-116"
		},
	{ ATF_POINTER, 44, offsetof(struct AllInclusive, item7_117),
		.tag = (ASN_TAG_CLASS_CONTEXT | (188 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TemporaryID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-117"
		},
	{ ATF_POINTER, 43, offsetof(struct AllInclusive, item7_118),
		.tag = (ASN_TAG_CLASS_CONTEXT | (189 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TermDistance,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-118"
		},
	{ ATF_POINTER, 42, offsetof(struct AllInclusive, item7_119),
		.tag = (ASN_TAG_CLASS_CONTEXT | (190 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TermTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-119"
		},
	{ ATF_POINTER, 41, offsetof(struct AllInclusive, item7_120),
		.tag = (ASN_TAG_CLASS_CONTEXT | (191 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ThrottleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-120"
		},
	{ ATF_POINTER, 40, offsetof(struct AllInclusive, item7_121),
		.tag = (ASN_TAG_CLASS_CONTEXT | (192 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ThrottlePosition,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-121"
		},
	{ ATF_POINTER, 39, offsetof(struct AllInclusive, item7_122),
		.tag = (ASN_TAG_CLASS_CONTEXT | (193 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-122"
		},
	{ ATF_POINTER, 38, offsetof(struct AllInclusive, item7_123),
		.tag = (ASN_TAG_CLASS_CONTEXT | (194 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeMark,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-123"
		},
	{ ATF_POINTER, 37, offsetof(struct AllInclusive, item7_124),
		.tag = (ASN_TAG_CLASS_CONTEXT | (195 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TractionControlState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-124"
		},
	{ ATF_POINTER, 36, offsetof(struct AllInclusive, item7_125),
		.tag = (ASN_TAG_CLASS_CONTEXT | (196 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransitPreEmptionRequest,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-125"
		},
	{ ATF_POINTER, 35, offsetof(struct AllInclusive, item7_126),
		.tag = (ASN_TAG_CLASS_CONTEXT | (197 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransitStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-126"
		},
	{ ATF_POINTER, 34, offsetof(struct AllInclusive, item7_127),
		.tag = (ASN_TAG_CLASS_CONTEXT | (198 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransmissionState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-127"
		},
	{ ATF_POINTER, 33, offsetof(struct AllInclusive, item7_128),
		.tag = (ASN_TAG_CLASS_CONTEXT | (199 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TxTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-128"
		},
	{ ATF_POINTER, 32, offsetof(struct AllInclusive, item7_129),
		.tag = (ASN_TAG_CLASS_CONTEXT | (200 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TravelerInfoType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-129"
		},
	{ ATF_POINTER, 31, offsetof(struct AllInclusive, item7_130),
		.tag = (ASN_TAG_CLASS_CONTEXT | (201 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniqueMSGID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-130"
		},
	{ ATF_POINTER, 30, offsetof(struct AllInclusive, item7_131),
		.tag = (ASN_TAG_CLASS_CONTEXT | (202 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_URL_Base,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-131"
		},
	{ ATF_POINTER, 29, offsetof(struct AllInclusive, item7_132),
		.tag = (ASN_TAG_CLASS_CONTEXT | (203 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_URL_Link,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-132"
		},
	{ ATF_POINTER, 28, offsetof(struct AllInclusive, item7_133),
		.tag = (ASN_TAG_CLASS_CONTEXT | (204 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_URL_Short,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-133"
		},
	{ ATF_POINTER, 27, offsetof(struct AllInclusive, item7_134),
		.tag = (ASN_TAG_CLASS_CONTEXT | (205 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleHeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-134"
		},
	{ ATF_POINTER, 26, offsetof(struct AllInclusive, item7_135),
		.tag = (ASN_TAG_CLASS_CONTEXT | (206 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-135"
		},
	{ ATF_POINTER, 25, offsetof(struct AllInclusive, item7_136),
		.tag = (ASN_TAG_CLASS_CONTEXT | (207 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleLength,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-136"
		},
	{ ATF_POINTER, 24, offsetof(struct AllInclusive, item7_137),
		.tag = (ASN_TAG_CLASS_CONTEXT | (208 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleMass,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-137"
		},
	{ ATF_POINTER, 23, offsetof(struct AllInclusive, item7_138),
		.tag = (ASN_TAG_CLASS_CONTEXT | (209 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleRequestStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-138"
		},
	{ ATF_POINTER, 22, offsetof(struct AllInclusive, item7_139),
		.tag = (ASN_TAG_CLASS_CONTEXT | (210 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatusDeviceTypeTag,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-139"
		},
	{ ATF_POINTER, 21, offsetof(struct AllInclusive, item7_140),
		.tag = (ASN_TAG_CLASS_CONTEXT | (211 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-140"
		},
	{ ATF_POINTER, 20, offsetof(struct AllInclusive, item7_141),
		.tag = (ASN_TAG_CLASS_CONTEXT | (212 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-141"
		},
	{ ATF_POINTER, 19, offsetof(struct AllInclusive, item7_142),
		.tag = (ASN_TAG_CLASS_CONTEXT | (213 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VerticalAccelerationThreshold,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-142"
		},
	{ ATF_POINTER, 18, offsetof(struct AllInclusive, item7_143),
		.tag = (ASN_TAG_CLASS_CONTEXT | (214 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VerticalAcceleration,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-143"
		},
	{ ATF_POINTER, 17, offsetof(struct AllInclusive, item7_144),
		.tag = (ASN_TAG_CLASS_CONTEXT | (215 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VINstring,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-144"
		},
	{ ATF_POINTER, 16, offsetof(struct AllInclusive, item7_145),
		.tag = (ASN_TAG_CLASS_CONTEXT | (216 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-145"
		},
	{ ATF_POINTER, 15, offsetof(struct AllInclusive, item7_146),
		.tag = (ASN_TAG_CLASS_CONTEXT | (217 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatusFront,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-146"
		},
	{ ATF_POINTER, 14, offsetof(struct AllInclusive, item7_147),
		.tag = (ASN_TAG_CLASS_CONTEXT | (218 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatusRear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-147"
		},
	{ ATF_POINTER, 13, offsetof(struct AllInclusive, item7_148),
		.tag = (ASN_TAG_CLASS_CONTEXT | (219 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_YawRateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-148"
		},
	{ ATF_POINTER, 12, offsetof(struct AllInclusive, item7_149),
		.tag = (ASN_TAG_CLASS_CONTEXT | (220 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_YawRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item7-149"
		},
	{ ATF_POINTER, 11, offsetof(struct AllInclusive, item8_1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (221 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IncidentResponseEquipment,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-1"
		},
	{ ATF_POINTER, 10, offsetof(struct AllInclusive, item8_2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (222 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIStext,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-2"
		},
	{ ATF_POINTER, 9, offsetof(struct AllInclusive, item8_3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (223 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ResponderGroupAffected,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-3"
		},
	{ ATF_POINTER, 8, offsetof(struct AllInclusive, item8_4),
		.tag = (ASN_TAG_CLASS_CONTEXT | (224 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleGroupAffected,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-4"
		},
	{ ATF_POINTER, 7, offsetof(struct AllInclusive, item8_5),
		.tag = (ASN_TAG_CLASS_CONTEXT | (225 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodesAndText,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-5"
		},
	{ ATF_POINTER, 6, offsetof(struct AllInclusive, item8_6),
		.tag = (ASN_TAG_CLASS_CONTEXT | (226 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssMobileFriction,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-6"
		},
	{ ATF_POINTER, 5, offsetof(struct AllInclusive, item8_7),
		.tag = (ASN_TAG_CLASS_CONTEXT | (227 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssPrecipRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-7"
		},
	{ ATF_POINTER, 4, offsetof(struct AllInclusive, item8_8),
		.tag = (ASN_TAG_CLASS_CONTEXT | (228 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssPrecipSituation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-8"
		},
	{ ATF_POINTER, 3, offsetof(struct AllInclusive, item8_9),
		.tag = (ASN_TAG_CLASS_CONTEXT | (229 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssPrecipYesNo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-9"
		},
	{ ATF_POINTER, 2, offsetof(struct AllInclusive, item8_10),
		.tag = (ASN_TAG_CLASS_CONTEXT | (230 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssSolarRadiation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-10"
		},
	{ ATF_POINTER, 1, offsetof(struct AllInclusive, item8_11),
		.tag = (ASN_TAG_CLASS_CONTEXT | (231 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item8-11"
		},
};
static ber_tlv_tag_t asn_DEF_AllInclusive_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_AllInclusive_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* item6-1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* item6-2 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* item6-4 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* item6-5 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* item6-6 */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* item6-7 */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* item6-8 */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* item6-9 */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* item6-10 */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* item6-11 */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* item6-12 */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* item6-13 */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* item6-14 */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* item6-15 */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* item6-16 */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 }, /* item6-17 */
    { (ASN_TAG_CLASS_CONTEXT | (16 << 2)), 16, 0, 0 }, /* item6-18 */
    { (ASN_TAG_CLASS_CONTEXT | (17 << 2)), 17, 0, 0 }, /* item6-19 */
    { (ASN_TAG_CLASS_CONTEXT | (18 << 2)), 18, 0, 0 }, /* item6-20 */
    { (ASN_TAG_CLASS_CONTEXT | (19 << 2)), 19, 0, 0 }, /* item6-21 */
    { (ASN_TAG_CLASS_CONTEXT | (20 << 2)), 20, 0, 0 }, /* item6-22 */
    { (ASN_TAG_CLASS_CONTEXT | (21 << 2)), 21, 0, 0 }, /* item6-23 */
    { (ASN_TAG_CLASS_CONTEXT | (22 << 2)), 22, 0, 0 }, /* item6-24 */
    { (ASN_TAG_CLASS_CONTEXT | (23 << 2)), 23, 0, 0 }, /* item6-25 */
    { (ASN_TAG_CLASS_CONTEXT | (24 << 2)), 24, 0, 0 }, /* item6-26 */
    { (ASN_TAG_CLASS_CONTEXT | (25 << 2)), 25, 0, 0 }, /* item6-27 */
    { (ASN_TAG_CLASS_CONTEXT | (26 << 2)), 26, 0, 0 }, /* item6-28 */
    { (ASN_TAG_CLASS_CONTEXT | (27 << 2)), 27, 0, 0 }, /* item6-29 */
    { (ASN_TAG_CLASS_CONTEXT | (28 << 2)), 28, 0, 0 }, /* item6-30 */
    { (ASN_TAG_CLASS_CONTEXT | (29 << 2)), 29, 0, 0 }, /* item6-31 */
    { (ASN_TAG_CLASS_CONTEXT | (30 << 2)), 30, 0, 0 }, /* item6-32 */
    { (ASN_TAG_CLASS_CONTEXT | (31 << 2)), 31, 0, 0 }, /* item6-33 */
    { (ASN_TAG_CLASS_CONTEXT | (32 << 2)), 32, 0, 0 }, /* item6-34 */
    { (ASN_TAG_CLASS_CONTEXT | (33 << 2)), 33, 0, 0 }, /* item6-35 */
    { (ASN_TAG_CLASS_CONTEXT | (34 << 2)), 34, 0, 0 }, /* item6-36 */
    { (ASN_TAG_CLASS_CONTEXT | (35 << 2)), 35, 0, 0 }, /* item6-37 */
    { (ASN_TAG_CLASS_CONTEXT | (36 << 2)), 36, 0, 0 }, /* item6-38 */
    { (ASN_TAG_CLASS_CONTEXT | (37 << 2)), 37, 0, 0 }, /* item6-39 */
    { (ASN_TAG_CLASS_CONTEXT | (38 << 2)), 38, 0, 0 }, /* item6-40 */
    { (ASN_TAG_CLASS_CONTEXT | (39 << 2)), 39, 0, 0 }, /* item6-41 */
    { (ASN_TAG_CLASS_CONTEXT | (40 << 2)), 40, 0, 0 }, /* item6-42 */
    { (ASN_TAG_CLASS_CONTEXT | (41 << 2)), 41, 0, 0 }, /* item6-43 */
    { (ASN_TAG_CLASS_CONTEXT | (42 << 2)), 42, 0, 0 }, /* item6-44 */
    { (ASN_TAG_CLASS_CONTEXT | (43 << 2)), 43, 0, 0 }, /* item6-45 */
    { (ASN_TAG_CLASS_CONTEXT | (44 << 2)), 44, 0, 0 }, /* item6-46 */
    { (ASN_TAG_CLASS_CONTEXT | (45 << 2)), 45, 0, 0 }, /* item6-47 */
    { (ASN_TAG_CLASS_CONTEXT | (46 << 2)), 46, 0, 0 }, /* item6-48 */
    { (ASN_TAG_CLASS_CONTEXT | (47 << 2)), 47, 0, 0 }, /* item6-49 */
    { (ASN_TAG_CLASS_CONTEXT | (48 << 2)), 48, 0, 0 }, /* item6-50 */
    { (ASN_TAG_CLASS_CONTEXT | (49 << 2)), 49, 0, 0 }, /* item6-51 */
    { (ASN_TAG_CLASS_CONTEXT | (50 << 2)), 50, 0, 0 }, /* item6-52 */
    { (ASN_TAG_CLASS_CONTEXT | (51 << 2)), 51, 0, 0 }, /* item6-53 */
    { (ASN_TAG_CLASS_CONTEXT | (52 << 2)), 52, 0, 0 }, /* item6-54 */
    { (ASN_TAG_CLASS_CONTEXT | (53 << 2)), 53, 0, 0 }, /* item6-55 */
    { (ASN_TAG_CLASS_CONTEXT | (54 << 2)), 54, 0, 0 }, /* item6-56 */
    { (ASN_TAG_CLASS_CONTEXT | (55 << 2)), 55, 0, 0 }, /* item6-57 */
    { (ASN_TAG_CLASS_CONTEXT | (56 << 2)), 56, 0, 0 }, /* item6-58 */
    { (ASN_TAG_CLASS_CONTEXT | (57 << 2)), 57, 0, 0 }, /* item6-59 */
    { (ASN_TAG_CLASS_CONTEXT | (58 << 2)), 58, 0, 0 }, /* item6-60 */
    { (ASN_TAG_CLASS_CONTEXT | (59 << 2)), 59, 0, 0 }, /* item6-61 */
    { (ASN_TAG_CLASS_CONTEXT | (60 << 2)), 60, 0, 0 }, /* item6-62 */
    { (ASN_TAG_CLASS_CONTEXT | (61 << 2)), 61, 0, 0 }, /* item6-63 */
    { (ASN_TAG_CLASS_CONTEXT | (62 << 2)), 62, 0, 0 }, /* item6-64 */
    { (ASN_TAG_CLASS_CONTEXT | (63 << 2)), 63, 0, 0 }, /* item6-65 */
    { (ASN_TAG_CLASS_CONTEXT | (64 << 2)), 64, 0, 0 }, /* item6-66 */
    { (ASN_TAG_CLASS_CONTEXT | (65 << 2)), 65, 0, 0 }, /* item6-67 */
    { (ASN_TAG_CLASS_CONTEXT | (66 << 2)), 66, 0, 0 }, /* item6-68 */
    { (ASN_TAG_CLASS_CONTEXT | (67 << 2)), 67, 0, 0 }, /* item6-69 */
    { (ASN_TAG_CLASS_CONTEXT | (68 << 2)), 68, 0, 0 }, /* item6-70 */
    { (ASN_TAG_CLASS_CONTEXT | (69 << 2)), 69, 0, 0 }, /* item6-71 */
    { (ASN_TAG_CLASS_CONTEXT | (70 << 2)), 70, 0, 0 }, /* item6-72 */
    { (ASN_TAG_CLASS_CONTEXT | (71 << 2)), 71, 0, 0 }, /* item6-73 */
    { (ASN_TAG_CLASS_CONTEXT | (72 << 2)), 72, 0, 0 }, /* item7-1 */
    { (ASN_TAG_CLASS_CONTEXT | (73 << 2)), 73, 0, 0 }, /* item7-2 */
    { (ASN_TAG_CLASS_CONTEXT | (74 << 2)), 74, 0, 0 }, /* item7-3 */
    { (ASN_TAG_CLASS_CONTEXT | (75 << 2)), 75, 0, 0 }, /* item7-4 */
    { (ASN_TAG_CLASS_CONTEXT | (76 << 2)), 76, 0, 0 }, /* item7-5 */
    { (ASN_TAG_CLASS_CONTEXT | (77 << 2)), 77, 0, 0 }, /* item7-6 */
    { (ASN_TAG_CLASS_CONTEXT | (78 << 2)), 78, 0, 0 }, /* item7-7 */
    { (ASN_TAG_CLASS_CONTEXT | (79 << 2)), 79, 0, 0 }, /* item7-8 */
    { (ASN_TAG_CLASS_CONTEXT | (80 << 2)), 80, 0, 0 }, /* item7-9 */
    { (ASN_TAG_CLASS_CONTEXT | (81 << 2)), 81, 0, 0 }, /* item7-10 */
    { (ASN_TAG_CLASS_CONTEXT | (82 << 2)), 82, 0, 0 }, /* item7-11 */
    { (ASN_TAG_CLASS_CONTEXT | (83 << 2)), 83, 0, 0 }, /* item7-12 */
    { (ASN_TAG_CLASS_CONTEXT | (84 << 2)), 84, 0, 0 }, /* item7-13 */
    { (ASN_TAG_CLASS_CONTEXT | (85 << 2)), 85, 0, 0 }, /* item7-14 */
    { (ASN_TAG_CLASS_CONTEXT | (86 << 2)), 86, 0, 0 }, /* item7-15 */
    { (ASN_TAG_CLASS_CONTEXT | (87 << 2)), 87, 0, 0 }, /* item7-16 */
    { (ASN_TAG_CLASS_CONTEXT | (88 << 2)), 88, 0, 0 }, /* item7-17 */
    { (ASN_TAG_CLASS_CONTEXT | (89 << 2)), 89, 0, 0 }, /* item7-18 */
    { (ASN_TAG_CLASS_CONTEXT | (90 << 2)), 90, 0, 0 }, /* item7-19 */
    { (ASN_TAG_CLASS_CONTEXT | (91 << 2)), 91, 0, 0 }, /* item7-20 */
    { (ASN_TAG_CLASS_CONTEXT | (92 << 2)), 92, 0, 0 }, /* item7-21 */
    { (ASN_TAG_CLASS_CONTEXT | (93 << 2)), 93, 0, 0 }, /* item7-22 */
    { (ASN_TAG_CLASS_CONTEXT | (94 << 2)), 94, 0, 0 }, /* item7-23 */
    { (ASN_TAG_CLASS_CONTEXT | (95 << 2)), 95, 0, 0 }, /* item7-24 */
    { (ASN_TAG_CLASS_CONTEXT | (96 << 2)), 96, 0, 0 }, /* item7-25 */
    { (ASN_TAG_CLASS_CONTEXT | (97 << 2)), 97, 0, 0 }, /* item7-26 */
    { (ASN_TAG_CLASS_CONTEXT | (98 << 2)), 98, 0, 0 }, /* item7-27 */
    { (ASN_TAG_CLASS_CONTEXT | (99 << 2)), 99, 0, 0 }, /* item7-28 */
    { (ASN_TAG_CLASS_CONTEXT | (100 << 2)), 100, 0, 0 }, /* item7-29 */
    { (ASN_TAG_CLASS_CONTEXT | (101 << 2)), 101, 0, 0 }, /* item7-30 */
    { (ASN_TAG_CLASS_CONTEXT | (102 << 2)), 102, 0, 0 }, /* item7-31 */
    { (ASN_TAG_CLASS_CONTEXT | (103 << 2)), 103, 0, 0 }, /* item7-32 */
    { (ASN_TAG_CLASS_CONTEXT | (104 << 2)), 104, 0, 0 }, /* item7-33 */
    { (ASN_TAG_CLASS_CONTEXT | (105 << 2)), 105, 0, 0 }, /* item7-34 */
    { (ASN_TAG_CLASS_CONTEXT | (106 << 2)), 106, 0, 0 }, /* item7-35 */
    { (ASN_TAG_CLASS_CONTEXT | (107 << 2)), 107, 0, 0 }, /* item7-36 */
    { (ASN_TAG_CLASS_CONTEXT | (108 << 2)), 108, 0, 0 }, /* item7-37 */
    { (ASN_TAG_CLASS_CONTEXT | (109 << 2)), 109, 0, 0 }, /* item7-38 */
    { (ASN_TAG_CLASS_CONTEXT | (110 << 2)), 110, 0, 0 }, /* item7-39 */
    { (ASN_TAG_CLASS_CONTEXT | (111 << 2)), 111, 0, 0 }, /* item7-40 */
    { (ASN_TAG_CLASS_CONTEXT | (112 << 2)), 112, 0, 0 }, /* item7-41 */
    { (ASN_TAG_CLASS_CONTEXT | (113 << 2)), 113, 0, 0 }, /* item7-42 */
    { (ASN_TAG_CLASS_CONTEXT | (114 << 2)), 114, 0, 0 }, /* item7-43 */
    { (ASN_TAG_CLASS_CONTEXT | (115 << 2)), 115, 0, 0 }, /* item7-44 */
    { (ASN_TAG_CLASS_CONTEXT | (116 << 2)), 116, 0, 0 }, /* item7-45 */
    { (ASN_TAG_CLASS_CONTEXT | (117 << 2)), 117, 0, 0 }, /* item7-46 */
    { (ASN_TAG_CLASS_CONTEXT | (118 << 2)), 118, 0, 0 }, /* item7-47 */
    { (ASN_TAG_CLASS_CONTEXT | (119 << 2)), 119, 0, 0 }, /* item7-48 */
    { (ASN_TAG_CLASS_CONTEXT | (120 << 2)), 120, 0, 0 }, /* item7-49 */
    { (ASN_TAG_CLASS_CONTEXT | (121 << 2)), 121, 0, 0 }, /* item7-50 */
    { (ASN_TAG_CLASS_CONTEXT | (122 << 2)), 122, 0, 0 }, /* item7-51 */
    { (ASN_TAG_CLASS_CONTEXT | (123 << 2)), 123, 0, 0 }, /* item7-52 */
    { (ASN_TAG_CLASS_CONTEXT | (124 << 2)), 124, 0, 0 }, /* item7-53 */
    { (ASN_TAG_CLASS_CONTEXT | (125 << 2)), 125, 0, 0 }, /* item7-54 */
    { (ASN_TAG_CLASS_CONTEXT | (126 << 2)), 126, 0, 0 }, /* item7-55 */
    { (ASN_TAG_CLASS_CONTEXT | (127 << 2)), 127, 0, 0 }, /* item7-56 */
    { (ASN_TAG_CLASS_CONTEXT | (128 << 2)), 128, 0, 0 }, /* item7-57 */
    { (ASN_TAG_CLASS_CONTEXT | (129 << 2)), 129, 0, 0 }, /* item7-58 */
    { (ASN_TAG_CLASS_CONTEXT | (130 << 2)), 130, 0, 0 }, /* item7-59 */
    { (ASN_TAG_CLASS_CONTEXT | (131 << 2)), 131, 0, 0 }, /* item7-60 */
    { (ASN_TAG_CLASS_CONTEXT | (132 << 2)), 132, 0, 0 }, /* item7-61 */
    { (ASN_TAG_CLASS_CONTEXT | (133 << 2)), 133, 0, 0 }, /* item7-62 */
    { (ASN_TAG_CLASS_CONTEXT | (134 << 2)), 134, 0, 0 }, /* item7-63 */
    { (ASN_TAG_CLASS_CONTEXT | (135 << 2)), 135, 0, 0 }, /* item7-64 */
    { (ASN_TAG_CLASS_CONTEXT | (136 << 2)), 136, 0, 0 }, /* item7-65 */
    { (ASN_TAG_CLASS_CONTEXT | (137 << 2)), 137, 0, 0 }, /* item7-66 */
    { (ASN_TAG_CLASS_CONTEXT | (138 << 2)), 138, 0, 0 }, /* item7-67 */
    { (ASN_TAG_CLASS_CONTEXT | (139 << 2)), 139, 0, 0 }, /* item7-68 */
    { (ASN_TAG_CLASS_CONTEXT | (140 << 2)), 140, 0, 0 }, /* item7-69 */
    { (ASN_TAG_CLASS_CONTEXT | (141 << 2)), 141, 0, 0 }, /* item7-70 */
    { (ASN_TAG_CLASS_CONTEXT | (142 << 2)), 142, 0, 0 }, /* item7-71 */
    { (ASN_TAG_CLASS_CONTEXT | (143 << 2)), 143, 0, 0 }, /* item7-72 */
    { (ASN_TAG_CLASS_CONTEXT | (144 << 2)), 144, 0, 0 }, /* item7-73 */
    { (ASN_TAG_CLASS_CONTEXT | (145 << 2)), 145, 0, 0 }, /* item7-74 */
    { (ASN_TAG_CLASS_CONTEXT | (146 << 2)), 146, 0, 0 }, /* item7-75 */
    { (ASN_TAG_CLASS_CONTEXT | (147 << 2)), 147, 0, 0 }, /* item7-76 */
    { (ASN_TAG_CLASS_CONTEXT | (148 << 2)), 148, 0, 0 }, /* item7-77 */
    { (ASN_TAG_CLASS_CONTEXT | (149 << 2)), 149, 0, 0 }, /* item7-78 */
    { (ASN_TAG_CLASS_CONTEXT | (150 << 2)), 150, 0, 0 }, /* item7-79 */
    { (ASN_TAG_CLASS_CONTEXT | (151 << 2)), 151, 0, 0 }, /* item7-80 */
    { (ASN_TAG_CLASS_CONTEXT | (152 << 2)), 152, 0, 0 }, /* item7-81 */
    { (ASN_TAG_CLASS_CONTEXT | (153 << 2)), 153, 0, 0 }, /* item7-82 */
    { (ASN_TAG_CLASS_CONTEXT | (154 << 2)), 154, 0, 0 }, /* item7-83 */
    { (ASN_TAG_CLASS_CONTEXT | (155 << 2)), 155, 0, 0 }, /* item7-84 */
    { (ASN_TAG_CLASS_CONTEXT | (156 << 2)), 156, 0, 0 }, /* item7-85 */
    { (ASN_TAG_CLASS_CONTEXT | (157 << 2)), 157, 0, 0 }, /* item7-86 */
    { (ASN_TAG_CLASS_CONTEXT | (158 << 2)), 158, 0, 0 }, /* item7-87 */
    { (ASN_TAG_CLASS_CONTEXT | (159 << 2)), 159, 0, 0 }, /* item7-88 */
    { (ASN_TAG_CLASS_CONTEXT | (160 << 2)), 160, 0, 0 }, /* item7-89 */
    { (ASN_TAG_CLASS_CONTEXT | (161 << 2)), 161, 0, 0 }, /* item7-90 */
    { (ASN_TAG_CLASS_CONTEXT | (162 << 2)), 162, 0, 0 }, /* item7-91 */
    { (ASN_TAG_CLASS_CONTEXT | (163 << 2)), 163, 0, 0 }, /* item7-92 */
    { (ASN_TAG_CLASS_CONTEXT | (164 << 2)), 164, 0, 0 }, /* item7-93 */
    { (ASN_TAG_CLASS_CONTEXT | (165 << 2)), 165, 0, 0 }, /* item7-94 */
    { (ASN_TAG_CLASS_CONTEXT | (166 << 2)), 166, 0, 0 }, /* item7-95 */
    { (ASN_TAG_CLASS_CONTEXT | (167 << 2)), 167, 0, 0 }, /* item7-96 */
    { (ASN_TAG_CLASS_CONTEXT | (168 << 2)), 168, 0, 0 }, /* item7-97 */
    { (ASN_TAG_CLASS_CONTEXT | (169 << 2)), 169, 0, 0 }, /* item7-98 */
    { (ASN_TAG_CLASS_CONTEXT | (170 << 2)), 170, 0, 0 }, /* item7-99 */
    { (ASN_TAG_CLASS_CONTEXT | (171 << 2)), 171, 0, 0 }, /* item7-100 */
    { (ASN_TAG_CLASS_CONTEXT | (172 << 2)), 172, 0, 0 }, /* item7-101 */
    { (ASN_TAG_CLASS_CONTEXT | (173 << 2)), 173, 0, 0 }, /* item7-102 */
    { (ASN_TAG_CLASS_CONTEXT | (174 << 2)), 174, 0, 0 }, /* item7-103 */
    { (ASN_TAG_CLASS_CONTEXT | (175 << 2)), 175, 0, 0 }, /* item7-104 */
    { (ASN_TAG_CLASS_CONTEXT | (176 << 2)), 176, 0, 0 }, /* item7-105 */
    { (ASN_TAG_CLASS_CONTEXT | (177 << 2)), 177, 0, 0 }, /* item7-106 */
    { (ASN_TAG_CLASS_CONTEXT | (178 << 2)), 178, 0, 0 }, /* item7-107 */
    { (ASN_TAG_CLASS_CONTEXT | (179 << 2)), 179, 0, 0 }, /* item7-108 */
    { (ASN_TAG_CLASS_CONTEXT | (180 << 2)), 180, 0, 0 }, /* item7-109 */
    { (ASN_TAG_CLASS_CONTEXT | (181 << 2)), 181, 0, 0 }, /* item7-110 */
    { (ASN_TAG_CLASS_CONTEXT | (182 << 2)), 182, 0, 0 }, /* item7-111 */
    { (ASN_TAG_CLASS_CONTEXT | (183 << 2)), 183, 0, 0 }, /* item7-112 */
    { (ASN_TAG_CLASS_CONTEXT | (184 << 2)), 184, 0, 0 }, /* item7-113 */
    { (ASN_TAG_CLASS_CONTEXT | (185 << 2)), 185, 0, 0 }, /* item7-114 */
    { (ASN_TAG_CLASS_CONTEXT | (186 << 2)), 186, 0, 0 }, /* item7-115 */
    { (ASN_TAG_CLASS_CONTEXT | (187 << 2)), 187, 0, 0 }, /* item7-116 */
    { (ASN_TAG_CLASS_CONTEXT | (188 << 2)), 188, 0, 0 }, /* item7-117 */
    { (ASN_TAG_CLASS_CONTEXT | (189 << 2)), 189, 0, 0 }, /* item7-118 */
    { (ASN_TAG_CLASS_CONTEXT | (190 << 2)), 190, 0, 0 }, /* item7-119 */
    { (ASN_TAG_CLASS_CONTEXT | (191 << 2)), 191, 0, 0 }, /* item7-120 */
    { (ASN_TAG_CLASS_CONTEXT | (192 << 2)), 192, 0, 0 }, /* item7-121 */
    { (ASN_TAG_CLASS_CONTEXT | (193 << 2)), 193, 0, 0 }, /* item7-122 */
    { (ASN_TAG_CLASS_CONTEXT | (194 << 2)), 194, 0, 0 }, /* item7-123 */
    { (ASN_TAG_CLASS_CONTEXT | (195 << 2)), 195, 0, 0 }, /* item7-124 */
    { (ASN_TAG_CLASS_CONTEXT | (196 << 2)), 196, 0, 0 }, /* item7-125 */
    { (ASN_TAG_CLASS_CONTEXT | (197 << 2)), 197, 0, 0 }, /* item7-126 */
    { (ASN_TAG_CLASS_CONTEXT | (198 << 2)), 198, 0, 0 }, /* item7-127 */
    { (ASN_TAG_CLASS_CONTEXT | (199 << 2)), 199, 0, 0 }, /* item7-128 */
    { (ASN_TAG_CLASS_CONTEXT | (200 << 2)), 200, 0, 0 }, /* item7-129 */
    { (ASN_TAG_CLASS_CONTEXT | (201 << 2)), 201, 0, 0 }, /* item7-130 */
    { (ASN_TAG_CLASS_CONTEXT | (202 << 2)), 202, 0, 0 }, /* item7-131 */
    { (ASN_TAG_CLASS_CONTEXT | (203 << 2)), 203, 0, 0 }, /* item7-132 */
    { (ASN_TAG_CLASS_CONTEXT | (204 << 2)), 204, 0, 0 }, /* item7-133 */
    { (ASN_TAG_CLASS_CONTEXT | (205 << 2)), 205, 0, 0 }, /* item7-134 */
    { (ASN_TAG_CLASS_CONTEXT | (206 << 2)), 206, 0, 0 }, /* item7-135 */
    { (ASN_TAG_CLASS_CONTEXT | (207 << 2)), 207, 0, 0 }, /* item7-136 */
    { (ASN_TAG_CLASS_CONTEXT | (208 << 2)), 208, 0, 0 }, /* item7-137 */
    { (ASN_TAG_CLASS_CONTEXT | (209 << 2)), 209, 0, 0 }, /* item7-138 */
    { (ASN_TAG_CLASS_CONTEXT | (210 << 2)), 210, 0, 0 }, /* item7-139 */
    { (ASN_TAG_CLASS_CONTEXT | (211 << 2)), 211, 0, 0 }, /* item7-140 */
    { (ASN_TAG_CLASS_CONTEXT | (212 << 2)), 212, 0, 0 }, /* item7-141 */
    { (ASN_TAG_CLASS_CONTEXT | (213 << 2)), 213, 0, 0 }, /* item7-142 */
    { (ASN_TAG_CLASS_CONTEXT | (214 << 2)), 214, 0, 0 }, /* item7-143 */
    { (ASN_TAG_CLASS_CONTEXT | (215 << 2)), 215, 0, 0 }, /* item7-144 */
    { (ASN_TAG_CLASS_CONTEXT | (216 << 2)), 216, 0, 0 }, /* item7-145 */
    { (ASN_TAG_CLASS_CONTEXT | (217 << 2)), 217, 0, 0 }, /* item7-146 */
    { (ASN_TAG_CLASS_CONTEXT | (218 << 2)), 218, 0, 0 }, /* item7-147 */
    { (ASN_TAG_CLASS_CONTEXT | (219 << 2)), 219, 0, 0 }, /* item7-148 */
    { (ASN_TAG_CLASS_CONTEXT | (220 << 2)), 220, 0, 0 }, /* item7-149 */
    { (ASN_TAG_CLASS_CONTEXT | (221 << 2)), 221, 0, 0 }, /* item8-1 */
    { (ASN_TAG_CLASS_CONTEXT | (222 << 2)), 222, 0, 0 }, /* item8-2 */
    { (ASN_TAG_CLASS_CONTEXT | (223 << 2)), 223, 0, 0 }, /* item8-3 */
    { (ASN_TAG_CLASS_CONTEXT | (224 << 2)), 224, 0, 0 }, /* item8-4 */
    { (ASN_TAG_CLASS_CONTEXT | (225 << 2)), 225, 0, 0 }, /* item8-5 */
    { (ASN_TAG_CLASS_CONTEXT | (226 << 2)), 226, 0, 0 }, /* item8-6 */
    { (ASN_TAG_CLASS_CONTEXT | (227 << 2)), 227, 0, 0 }, /* item8-7 */
    { (ASN_TAG_CLASS_CONTEXT | (228 << 2)), 228, 0, 0 }, /* item8-8 */
    { (ASN_TAG_CLASS_CONTEXT | (229 << 2)), 229, 0, 0 }, /* item8-9 */
    { (ASN_TAG_CLASS_CONTEXT | (230 << 2)), 230, 0, 0 }, /* item8-10 */
    { (ASN_TAG_CLASS_CONTEXT | (231 << 2)), 231, 0, 0 } /* item8-11 */
};
static asn_SEQUENCE_specifics_t asn_SPC_AllInclusive_specs_1 = {
	sizeof(struct AllInclusive),
	offsetof(struct AllInclusive, _asn_ctx),
	asn_MAP_AllInclusive_tag2el_1,
	232,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	231,	/* Start extensions */
	233	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_AllInclusive = {
	"AllInclusive",
	"AllInclusive",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AllInclusive_tags_1,
	sizeof(asn_DEF_AllInclusive_tags_1)
		/sizeof(asn_DEF_AllInclusive_tags_1[0]), /* 1 */
	asn_DEF_AllInclusive_tags_1,	/* Same as above */
	sizeof(asn_DEF_AllInclusive_tags_1)
		/sizeof(asn_DEF_AllInclusive_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_AllInclusive_1,
	232,	/* Elements count */
	&asn_SPC_AllInclusive_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [AntennaOffsetSet] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [AntennaOffsetSet] >>> ***/

typedef OCTET_STRING_t	 AntennaOffsetSet_t;

/*** <<< FUNC-DECLS [AntennaOffsetSet] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AntennaOffsetSet;
asn_struct_free_f AntennaOffsetSet_free;
asn_struct_print_f AntennaOffsetSet_print;
asn_constr_check_f AntennaOffsetSet_constraint;
ber_type_decoder_f AntennaOffsetSet_decode_ber;
der_type_encoder_f AntennaOffsetSet_encode_der;
xer_type_decoder_f AntennaOffsetSet_decode_xer;
xer_type_encoder_f AntennaOffsetSet_encode_xer;

/*** <<< CODE [AntennaOffsetSet] >>> ***/

int
AntennaOffsetSet_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 4)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
AntennaOffsetSet_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
AntennaOffsetSet_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AntennaOffsetSet_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AntennaOffsetSet_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AntennaOffsetSet_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AntennaOffsetSet_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AntennaOffsetSet_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AntennaOffsetSet_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AntennaOffsetSet_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AntennaOffsetSet_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AntennaOffsetSet_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AntennaOffsetSet_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AntennaOffsetSet_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AntennaOffsetSet] >>> ***/

static ber_tlv_tag_t asn_DEF_AntennaOffsetSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AntennaOffsetSet = {
	"AntennaOffsetSet",
	"AntennaOffsetSet",
	AntennaOffsetSet_free,
	AntennaOffsetSet_print,
	AntennaOffsetSet_constraint,
	AntennaOffsetSet_decode_ber,
	AntennaOffsetSet_encode_der,
	AntennaOffsetSet_decode_xer,
	AntennaOffsetSet_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AntennaOffsetSet_tags_1,
	sizeof(asn_DEF_AntennaOffsetSet_tags_1)
		/sizeof(asn_DEF_AntennaOffsetSet_tags_1[0]), /* 1 */
	asn_DEF_AntennaOffsetSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_AntennaOffsetSet_tags_1)
		/sizeof(asn_DEF_AntennaOffsetSet_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Approach] >>> ***/

#include "DescriptiveName.h"
#include "ApproachNumber.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Approach] >>> ***/

struct VehicleReferenceLane;
struct VehicleComputedLane;
struct SpecialLane;
struct BarrierLane;
struct CrosswalkLane;

/*** <<< TYPE-DECLS [Approach] >>> ***/

typedef struct Approach {
	DescriptiveName_t	*name	/* OPTIONAL */;
	ApproachNumber_t	*id	/* OPTIONAL */;
	struct drivingLanes {
		A_SEQUENCE_OF(struct VehicleReferenceLane) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *drivingLanes;
	struct computedLanes {
		A_SEQUENCE_OF(struct VehicleComputedLane) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *computedLanes;
	struct trainsAndBuses {
		A_SEQUENCE_OF(struct SpecialLane) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *trainsAndBuses;
	struct barriers {
		A_SEQUENCE_OF(struct BarrierLane) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *barriers;
	struct crosswalks {
		A_SEQUENCE_OF(struct CrosswalkLane) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *crosswalks;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Approach_t;

/*** <<< FUNC-DECLS [Approach] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Approach;

/*** <<< POST-INCLUDE [Approach] >>> ***/

#include "VehicleReferenceLane.h"
#include "VehicleComputedLane.h"
#include "SpecialLane.h"
#include "BarrierLane.h"
#include "CrosswalkLane.h"

/*** <<< CODE [Approach] >>> ***/

static int
memb_drivingLanes_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_computedLanes_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_trainsAndBuses_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_barriers_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_crosswalks_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [Approach] >>> ***/

static asn_TYPE_member_t asn_MBR_drivingLanes_4[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_VehicleReferenceLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_drivingLanes_tags_4[] = {
	(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_drivingLanes_specs_4 = {
	sizeof(struct drivingLanes),
	offsetof(struct drivingLanes, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_drivingLanes_4 = {
	"drivingLanes",
	"drivingLanes",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_drivingLanes_tags_4,
	sizeof(asn_DEF_drivingLanes_tags_4)
		/sizeof(asn_DEF_drivingLanes_tags_4[0]) - 1, /* 1 */
	asn_DEF_drivingLanes_tags_4,	/* Same as above */
	sizeof(asn_DEF_drivingLanes_tags_4)
		/sizeof(asn_DEF_drivingLanes_tags_4[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_drivingLanes_4,
	1,	/* Single element */
	&asn_SPC_drivingLanes_specs_4	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_computedLanes_6[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_VehicleComputedLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_computedLanes_tags_6[] = {
	(ASN_TAG_CLASS_CONTEXT | (3 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_computedLanes_specs_6 = {
	sizeof(struct computedLanes),
	offsetof(struct computedLanes, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_computedLanes_6 = {
	"computedLanes",
	"computedLanes",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_computedLanes_tags_6,
	sizeof(asn_DEF_computedLanes_tags_6)
		/sizeof(asn_DEF_computedLanes_tags_6[0]) - 1, /* 1 */
	asn_DEF_computedLanes_tags_6,	/* Same as above */
	sizeof(asn_DEF_computedLanes_tags_6)
		/sizeof(asn_DEF_computedLanes_tags_6[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_computedLanes_6,
	1,	/* Single element */
	&asn_SPC_computedLanes_specs_6	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_trainsAndBuses_8[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_SpecialLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_trainsAndBuses_tags_8[] = {
	(ASN_TAG_CLASS_CONTEXT | (4 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_trainsAndBuses_specs_8 = {
	sizeof(struct trainsAndBuses),
	offsetof(struct trainsAndBuses, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_trainsAndBuses_8 = {
	"trainsAndBuses",
	"trainsAndBuses",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_trainsAndBuses_tags_8,
	sizeof(asn_DEF_trainsAndBuses_tags_8)
		/sizeof(asn_DEF_trainsAndBuses_tags_8[0]) - 1, /* 1 */
	asn_DEF_trainsAndBuses_tags_8,	/* Same as above */
	sizeof(asn_DEF_trainsAndBuses_tags_8)
		/sizeof(asn_DEF_trainsAndBuses_tags_8[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_trainsAndBuses_8,
	1,	/* Single element */
	&asn_SPC_trainsAndBuses_specs_8	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_barriers_10[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_BarrierLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_barriers_tags_10[] = {
	(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_barriers_specs_10 = {
	sizeof(struct barriers),
	offsetof(struct barriers, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_barriers_10 = {
	"barriers",
	"barriers",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_barriers_tags_10,
	sizeof(asn_DEF_barriers_tags_10)
		/sizeof(asn_DEF_barriers_tags_10[0]) - 1, /* 1 */
	asn_DEF_barriers_tags_10,	/* Same as above */
	sizeof(asn_DEF_barriers_tags_10)
		/sizeof(asn_DEF_barriers_tags_10[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_barriers_10,
	1,	/* Single element */
	&asn_SPC_barriers_specs_10	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_crosswalks_12[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_CrosswalkLane,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_crosswalks_tags_12[] = {
	(ASN_TAG_CLASS_CONTEXT | (6 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_crosswalks_specs_12 = {
	sizeof(struct crosswalks),
	offsetof(struct crosswalks, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_crosswalks_12 = {
	"crosswalks",
	"crosswalks",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_crosswalks_tags_12,
	sizeof(asn_DEF_crosswalks_tags_12)
		/sizeof(asn_DEF_crosswalks_tags_12[0]) - 1, /* 1 */
	asn_DEF_crosswalks_tags_12,	/* Same as above */
	sizeof(asn_DEF_crosswalks_tags_12)
		/sizeof(asn_DEF_crosswalks_tags_12[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_crosswalks_12,
	1,	/* Single element */
	&asn_SPC_crosswalks_specs_12	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Approach_1[] = {
	{ ATF_POINTER, 7, offsetof(struct Approach, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_POINTER, 6, offsetof(struct Approach, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ApproachNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_POINTER, 5, offsetof(struct Approach, drivingLanes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_drivingLanes_4,
		.memb_constraints = memb_drivingLanes_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "drivingLanes"
		},
	{ ATF_POINTER, 4, offsetof(struct Approach, computedLanes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_computedLanes_6,
		.memb_constraints = memb_computedLanes_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "computedLanes"
		},
	{ ATF_POINTER, 3, offsetof(struct Approach, trainsAndBuses),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_trainsAndBuses_8,
		.memb_constraints = memb_trainsAndBuses_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "trainsAndBuses"
		},
	{ ATF_POINTER, 2, offsetof(struct Approach, barriers),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_barriers_10,
		.memb_constraints = memb_barriers_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "barriers"
		},
	{ ATF_POINTER, 1, offsetof(struct Approach, crosswalks),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_crosswalks_12,
		.memb_constraints = memb_crosswalks_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crosswalks"
		},
};
static ber_tlv_tag_t asn_DEF_Approach_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Approach_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* drivingLanes */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* computedLanes */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* trainsAndBuses */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* barriers */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 } /* crosswalks */
};
static asn_SEQUENCE_specifics_t asn_SPC_Approach_specs_1 = {
	sizeof(struct Approach),
	offsetof(struct Approach, _asn_ctx),
	asn_MAP_Approach_tag2el_1,
	7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	6,	/* Start extensions */
	8	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Approach = {
	"Approach",
	"Approach",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Approach_tags_1,
	sizeof(asn_DEF_Approach_tags_1)
		/sizeof(asn_DEF_Approach_tags_1[0]), /* 1 */
	asn_DEF_Approach_tags_1,	/* Same as above */
	sizeof(asn_DEF_Approach_tags_1)
		/sizeof(asn_DEF_Approach_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Approach_1,
	7,	/* Elements count */
	&asn_SPC_Approach_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ApproachObject] >>> ***/

#include "LaneWidth.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [ApproachObject] >>> ***/

struct Position3D;
struct Approach;

/*** <<< TYPE-DECLS [ApproachObject] >>> ***/

typedef struct ApproachObject {
	struct Position3D	*refPoint	/* OPTIONAL */;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	struct Approach	*approach	/* OPTIONAL */;
	struct Approach	*egress	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ApproachObject_t;

/*** <<< FUNC-DECLS [ApproachObject] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ApproachObject;

/*** <<< POST-INCLUDE [ApproachObject] >>> ***/

#include "Position3D.h"
#include "Approach.h"

/*** <<< STAT-DEFS [ApproachObject] >>> ***/

static asn_TYPE_member_t asn_MBR_ApproachObject_1[] = {
	{ ATF_POINTER, 4, offsetof(struct ApproachObject, refPoint),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "refPoint"
		},
	{ ATF_POINTER, 3, offsetof(struct ApproachObject, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_POINTER, 2, offsetof(struct ApproachObject, approach),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Approach,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "approach"
		},
	{ ATF_POINTER, 1, offsetof(struct ApproachObject, egress),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Approach,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "egress"
		},
};
static ber_tlv_tag_t asn_DEF_ApproachObject_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ApproachObject_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* refPoint */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* approach */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* egress */
};
static asn_SEQUENCE_specifics_t asn_SPC_ApproachObject_specs_1 = {
	sizeof(struct ApproachObject),
	offsetof(struct ApproachObject, _asn_ctx),
	asn_MAP_ApproachObject_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ApproachObject = {
	"ApproachObject",
	"ApproachObject",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ApproachObject_tags_1,
	sizeof(asn_DEF_ApproachObject_tags_1)
		/sizeof(asn_DEF_ApproachObject_tags_1[0]), /* 1 */
	asn_DEF_ApproachObject_tags_1,	/* Same as above */
	sizeof(asn_DEF_ApproachObject_tags_1)
		/sizeof(asn_DEF_ApproachObject_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ApproachObject_1,
	4,	/* Elements count */
	&asn_SPC_ApproachObject_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [BarrierLane] >>> ***/

#include "LaneNumber.h"
#include "LaneWidth.h"
#include "BarrierAttributes.h"
#include "NodeList.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [BarrierLane] >>> ***/

typedef struct BarrierLane {
	LaneNumber_t	 laneNumber;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	BarrierAttributes_t	 barrierAttributes;
	NodeList_t	 nodeList;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} BarrierLane_t;

/*** <<< FUNC-DECLS [BarrierLane] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BarrierLane;

/*** <<< STAT-DEFS [BarrierLane] >>> ***/

static asn_TYPE_member_t asn_MBR_BarrierLane_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BarrierLane, laneNumber),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneNumber"
		},
	{ ATF_POINTER, 1, offsetof(struct BarrierLane, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BarrierLane, barrierAttributes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BarrierAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "barrierAttributes"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BarrierLane, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
};
static ber_tlv_tag_t asn_DEF_BarrierLane_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_BarrierLane_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* laneNumber */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* barrierAttributes */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* nodeList */
};
static asn_SEQUENCE_specifics_t asn_SPC_BarrierLane_specs_1 = {
	sizeof(struct BarrierLane),
	offsetof(struct BarrierLane, _asn_ctx),
	asn_MAP_BarrierLane_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_BarrierLane = {
	"BarrierLane",
	"BarrierLane",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BarrierLane_tags_1,
	sizeof(asn_DEF_BarrierLane_tags_1)
		/sizeof(asn_DEF_BarrierLane_tags_1[0]), /* 1 */
	asn_DEF_BarrierLane_tags_1,	/* Same as above */
	sizeof(asn_DEF_BarrierLane_tags_1)
		/sizeof(asn_DEF_BarrierLane_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_BarrierLane_1,
	4,	/* Elements count */
	&asn_SPC_BarrierLane_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [BrakeSystemStatus] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [BrakeSystemStatus] >>> ***/

typedef OCTET_STRING_t	 BrakeSystemStatus_t;

/*** <<< FUNC-DECLS [BrakeSystemStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BrakeSystemStatus;
asn_struct_free_f BrakeSystemStatus_free;
asn_struct_print_f BrakeSystemStatus_print;
asn_constr_check_f BrakeSystemStatus_constraint;
ber_type_decoder_f BrakeSystemStatus_decode_ber;
der_type_encoder_f BrakeSystemStatus_encode_der;
xer_type_decoder_f BrakeSystemStatus_decode_xer;
xer_type_encoder_f BrakeSystemStatus_encode_xer;

/*** <<< CODE [BrakeSystemStatus] >>> ***/

int
BrakeSystemStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
BrakeSystemStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
BrakeSystemStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BrakeSystemStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BrakeSystemStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeSystemStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BrakeSystemStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BrakeSystemStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BrakeSystemStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeSystemStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BrakeSystemStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BrakeSystemStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BrakeSystemStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeSystemStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BrakeSystemStatus] >>> ***/

static ber_tlv_tag_t asn_DEF_BrakeSystemStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BrakeSystemStatus = {
	"BrakeSystemStatus",
	"BrakeSystemStatus",
	BrakeSystemStatus_free,
	BrakeSystemStatus_print,
	BrakeSystemStatus_constraint,
	BrakeSystemStatus_decode_ber,
	BrakeSystemStatus_encode_der,
	BrakeSystemStatus_decode_xer,
	BrakeSystemStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BrakeSystemStatus_tags_1,
	sizeof(asn_DEF_BrakeSystemStatus_tags_1)
		/sizeof(asn_DEF_BrakeSystemStatus_tags_1[0]), /* 1 */
	asn_DEF_BrakeSystemStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_BrakeSystemStatus_tags_1)
		/sizeof(asn_DEF_BrakeSystemStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [BSMblob] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [BSMblob] >>> ***/

typedef OCTET_STRING_t	 BSMblob_t;

/*** <<< FUNC-DECLS [BSMblob] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BSMblob;
asn_struct_free_f BSMblob_free;
asn_struct_print_f BSMblob_print;
asn_constr_check_f BSMblob_constraint;
ber_type_decoder_f BSMblob_decode_ber;
der_type_encoder_f BSMblob_encode_der;
xer_type_decoder_f BSMblob_decode_xer;
xer_type_encoder_f BSMblob_encode_xer;

/*** <<< CODE [BSMblob] >>> ***/

int
BSMblob_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 38)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
BSMblob_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
BSMblob_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BSMblob_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BSMblob_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BSMblob_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BSMblob_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BSMblob_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BSMblob_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BSMblob_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BSMblob_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BSMblob_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BSMblob_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BSMblob_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BSMblob] >>> ***/

static ber_tlv_tag_t asn_DEF_BSMblob_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BSMblob = {
	"BSMblob",
	"BSMblob",
	BSMblob_free,
	BSMblob_print,
	BSMblob_constraint,
	BSMblob_decode_ber,
	BSMblob_encode_der,
	BSMblob_decode_xer,
	BSMblob_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BSMblob_tags_1,
	sizeof(asn_DEF_BSMblob_tags_1)
		/sizeof(asn_DEF_BSMblob_tags_1[0]), /* 1 */
	asn_DEF_BSMblob_tags_1,	/* Same as above */
	sizeof(asn_DEF_BSMblob_tags_1)
		/sizeof(asn_DEF_BSMblob_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [BumperHeights] >>> ***/

#include "BumperHeightFront.h"
#include "BumperHeightRear.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [BumperHeights] >>> ***/

typedef struct BumperHeights {
	BumperHeightFront_t	 frnt;
	BumperHeightRear_t	 rear;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} BumperHeights_t;

/*** <<< FUNC-DECLS [BumperHeights] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BumperHeights;

/*** <<< STAT-DEFS [BumperHeights] >>> ***/

static asn_TYPE_member_t asn_MBR_BumperHeights_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BumperHeights, frnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BumperHeightFront,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "frnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BumperHeights, rear),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BumperHeightRear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rear"
		},
};
static ber_tlv_tag_t asn_DEF_BumperHeights_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_BumperHeights_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* frnt */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* rear */
};
static asn_SEQUENCE_specifics_t asn_SPC_BumperHeights_specs_1 = {
	sizeof(struct BumperHeights),
	offsetof(struct BumperHeights, _asn_ctx),
	asn_MAP_BumperHeights_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_BumperHeights = {
	"BumperHeights",
	"BumperHeights",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BumperHeights_tags_1,
	sizeof(asn_DEF_BumperHeights_tags_1)
		/sizeof(asn_DEF_BumperHeights_tags_1[0]), /* 1 */
	asn_DEF_BumperHeights_tags_1,	/* Same as above */
	sizeof(asn_DEF_BumperHeights_tags_1)
		/sizeof(asn_DEF_BumperHeights_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_BumperHeights_1,
	2,	/* Elements count */
	&asn_SPC_BumperHeights_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Circle] >>> ***/

#include "Position3D.h"
#include <NativeInteger.h>
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>

/*** <<< DEPS [Circle] >>> ***/

typedef enum raduis_PR {
	raduis_PR_NOTHING,	/* No components present */
	raduis_PR_radiusSteps,
	raduis_PR_miles,
	raduis_PR_km
} raduis_PR;

/*** <<< TYPE-DECLS [Circle] >>> ***/

typedef struct Circle {
	Position3D_t	 center;
	struct raduis {
		raduis_PR present;
		union Circle__raduis_u {
			long	 radiusSteps;
			long	 miles;
			long	 km;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} raduis;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Circle_t;

/*** <<< FUNC-DECLS [Circle] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Circle;

/*** <<< CODE [Circle] >>> ***/

static int
memb_radiusSteps_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_miles_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 2000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_km_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 5000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [Circle] >>> ***/

static asn_TYPE_member_t asn_MBR_raduis_3[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct raduis, choice.radiusSteps),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_radiusSteps_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "radiusSteps"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct raduis, choice.miles),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_miles_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "miles"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct raduis, choice.km),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_km_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "km"
		},
};
static asn_TYPE_tag2member_t asn_MAP_raduis_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* radiusSteps */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* miles */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* km */
};
static asn_CHOICE_specifics_t asn_SPC_raduis_specs_3 = {
	sizeof(struct raduis),
	offsetof(struct raduis, _asn_ctx),
	offsetof(struct raduis, present),
	sizeof(((struct raduis *)0)->present),
	asn_MAP_raduis_tag2el_3,
	3,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_raduis_3 = {
	"raduis",
	"raduis",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_raduis_3,
	3,	/* Elements count */
	&asn_SPC_raduis_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Circle_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Circle, center),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "center"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Circle, raduis),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_raduis_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "raduis"
		},
};
static ber_tlv_tag_t asn_DEF_Circle_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Circle_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* center */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* raduis */
};
static asn_SEQUENCE_specifics_t asn_SPC_Circle_specs_1 = {
	sizeof(struct Circle),
	offsetof(struct Circle, _asn_ctx),
	asn_MAP_Circle_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Circle = {
	"Circle",
	"Circle",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Circle_tags_1,
	sizeof(asn_DEF_Circle_tags_1)
		/sizeof(asn_DEF_Circle_tags_1[0]), /* 1 */
	asn_DEF_Circle_tags_1,	/* Same as above */
	sizeof(asn_DEF_Circle_tags_1)
		/sizeof(asn_DEF_Circle_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Circle_1,
	2,	/* Elements count */
	&asn_SPC_Circle_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ConfidenceSet] >>> ***/

#include "SpeedandHeadingandThrottleConfidence.h"
#include "TimeConfidence.h"
#include "PositionConfidenceSet.h"
#include "SteeringWheelAngleConfidence.h"
#include "ThrottleConfidence.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [ConfidenceSet] >>> ***/

struct AccelSteerYawRateConfidence;

/*** <<< TYPE-DECLS [ConfidenceSet] >>> ***/

typedef struct ConfidenceSet {
	struct AccelSteerYawRateConfidence	*accelConfidence	/* OPTIONAL */;
	SpeedandHeadingandThrottleConfidence_t	*speedConfidence	/* OPTIONAL */;
	TimeConfidence_t	*timeConfidence	/* OPTIONAL */;
	PositionConfidenceSet_t	*posConfidence	/* OPTIONAL */;
	SteeringWheelAngleConfidence_t	*steerConfidence	/* OPTIONAL */;
	ThrottleConfidence_t	*throttleConfidence	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ConfidenceSet_t;

/*** <<< FUNC-DECLS [ConfidenceSet] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ConfidenceSet;

/*** <<< POST-INCLUDE [ConfidenceSet] >>> ***/

#include "AccelSteerYawRateConfidence.h"

/*** <<< STAT-DEFS [ConfidenceSet] >>> ***/

static asn_TYPE_member_t asn_MBR_ConfidenceSet_1[] = {
	{ ATF_POINTER, 6, offsetof(struct ConfidenceSet, accelConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelSteerYawRateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "accelConfidence"
		},
	{ ATF_POINTER, 5, offsetof(struct ConfidenceSet, speedConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedandHeadingandThrottleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speedConfidence"
		},
	{ ATF_POINTER, 4, offsetof(struct ConfidenceSet, timeConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "timeConfidence"
		},
	{ ATF_POINTER, 3, offsetof(struct ConfidenceSet, posConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionConfidenceSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "posConfidence"
		},
	{ ATF_POINTER, 2, offsetof(struct ConfidenceSet, steerConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "steerConfidence"
		},
	{ ATF_POINTER, 1, offsetof(struct ConfidenceSet, throttleConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ThrottleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "throttleConfidence"
		},
};
static ber_tlv_tag_t asn_DEF_ConfidenceSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ConfidenceSet_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* accelConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* speedConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* timeConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* posConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* steerConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* throttleConfidence */
};
static asn_SEQUENCE_specifics_t asn_SPC_ConfidenceSet_specs_1 = {
	sizeof(struct ConfidenceSet),
	offsetof(struct ConfidenceSet, _asn_ctx),
	asn_MAP_ConfidenceSet_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ConfidenceSet = {
	"ConfidenceSet",
	"ConfidenceSet",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ConfidenceSet_tags_1,
	sizeof(asn_DEF_ConfidenceSet_tags_1)
		/sizeof(asn_DEF_ConfidenceSet_tags_1[0]), /* 1 */
	asn_DEF_ConfidenceSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_ConfidenceSet_tags_1)
		/sizeof(asn_DEF_ConfidenceSet_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ConfidenceSet_1,
	6,	/* Elements count */
	&asn_SPC_ConfidenceSet_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ConnectsTo] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [ConnectsTo] >>> ***/

typedef OCTET_STRING_t	 ConnectsTo_t;

/*** <<< FUNC-DECLS [ConnectsTo] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ConnectsTo;
asn_struct_free_f ConnectsTo_free;
asn_struct_print_f ConnectsTo_print;
asn_constr_check_f ConnectsTo_constraint;
ber_type_decoder_f ConnectsTo_decode_ber;
der_type_encoder_f ConnectsTo_encode_der;
xer_type_decoder_f ConnectsTo_decode_xer;
xer_type_encoder_f ConnectsTo_encode_xer;

/*** <<< CODE [ConnectsTo] >>> ***/

int
ConnectsTo_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 2 && size <= 32)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
ConnectsTo_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
ConnectsTo_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ConnectsTo_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ConnectsTo_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ConnectsTo_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ConnectsTo_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ConnectsTo_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ConnectsTo_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ConnectsTo_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ConnectsTo_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ConnectsTo_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ConnectsTo_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ConnectsTo_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ConnectsTo] >>> ***/

static ber_tlv_tag_t asn_DEF_ConnectsTo_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ConnectsTo = {
	"ConnectsTo",
	"ConnectsTo",
	ConnectsTo_free,
	ConnectsTo_print,
	ConnectsTo_constraint,
	ConnectsTo_decode_ber,
	ConnectsTo_encode_der,
	ConnectsTo_decode_xer,
	ConnectsTo_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ConnectsTo_tags_1,
	sizeof(asn_DEF_ConnectsTo_tags_1)
		/sizeof(asn_DEF_ConnectsTo_tags_1[0]), /* 1 */
	asn_DEF_ConnectsTo_tags_1,	/* Same as above */
	sizeof(asn_DEF_ConnectsTo_tags_1)
		/sizeof(asn_DEF_ConnectsTo_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [CrosswalkLane] >>> ***/

#include "LaneNumber.h"
#include "LaneWidth.h"
#include "CrosswalkLaneAttributes.h"
#include "NodeList.h"
#include "ConnectsTo.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [CrosswalkLane] >>> ***/

struct NodeList;

/*** <<< TYPE-DECLS [CrosswalkLane] >>> ***/

typedef struct CrosswalkLane {
	LaneNumber_t	 laneNumber;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	CrosswalkLaneAttributes_t	 laneAttributes;
	NodeList_t	 nodeList;
	struct NodeList	*keepOutList	/* OPTIONAL */;
	ConnectsTo_t	*connectsTo	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} CrosswalkLane_t;

/*** <<< FUNC-DECLS [CrosswalkLane] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_CrosswalkLane;

/*** <<< POST-INCLUDE [CrosswalkLane] >>> ***/

#include "NodeList.h"

/*** <<< STAT-DEFS [CrosswalkLane] >>> ***/

static asn_TYPE_member_t asn_MBR_CrosswalkLane_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CrosswalkLane, laneNumber),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneNumber"
		},
	{ ATF_POINTER, 1, offsetof(struct CrosswalkLane, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CrosswalkLane, laneAttributes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CrosswalkLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneAttributes"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CrosswalkLane, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
	{ ATF_POINTER, 2, offsetof(struct CrosswalkLane, keepOutList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "keepOutList"
		},
	{ ATF_POINTER, 1, offsetof(struct CrosswalkLane, connectsTo),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConnectsTo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "connectsTo"
		},
};
static ber_tlv_tag_t asn_DEF_CrosswalkLane_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_CrosswalkLane_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* laneNumber */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* laneAttributes */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* nodeList */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* keepOutList */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* connectsTo */
};
static asn_SEQUENCE_specifics_t asn_SPC_CrosswalkLane_specs_1 = {
	sizeof(struct CrosswalkLane),
	offsetof(struct CrosswalkLane, _asn_ctx),
	asn_MAP_CrosswalkLane_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_CrosswalkLane = {
	"CrosswalkLane",
	"CrosswalkLane",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CrosswalkLane_tags_1,
	sizeof(asn_DEF_CrosswalkLane_tags_1)
		/sizeof(asn_DEF_CrosswalkLane_tags_1[0]), /* 1 */
	asn_DEF_CrosswalkLane_tags_1,	/* Same as above */
	sizeof(asn_DEF_CrosswalkLane_tags_1)
		/sizeof(asn_DEF_CrosswalkLane_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_CrosswalkLane_1,
	6,	/* Elements count */
	&asn_SPC_CrosswalkLane_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DataParameters] >>> ***/

#include <IA5String.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DataParameters] >>> ***/

typedef struct DataParameters {
	IA5String_t	*processMethod	/* OPTIONAL */;
	IA5String_t	*processAgency	/* OPTIONAL */;
	IA5String_t	*lastCheckedDate	/* OPTIONAL */;
	IA5String_t	*geiodUsed	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DataParameters_t;

/*** <<< FUNC-DECLS [DataParameters] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DataParameters;

/*** <<< CTABLES [DataParameters] >>> ***/

static int check_permitted_alphabet_2(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_3(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_4(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_5(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [DataParameters] >>> ***/

static int
memb_processMethod_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 255)
		 && !check_permitted_alphabet_2(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_processAgency_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 255)
		 && !check_permitted_alphabet_3(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_lastCheckedDate_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 255)
		 && !check_permitted_alphabet_4(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_geiodUsed_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 255)
		 && !check_permitted_alphabet_5(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [DataParameters] >>> ***/

static asn_TYPE_member_t asn_MBR_DataParameters_1[] = {
	{ ATF_POINTER, 4, offsetof(struct DataParameters, processMethod),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_processMethod_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "processMethod"
		},
	{ ATF_POINTER, 3, offsetof(struct DataParameters, processAgency),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_processAgency_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "processAgency"
		},
	{ ATF_POINTER, 2, offsetof(struct DataParameters, lastCheckedDate),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_lastCheckedDate_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lastCheckedDate"
		},
	{ ATF_POINTER, 1, offsetof(struct DataParameters, geiodUsed),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_geiodUsed_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "geiodUsed"
		},
};
static ber_tlv_tag_t asn_DEF_DataParameters_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DataParameters_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* processMethod */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* processAgency */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* lastCheckedDate */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* geiodUsed */
};
static asn_SEQUENCE_specifics_t asn_SPC_DataParameters_specs_1 = {
	sizeof(struct DataParameters),
	offsetof(struct DataParameters, _asn_ctx),
	asn_MAP_DataParameters_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DataParameters = {
	"DataParameters",
	"DataParameters",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DataParameters_tags_1,
	sizeof(asn_DEF_DataParameters_tags_1)
		/sizeof(asn_DEF_DataParameters_tags_1[0]), /* 1 */
	asn_DEF_DataParameters_tags_1,	/* Same as above */
	sizeof(asn_DEF_DataParameters_tags_1)
		/sizeof(asn_DEF_DataParameters_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DataParameters_1,
	4,	/* Elements count */
	&asn_SPC_DataParameters_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DDate] >>> ***/

#include "DYear.h"
#include "DMonth.h"
#include "DDay.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DDate] >>> ***/

typedef struct DDate {
	DYear_t	 year;
	DMonth_t	 month;
	DDay_t	 day;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DDate_t;

/*** <<< FUNC-DECLS [DDate] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DDate;

/*** <<< STAT-DEFS [DDate] >>> ***/

static asn_TYPE_member_t asn_MBR_DDate_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct DDate, year),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "year"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DDate, month),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "month"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DDate, day),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDay,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "day"
		},
};
static ber_tlv_tag_t asn_DEF_DDate_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DDate_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* year */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* month */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* day */
};
static asn_SEQUENCE_specifics_t asn_SPC_DDate_specs_1 = {
	sizeof(struct DDate),
	offsetof(struct DDate, _asn_ctx),
	asn_MAP_DDate_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DDate = {
	"DDate",
	"DDate",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DDate_tags_1,
	sizeof(asn_DEF_DDate_tags_1)
		/sizeof(asn_DEF_DDate_tags_1[0]), /* 1 */
	asn_DEF_DDate_tags_1,	/* Same as above */
	sizeof(asn_DEF_DDate_tags_1)
		/sizeof(asn_DEF_DDate_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DDate_1,
	3,	/* Elements count */
	&asn_SPC_DDate_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DDateTime] >>> ***/

#include "DYear.h"
#include "DMonth.h"
#include "DDay.h"
#include "DHour.h"
#include "DMinute.h"
#include "DSecond.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DDateTime] >>> ***/

typedef struct DDateTime {
	DYear_t	*year	/* OPTIONAL */;
	DMonth_t	*month	/* OPTIONAL */;
	DDay_t	*day	/* OPTIONAL */;
	DHour_t	*hour	/* OPTIONAL */;
	DMinute_t	*minute	/* OPTIONAL */;
	DSecond_t	*second	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DDateTime_t;

/*** <<< FUNC-DECLS [DDateTime] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DDateTime;

/*** <<< STAT-DEFS [DDateTime] >>> ***/

static asn_TYPE_member_t asn_MBR_DDateTime_1[] = {
	{ ATF_POINTER, 6, offsetof(struct DDateTime, year),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "year"
		},
	{ ATF_POINTER, 5, offsetof(struct DDateTime, month),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "month"
		},
	{ ATF_POINTER, 4, offsetof(struct DDateTime, day),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDay,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "day"
		},
	{ ATF_POINTER, 3, offsetof(struct DDateTime, hour),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DHour,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "hour"
		},
	{ ATF_POINTER, 2, offsetof(struct DDateTime, minute),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMinute,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "minute"
		},
	{ ATF_POINTER, 1, offsetof(struct DDateTime, second),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSecond,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "second"
		},
};
static ber_tlv_tag_t asn_DEF_DDateTime_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DDateTime_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* year */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* month */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* day */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* hour */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* minute */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* second */
};
static asn_SEQUENCE_specifics_t asn_SPC_DDateTime_specs_1 = {
	sizeof(struct DDateTime),
	offsetof(struct DDateTime, _asn_ctx),
	asn_MAP_DDateTime_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DDateTime = {
	"DDateTime",
	"DDateTime",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DDateTime_tags_1,
	sizeof(asn_DEF_DDateTime_tags_1)
		/sizeof(asn_DEF_DDateTime_tags_1[0]), /* 1 */
	asn_DEF_DDateTime_tags_1,	/* Same as above */
	sizeof(asn_DEF_DDateTime_tags_1)
		/sizeof(asn_DEF_DDateTime_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DDateTime_1,
	6,	/* Elements count */
	&asn_SPC_DDateTime_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DFullTime] >>> ***/

#include "DYear.h"
#include "DMonth.h"
#include "DDay.h"
#include "DHour.h"
#include "DMinute.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DFullTime] >>> ***/

typedef struct DFullTime {
	DYear_t	 year;
	DMonth_t	 month;
	DDay_t	 day;
	DHour_t	 hour;
	DMinute_t	 minute;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DFullTime_t;

/*** <<< FUNC-DECLS [DFullTime] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DFullTime;

/*** <<< STAT-DEFS [DFullTime] >>> ***/

static asn_TYPE_member_t asn_MBR_DFullTime_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct DFullTime, year),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "year"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DFullTime, month),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "month"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DFullTime, day),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDay,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "day"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DFullTime, hour),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DHour,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "hour"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DFullTime, minute),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMinute,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "minute"
		},
};
static ber_tlv_tag_t asn_DEF_DFullTime_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DFullTime_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* year */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* month */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* day */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* hour */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* minute */
};
static asn_SEQUENCE_specifics_t asn_SPC_DFullTime_specs_1 = {
	sizeof(struct DFullTime),
	offsetof(struct DFullTime, _asn_ctx),
	asn_MAP_DFullTime_tag2el_1,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DFullTime = {
	"DFullTime",
	"DFullTime",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DFullTime_tags_1,
	sizeof(asn_DEF_DFullTime_tags_1)
		/sizeof(asn_DEF_DFullTime_tags_1[0]), /* 1 */
	asn_DEF_DFullTime_tags_1,	/* Same as above */
	sizeof(asn_DEF_DFullTime_tags_1)
		/sizeof(asn_DEF_DFullTime_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DFullTime_1,
	5,	/* Elements count */
	&asn_SPC_DFullTime_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DMonthDay] >>> ***/

#include "DMonth.h"
#include "DDay.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DMonthDay] >>> ***/

typedef struct DMonthDay {
	DMonth_t	 month;
	DDay_t	 day;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DMonthDay_t;

/*** <<< FUNC-DECLS [DMonthDay] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DMonthDay;

/*** <<< STAT-DEFS [DMonthDay] >>> ***/

static asn_TYPE_member_t asn_MBR_DMonthDay_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct DMonthDay, month),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "month"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DMonthDay, day),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDay,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "day"
		},
};
static ber_tlv_tag_t asn_DEF_DMonthDay_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DMonthDay_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* month */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* day */
};
static asn_SEQUENCE_specifics_t asn_SPC_DMonthDay_specs_1 = {
	sizeof(struct DMonthDay),
	offsetof(struct DMonthDay, _asn_ctx),
	asn_MAP_DMonthDay_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DMonthDay = {
	"DMonthDay",
	"DMonthDay",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DMonthDay_tags_1,
	sizeof(asn_DEF_DMonthDay_tags_1)
		/sizeof(asn_DEF_DMonthDay_tags_1[0]), /* 1 */
	asn_DEF_DMonthDay_tags_1,	/* Same as above */
	sizeof(asn_DEF_DMonthDay_tags_1)
		/sizeof(asn_DEF_DMonthDay_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DMonthDay_1,
	2,	/* Elements count */
	&asn_SPC_DMonthDay_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DTime] >>> ***/

#include "DHour.h"
#include "DMinute.h"
#include "DSecond.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DTime] >>> ***/

typedef struct DTime {
	DHour_t	 hour;
	DMinute_t	 minute;
	DSecond_t	 second;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DTime_t;

/*** <<< FUNC-DECLS [DTime] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DTime;

/*** <<< STAT-DEFS [DTime] >>> ***/

static asn_TYPE_member_t asn_MBR_DTime_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct DTime, hour),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DHour,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "hour"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DTime, minute),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMinute,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "minute"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DTime, second),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DSecond,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "second"
		},
};
static ber_tlv_tag_t asn_DEF_DTime_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DTime_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* hour */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* minute */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* second */
};
static asn_SEQUENCE_specifics_t asn_SPC_DTime_specs_1 = {
	sizeof(struct DTime),
	offsetof(struct DTime, _asn_ctx),
	asn_MAP_DTime_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DTime = {
	"DTime",
	"DTime",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DTime_tags_1,
	sizeof(asn_DEF_DTime_tags_1)
		/sizeof(asn_DEF_DTime_tags_1[0]), /* 1 */
	asn_DEF_DTime_tags_1,	/* Same as above */
	sizeof(asn_DEF_DTime_tags_1)
		/sizeof(asn_DEF_DTime_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DTime_1,
	3,	/* Elements count */
	&asn_SPC_DTime_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DYearMonth] >>> ***/

#include "DYear.h"
#include "DMonth.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [DYearMonth] >>> ***/

typedef struct DYearMonth {
	DYear_t	 year;
	DMonth_t	 month;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} DYearMonth_t;

/*** <<< FUNC-DECLS [DYearMonth] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DYearMonth;

/*** <<< STAT-DEFS [DYearMonth] >>> ***/

static asn_TYPE_member_t asn_MBR_DYearMonth_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct DYearMonth, year),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DYear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "year"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct DYearMonth, month),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DMonth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "month"
		},
};
static ber_tlv_tag_t asn_DEF_DYearMonth_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_DYearMonth_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* year */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* month */
};
static asn_SEQUENCE_specifics_t asn_SPC_DYearMonth_specs_1 = {
	sizeof(struct DYearMonth),
	offsetof(struct DYearMonth, _asn_ctx),
	asn_MAP_DYearMonth_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_DYearMonth = {
	"DYearMonth",
	"DYearMonth",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DYearMonth_tags_1,
	sizeof(asn_DEF_DYearMonth_tags_1)
		/sizeof(asn_DEF_DYearMonth_tags_1[0]), /* 1 */
	asn_DEF_DYearMonth_tags_1,	/* Same as above */
	sizeof(asn_DEF_DYearMonth_tags_1)
		/sizeof(asn_DEF_DYearMonth_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_DYearMonth_1,
	2,	/* Elements count */
	&asn_SPC_DYearMonth_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ExitService] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include "ITIScodes.h"
#include <IA5String.h>
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< DEPS [ExitService] >>> ***/

typedef enum item_PR {
	item_PR_NOTHING,	/* No components present */
	item_PR_itis,
	item_PR_text
} item_PR;

/*** <<< TYPE-DECLS [ExitService] >>> ***/

typedef struct ExitService {
	A_SEQUENCE_OF(struct Member {
		struct item {
			item_PR present;
			union item_u {
				ITIScodes_t	 itis;
				IA5String_t	 text;
			} choice;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} item;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ExitService_t;

/*** <<< FUNC-DECLS [ExitService] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ExitService;

/*** <<< CTABLES [ExitService] >>> ***/

static int check_permitted_alphabet_5(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [ExitService] >>> ***/

static int
memb_text_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 16)
		 && !check_permitted_alphabet_5(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [ExitService] >>> ***/

static asn_TYPE_member_t asn_MBR_item_3[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.itis),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "itis"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.text),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_text_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "text"
		},
};
static asn_TYPE_tag2member_t asn_MAP_item_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* itis */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* text */
};
static asn_CHOICE_specifics_t asn_SPC_item_specs_3 = {
	sizeof(struct item),
	offsetof(struct item, _asn_ctx),
	offsetof(struct item, present),
	sizeof(((struct item *)0)->present),
	asn_MAP_item_tag2el_3,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_item_3 = {
	"item",
	"item",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_item_3,
	2,	/* Elements count */
	&asn_SPC_item_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, item),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_item_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* item */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_2 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_2,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_2,
	1,	/* Elements count */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_ExitService_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_ExitService_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_ExitService_specs_1 = {
	sizeof(struct ExitService),
	offsetof(struct ExitService, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_ExitService = {
	"ExitService",
	"ExitService",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ExitService_tags_1,
	sizeof(asn_DEF_ExitService_tags_1)
		/sizeof(asn_DEF_ExitService_tags_1[0]), /* 1 */
	asn_DEF_ExitService_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExitService_tags_1)
		/sizeof(asn_DEF_ExitService_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ExitService_1,
	1,	/* Single element */
	&asn_SPC_ExitService_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [FullPositionVector] >>> ***/

#include "Longitude.h"
#include "Latitude.h"
#include "Elevation.h"
#include "Heading.h"
#include "TransmissionAndSpeed.h"
#include "PositionalAccuracy.h"
#include "TimeConfidence.h"
#include "PositionConfidenceSet.h"
#include "SpeedandHeadingandThrottleConfidence.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [FullPositionVector] >>> ***/

struct DDateTime;

/*** <<< TYPE-DECLS [FullPositionVector] >>> ***/

typedef struct FullPositionVector {
	struct DDateTime	*utcTime	/* OPTIONAL */;
	Longitude_t	 Long;
	Latitude_t	 lat;
	Elevation_t	*elevation	/* OPTIONAL */;
	Heading_t	*heading	/* OPTIONAL */;
	TransmissionAndSpeed_t	*speed	/* OPTIONAL */;
	PositionalAccuracy_t	*posAccuracy	/* OPTIONAL */;
	TimeConfidence_t	*timeConfidence	/* OPTIONAL */;
	PositionConfidenceSet_t	*posConfidence	/* OPTIONAL */;
	SpeedandHeadingandThrottleConfidence_t	*speedConfidence	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} FullPositionVector_t;

/*** <<< FUNC-DECLS [FullPositionVector] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_FullPositionVector;

/*** <<< POST-INCLUDE [FullPositionVector] >>> ***/

#include "DDateTime.h"

/*** <<< STAT-DEFS [FullPositionVector] >>> ***/

static asn_TYPE_member_t asn_MBR_FullPositionVector_1[] = {
	{ ATF_POINTER, 1, offsetof(struct FullPositionVector, utcTime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDateTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "utcTime"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct FullPositionVector, Long),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Longitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "long"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct FullPositionVector, lat),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Latitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lat"
		},
	{ ATF_POINTER, 7, offsetof(struct FullPositionVector, elevation),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Elevation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "elevation"
		},
	{ ATF_POINTER, 6, offsetof(struct FullPositionVector, heading),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Heading,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "heading"
		},
	{ ATF_POINTER, 5, offsetof(struct FullPositionVector, speed),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransmissionAndSpeed,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speed"
		},
	{ ATF_POINTER, 4, offsetof(struct FullPositionVector, posAccuracy),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionalAccuracy,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "posAccuracy"
		},
	{ ATF_POINTER, 3, offsetof(struct FullPositionVector, timeConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "timeConfidence"
		},
	{ ATF_POINTER, 2, offsetof(struct FullPositionVector, posConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionConfidenceSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "posConfidence"
		},
	{ ATF_POINTER, 1, offsetof(struct FullPositionVector, speedConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedandHeadingandThrottleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speedConfidence"
		},
};
static ber_tlv_tag_t asn_DEF_FullPositionVector_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_FullPositionVector_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* utcTime */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* long */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* lat */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* elevation */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* heading */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* speed */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* posAccuracy */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* timeConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* posConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 } /* speedConfidence */
};
static asn_SEQUENCE_specifics_t asn_SPC_FullPositionVector_specs_1 = {
	sizeof(struct FullPositionVector),
	offsetof(struct FullPositionVector, _asn_ctx),
	asn_MAP_FullPositionVector_tag2el_1,
	10,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	9,	/* Start extensions */
	11	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_FullPositionVector = {
	"FullPositionVector",
	"FullPositionVector",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_FullPositionVector_tags_1,
	sizeof(asn_DEF_FullPositionVector_tags_1)
		/sizeof(asn_DEF_FullPositionVector_tags_1[0]), /* 1 */
	asn_DEF_FullPositionVector_tags_1,	/* Same as above */
	sizeof(asn_DEF_FullPositionVector_tags_1)
		/sizeof(asn_DEF_FullPositionVector_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_FullPositionVector_1,
	10,	/* Elements count */
	&asn_SPC_FullPositionVector_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [GenericSignage] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include "ITIScodes.h"
#include <IA5String.h>
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< DEPS [GenericSignage] >>> ***/

typedef enum item_PR {
	item_PR_NOTHING,	/* No components present */
	item_PR_itis,
	item_PR_text
} item_PR;

/*** <<< TYPE-DECLS [GenericSignage] >>> ***/

typedef struct GenericSignage {
	A_SEQUENCE_OF(struct Member {
		struct item {
			item_PR present;
			union item_u {
				ITIScodes_t	 itis;
				IA5String_t	 text;
			} choice;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} item;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} GenericSignage_t;

/*** <<< FUNC-DECLS [GenericSignage] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_GenericSignage;

/*** <<< CTABLES [GenericSignage] >>> ***/

static int check_permitted_alphabet_5(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [GenericSignage] >>> ***/

static int
memb_text_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 16)
		 && !check_permitted_alphabet_5(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [GenericSignage] >>> ***/

static asn_TYPE_member_t asn_MBR_item_3[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.itis),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "itis"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.text),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_text_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "text"
		},
};
static asn_TYPE_tag2member_t asn_MAP_item_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* itis */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* text */
};
static asn_CHOICE_specifics_t asn_SPC_item_specs_3 = {
	sizeof(struct item),
	offsetof(struct item, _asn_ctx),
	offsetof(struct item, present),
	sizeof(((struct item *)0)->present),
	asn_MAP_item_tag2el_3,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_item_3 = {
	"item",
	"item",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_item_3,
	2,	/* Elements count */
	&asn_SPC_item_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, item),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_item_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* item */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_2 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_2,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_2,
	1,	/* Elements count */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_GenericSignage_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_GenericSignage_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_GenericSignage_specs_1 = {
	sizeof(struct GenericSignage),
	offsetof(struct GenericSignage, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_GenericSignage = {
	"GenericSignage",
	"GenericSignage",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_GenericSignage_tags_1,
	sizeof(asn_DEF_GenericSignage_tags_1)
		/sizeof(asn_DEF_GenericSignage_tags_1[0]), /* 1 */
	asn_DEF_GenericSignage_tags_1,	/* Same as above */
	sizeof(asn_DEF_GenericSignage_tags_1)
		/sizeof(asn_DEF_GenericSignage_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_GenericSignage_1,
	1,	/* Single element */
	&asn_SPC_GenericSignage_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Intersection] >>> ***/

#include "DescriptiveName.h"
#include "IntersectionID.h"
#include "Heading.h"
#include "LaneWidth.h"
#include "IntersectionStatusObject.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Intersection] >>> ***/

struct Position3D;
struct ApproachObject;
struct SignalControlZone;

/*** <<< TYPE-DECLS [Intersection] >>> ***/

typedef struct Intersection {
	DescriptiveName_t	*name	/* OPTIONAL */;
	IntersectionID_t	 id;
	struct Position3D	*refPoint	/* OPTIONAL */;
	IntersectionID_t	*refInterNum	/* OPTIONAL */;
	Heading_t	*orientation	/* OPTIONAL */;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	IntersectionStatusObject_t	*type	/* OPTIONAL */;
	struct approaches {
		A_SEQUENCE_OF(struct ApproachObject) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} approaches;
	struct preemptZones {
		A_SEQUENCE_OF(struct SignalControlZone) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *preemptZones;
	struct priorityZones {
		A_SEQUENCE_OF(struct SignalControlZone) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *priorityZones;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Intersection_t;

/*** <<< FUNC-DECLS [Intersection] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Intersection;

/*** <<< POST-INCLUDE [Intersection] >>> ***/

#include "Position3D.h"
#include "ApproachObject.h"
#include "SignalControlZone.h"

/*** <<< CODE [Intersection] >>> ***/

static int
memb_approaches_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_preemptZones_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_priorityZones_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [Intersection] >>> ***/

static asn_TYPE_member_t asn_MBR_approaches_9[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_ApproachObject,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_approaches_tags_9[] = {
	(ASN_TAG_CLASS_CONTEXT | (7 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_approaches_specs_9 = {
	sizeof(struct approaches),
	offsetof(struct approaches, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_approaches_9 = {
	"approaches",
	"approaches",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_approaches_tags_9,
	sizeof(asn_DEF_approaches_tags_9)
		/sizeof(asn_DEF_approaches_tags_9[0]) - 1, /* 1 */
	asn_DEF_approaches_tags_9,	/* Same as above */
	sizeof(asn_DEF_approaches_tags_9)
		/sizeof(asn_DEF_approaches_tags_9[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_approaches_9,
	1,	/* Single element */
	&asn_SPC_approaches_specs_9	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_preemptZones_11[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_SignalControlZone,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_preemptZones_tags_11[] = {
	(ASN_TAG_CLASS_CONTEXT | (8 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_preemptZones_specs_11 = {
	sizeof(struct preemptZones),
	offsetof(struct preemptZones, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_preemptZones_11 = {
	"preemptZones",
	"preemptZones",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_preemptZones_tags_11,
	sizeof(asn_DEF_preemptZones_tags_11)
		/sizeof(asn_DEF_preemptZones_tags_11[0]) - 1, /* 1 */
	asn_DEF_preemptZones_tags_11,	/* Same as above */
	sizeof(asn_DEF_preemptZones_tags_11)
		/sizeof(asn_DEF_preemptZones_tags_11[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_preemptZones_11,
	1,	/* Single element */
	&asn_SPC_preemptZones_specs_11	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_priorityZones_13[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_SignalControlZone,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_priorityZones_tags_13[] = {
	(ASN_TAG_CLASS_CONTEXT | (9 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_priorityZones_specs_13 = {
	sizeof(struct priorityZones),
	offsetof(struct priorityZones, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_priorityZones_13 = {
	"priorityZones",
	"priorityZones",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_priorityZones_tags_13,
	sizeof(asn_DEF_priorityZones_tags_13)
		/sizeof(asn_DEF_priorityZones_tags_13[0]) - 1, /* 1 */
	asn_DEF_priorityZones_tags_13,	/* Same as above */
	sizeof(asn_DEF_priorityZones_tags_13)
		/sizeof(asn_DEF_priorityZones_tags_13[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_priorityZones_13,
	1,	/* Single element */
	&asn_SPC_priorityZones_specs_13	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Intersection_1[] = {
	{ ATF_POINTER, 1, offsetof(struct Intersection, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Intersection, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_POINTER, 5, offsetof(struct Intersection, refPoint),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "refPoint"
		},
	{ ATF_POINTER, 4, offsetof(struct Intersection, refInterNum),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "refInterNum"
		},
	{ ATF_POINTER, 3, offsetof(struct Intersection, orientation),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Heading,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "orientation"
		},
	{ ATF_POINTER, 2, offsetof(struct Intersection, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_POINTER, 1, offsetof(struct Intersection, type),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionStatusObject,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "type"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Intersection, approaches),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_approaches_9,
		.memb_constraints = memb_approaches_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "approaches"
		},
	{ ATF_POINTER, 2, offsetof(struct Intersection, preemptZones),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_preemptZones_11,
		.memb_constraints = memb_preemptZones_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "preemptZones"
		},
	{ ATF_POINTER, 1, offsetof(struct Intersection, priorityZones),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_priorityZones_13,
		.memb_constraints = memb_priorityZones_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "priorityZones"
		},
};
static ber_tlv_tag_t asn_DEF_Intersection_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Intersection_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* refPoint */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* refInterNum */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* orientation */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* type */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* approaches */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* preemptZones */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 } /* priorityZones */
};
static asn_SEQUENCE_specifics_t asn_SPC_Intersection_specs_1 = {
	sizeof(struct Intersection),
	offsetof(struct Intersection, _asn_ctx),
	asn_MAP_Intersection_tag2el_1,
	10,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	9,	/* Start extensions */
	11	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Intersection = {
	"Intersection",
	"Intersection",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Intersection_tags_1,
	sizeof(asn_DEF_Intersection_tags_1)
		/sizeof(asn_DEF_Intersection_tags_1[0]), /* 1 */
	asn_DEF_Intersection_tags_1,	/* Same as above */
	sizeof(asn_DEF_Intersection_tags_1)
		/sizeof(asn_DEF_Intersection_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Intersection_1,
	10,	/* Elements count */
	&asn_SPC_Intersection_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [IntersectionState] >>> ***/

#include "DescriptiveName.h"
#include "IntersectionID.h"
#include "IntersectionStatusObject.h"
#include "TimeMark.h"
#include <NativeInteger.h>
#include "SignalState.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [IntersectionState] >>> ***/

struct MovementState;

/*** <<< TYPE-DECLS [IntersectionState] >>> ***/

typedef struct IntersectionState {
	DescriptiveName_t	*name	/* OPTIONAL */;
	IntersectionID_t	 id;
	IntersectionStatusObject_t	 status;
	TimeMark_t	*timeStamp	/* OPTIONAL */;
	long	*lanesCnt	/* OPTIONAL */;
	struct states {
		A_SEQUENCE_OF(struct MovementState) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} states;
	SignalState_t	*priority	/* OPTIONAL */;
	SignalState_t	*preempt	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} IntersectionState_t;

/*** <<< FUNC-DECLS [IntersectionState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_IntersectionState;

/*** <<< POST-INCLUDE [IntersectionState] >>> ***/

#include "MovementState.h"

/*** <<< CODE [IntersectionState] >>> ***/

static int
memb_lanesCnt_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_states_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 255)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [IntersectionState] >>> ***/

static asn_TYPE_member_t asn_MBR_states_7[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_MovementState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_states_tags_7[] = {
	(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_states_specs_7 = {
	sizeof(struct states),
	offsetof(struct states, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_states_7 = {
	"states",
	"states",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_states_tags_7,
	sizeof(asn_DEF_states_tags_7)
		/sizeof(asn_DEF_states_tags_7[0]) - 1, /* 1 */
	asn_DEF_states_tags_7,	/* Same as above */
	sizeof(asn_DEF_states_tags_7)
		/sizeof(asn_DEF_states_tags_7[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_states_7,
	1,	/* Single element */
	&asn_SPC_states_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_IntersectionState_1[] = {
	{ ATF_POINTER, 1, offsetof(struct IntersectionState, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionState, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionState, status),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionStatusObject,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "status"
		},
	{ ATF_POINTER, 2, offsetof(struct IntersectionState, timeStamp),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeMark,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "timeStamp"
		},
	{ ATF_POINTER, 1, offsetof(struct IntersectionState, lanesCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_lanesCnt_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lanesCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IntersectionState, states),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_states_7,
		.memb_constraints = memb_states_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "states"
		},
	{ ATF_POINTER, 2, offsetof(struct IntersectionState, priority),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "priority"
		},
	{ ATF_POINTER, 1, offsetof(struct IntersectionState, preempt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "preempt"
		},
};
static ber_tlv_tag_t asn_DEF_IntersectionState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_IntersectionState_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* status */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* timeStamp */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* lanesCnt */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* states */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* priority */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 } /* preempt */
};
static asn_SEQUENCE_specifics_t asn_SPC_IntersectionState_specs_1 = {
	sizeof(struct IntersectionState),
	offsetof(struct IntersectionState, _asn_ctx),
	asn_MAP_IntersectionState_tag2el_1,
	8,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	7,	/* Start extensions */
	9	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_IntersectionState = {
	"IntersectionState",
	"IntersectionState",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_IntersectionState_tags_1,
	sizeof(asn_DEF_IntersectionState_tags_1)
		/sizeof(asn_DEF_IntersectionState_tags_1[0]), /* 1 */
	asn_DEF_IntersectionState_tags_1,	/* Same as above */
	sizeof(asn_DEF_IntersectionState_tags_1)
		/sizeof(asn_DEF_IntersectionState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_IntersectionState_1,
	8,	/* Elements count */
	&asn_SPC_IntersectionState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [J1939data] >>> ***/

#include "TrailerWeight.h"
#include "CargoWeight.h"
#include "SteeringAxleTemperature.h"
#include "DriveAxleLocation.h"
#include "DriveAxleLiftAirPressure.h"
#include "DriveAxleTemperature.h"
#include "DriveAxleLubePressure.h"
#include "SteeringAxleLubePressure.h"
#include <asn_SEQUENCE_OF.h>
#include "TireLocation.h"
#include "TirePressure.h"
#include "TireTemp.h"
#include "WheelSensorStatus.h"
#include "WheelEndElectFault.h"
#include "TireLeakageRate.h"
#include "TirePressureThresholdDetection.h"
#include <constr_SEQUENCE.h>
#include <constr_SEQUENCE_OF.h>
#include "AxleLocation.h"
#include "AxleWeight.h"

/*** <<< TYPE-DECLS [J1939data] >>> ***/

typedef struct J1939data {
	struct tires {
		A_SEQUENCE_OF(struct Member {
			TireLocation_t	*location	/* OPTIONAL */;
			TirePressure_t	*pressure	/* OPTIONAL */;
			TireTemp_t	*temp	/* OPTIONAL */;
			WheelSensorStatus_t	*wheelSensorStatus	/* OPTIONAL */;
			WheelEndElectFault_t	*wheelEndElectFault	/* OPTIONAL */;
			TireLeakageRate_t	*leakageRate	/* OPTIONAL */;
			TirePressureThresholdDetection_t	*detection	/* OPTIONAL */;
			/*
			 * This type is extensible,
			 * possible extensions are below.
			 */
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} ) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *tires;
	struct axle {
		A_SEQUENCE_OF(struct Member {
			AxleLocation_t	*location	/* OPTIONAL */;
			AxleWeight_t	*weight	/* OPTIONAL */;
			/*
			 * This type is extensible,
			 * possible extensions are below.
			 */
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} ) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *axle;
	TrailerWeight_t	*trailerWeight	/* OPTIONAL */;
	CargoWeight_t	*cargoWeight	/* OPTIONAL */;
	SteeringAxleTemperature_t	*steeringAxleTemperature	/* OPTIONAL */;
	DriveAxleLocation_t	*driveAxleLocation	/* OPTIONAL */;
	DriveAxleLiftAirPressure_t	*driveAxleLiftAirPressure	/* OPTIONAL */;
	DriveAxleTemperature_t	*driveAxleTemperature	/* OPTIONAL */;
	DriveAxleLubePressure_t	*driveAxleLubePressure	/* OPTIONAL */;
	SteeringAxleLubePressure_t	*steeringAxleLubePressure	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} J1939data_t;

/*** <<< FUNC-DECLS [J1939data] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_J1939data;

/*** <<< CODE [J1939data] >>> ***/

static int
memb_tires_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 16)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_axle_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size <= 16)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [J1939data] >>> ***/

static asn_TYPE_member_t asn_MBR_Member_3[] = {
	{ ATF_POINTER, 7, offsetof(struct Member, location),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TireLocation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "location"
		},
	{ ATF_POINTER, 6, offsetof(struct Member, pressure),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TirePressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pressure"
		},
	{ ATF_POINTER, 5, offsetof(struct Member, temp),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TireTemp,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "temp"
		},
	{ ATF_POINTER, 4, offsetof(struct Member, wheelSensorStatus),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WheelSensorStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "wheelSensorStatus"
		},
	{ ATF_POINTER, 3, offsetof(struct Member, wheelEndElectFault),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WheelEndElectFault,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "wheelEndElectFault"
		},
	{ ATF_POINTER, 2, offsetof(struct Member, leakageRate),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TireLeakageRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "leakageRate"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, detection),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TirePressureThresholdDetection,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "detection"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_3[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* location */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* pressure */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* temp */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* wheelSensorStatus */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* wheelEndElectFault */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* leakageRate */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 } /* detection */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_3 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_3,
	7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	6,	/* Start extensions */
	8	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_3 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_3,
	sizeof(asn_DEF_Member_tags_3)
		/sizeof(asn_DEF_Member_tags_3[0]), /* 1 */
	asn_DEF_Member_tags_3,	/* Same as above */
	sizeof(asn_DEF_Member_tags_3)
		/sizeof(asn_DEF_Member_tags_3[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_3,
	7,	/* Elements count */
	&asn_SPC_Member_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_tires_2[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_tires_tags_2[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_tires_specs_2 = {
	sizeof(struct tires),
	offsetof(struct tires, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_tires_2 = {
	"tires",
	"tires",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_tires_tags_2,
	sizeof(asn_DEF_tires_tags_2)
		/sizeof(asn_DEF_tires_tags_2[0]) - 1, /* 1 */
	asn_DEF_tires_tags_2,	/* Same as above */
	sizeof(asn_DEF_tires_tags_2)
		/sizeof(asn_DEF_tires_tags_2[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_tires_2,
	1,	/* Single element */
	&asn_SPC_tires_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_13[] = {
	{ ATF_POINTER, 2, offsetof(struct Member, location),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AxleLocation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "location"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, weight),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AxleWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "weight"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_13[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_13[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* location */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* weight */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_13 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_13,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	1,	/* Start extensions */
	3	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_13 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_13,
	sizeof(asn_DEF_Member_tags_13)
		/sizeof(asn_DEF_Member_tags_13[0]), /* 1 */
	asn_DEF_Member_tags_13,	/* Same as above */
	sizeof(asn_DEF_Member_tags_13)
		/sizeof(asn_DEF_Member_tags_13[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_13,
	2,	/* Elements count */
	&asn_SPC_Member_specs_13	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_axle_12[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_13,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_axle_tags_12[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_axle_specs_12 = {
	sizeof(struct axle),
	offsetof(struct axle, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_axle_12 = {
	"axle",
	"axle",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_axle_tags_12,
	sizeof(asn_DEF_axle_tags_12)
		/sizeof(asn_DEF_axle_tags_12[0]) - 1, /* 1 */
	asn_DEF_axle_tags_12,	/* Same as above */
	sizeof(asn_DEF_axle_tags_12)
		/sizeof(asn_DEF_axle_tags_12[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_axle_12,
	1,	/* Single element */
	&asn_SPC_axle_specs_12	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_J1939data_1[] = {
	{ ATF_POINTER, 10, offsetof(struct J1939data, tires),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_tires_2,
		.memb_constraints = memb_tires_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "tires"
		},
	{ ATF_POINTER, 9, offsetof(struct J1939data, axle),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_axle_12,
		.memb_constraints = memb_axle_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "axle"
		},
	{ ATF_POINTER, 8, offsetof(struct J1939data, trailerWeight),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TrailerWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "trailerWeight"
		},
	{ ATF_POINTER, 7, offsetof(struct J1939data, cargoWeight),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CargoWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "cargoWeight"
		},
	{ ATF_POINTER, 6, offsetof(struct J1939data, steeringAxleTemperature),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringAxleTemperature,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "steeringAxleTemperature"
		},
	{ ATF_POINTER, 5, offsetof(struct J1939data, driveAxleLocation),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleLocation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "driveAxleLocation"
		},
	{ ATF_POINTER, 4, offsetof(struct J1939data, driveAxleLiftAirPressure),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleLiftAirPressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "driveAxleLiftAirPressure"
		},
	{ ATF_POINTER, 3, offsetof(struct J1939data, driveAxleTemperature),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleTemperature,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "driveAxleTemperature"
		},
	{ ATF_POINTER, 2, offsetof(struct J1939data, driveAxleLubePressure),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DriveAxleLubePressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "driveAxleLubePressure"
		},
	{ ATF_POINTER, 1, offsetof(struct J1939data, steeringAxleLubePressure),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringAxleLubePressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "steeringAxleLubePressure"
		},
};
static ber_tlv_tag_t asn_DEF_J1939data_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_J1939data_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* tires */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* axle */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* trailerWeight */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* cargoWeight */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* steeringAxleTemperature */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* driveAxleLocation */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* driveAxleLiftAirPressure */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* driveAxleTemperature */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* driveAxleLubePressure */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 } /* steeringAxleLubePressure */
};
static asn_SEQUENCE_specifics_t asn_SPC_J1939data_specs_1 = {
	sizeof(struct J1939data),
	offsetof(struct J1939data, _asn_ctx),
	asn_MAP_J1939data_tag2el_1,
	10,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	9,	/* Start extensions */
	11	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_J1939data = {
	"J1939data",
	"J1939data",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_J1939data_tags_1,
	sizeof(asn_DEF_J1939data_tags_1)
		/sizeof(asn_DEF_J1939data_tags_1[0]), /* 1 */
	asn_DEF_J1939data_tags_1,	/* Same as above */
	sizeof(asn_DEF_J1939data_tags_1)
		/sizeof(asn_DEF_J1939data_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_J1939data_1,
	10,	/* Elements count */
	&asn_SPC_J1939data_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [MovementState] >>> ***/

#include "DescriptiveName.h"
#include "LaneCount.h"
#include "LaneSet.h"
#include "SignalLightState.h"
#include "PedestrianSignalState.h"
#include "SpecialSignalState.h"
#include "TimeMark.h"
#include "StateConfidence.h"
#include "ObjectCount.h"
#include "PedestrianDetect.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [MovementState] >>> ***/

typedef struct MovementState {
	DescriptiveName_t	*movementName	/* OPTIONAL */;
	LaneCount_t	*laneCnt	/* OPTIONAL */;
	LaneSet_t	 laneSet;
	SignalLightState_t	*currState	/* OPTIONAL */;
	PedestrianSignalState_t	*pedState	/* OPTIONAL */;
	SpecialSignalState_t	*specialState	/* OPTIONAL */;
	TimeMark_t	 timeToChange;
	StateConfidence_t	*stateConfidence	/* OPTIONAL */;
	SignalLightState_t	*yellState	/* OPTIONAL */;
	PedestrianSignalState_t	*yellPedState	/* OPTIONAL */;
	TimeMark_t	*yellTimeToChange	/* OPTIONAL */;
	StateConfidence_t	*yellStateConfidence	/* OPTIONAL */;
	ObjectCount_t	*vehicleCount	/* OPTIONAL */;
	PedestrianDetect_t	*pedDetect	/* OPTIONAL */;
	ObjectCount_t	*pedCount	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} MovementState_t;

/*** <<< FUNC-DECLS [MovementState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MovementState;

/*** <<< STAT-DEFS [MovementState] >>> ***/

static asn_TYPE_member_t asn_MBR_MovementState_1[] = {
	{ ATF_POINTER, 2, offsetof(struct MovementState, movementName),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "movementName"
		},
	{ ATF_POINTER, 1, offsetof(struct MovementState, laneCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct MovementState, laneSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneSet"
		},
	{ ATF_POINTER, 3, offsetof(struct MovementState, currState),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalLightState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "currState"
		},
	{ ATF_POINTER, 2, offsetof(struct MovementState, pedState),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PedestrianSignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pedState"
		},
	{ ATF_POINTER, 1, offsetof(struct MovementState, specialState),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpecialSignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "specialState"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct MovementState, timeToChange),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeMark,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "timeToChange"
		},
	{ ATF_POINTER, 8, offsetof(struct MovementState, stateConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_StateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "stateConfidence"
		},
	{ ATF_POINTER, 7, offsetof(struct MovementState, yellState),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalLightState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yellState"
		},
	{ ATF_POINTER, 6, offsetof(struct MovementState, yellPedState),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PedestrianSignalState,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yellPedState"
		},
	{ ATF_POINTER, 5, offsetof(struct MovementState, yellTimeToChange),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TimeMark,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yellTimeToChange"
		},
	{ ATF_POINTER, 4, offsetof(struct MovementState, yellStateConfidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_StateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yellStateConfidence"
		},
	{ ATF_POINTER, 3, offsetof(struct MovementState, vehicleCount),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObjectCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleCount"
		},
	{ ATF_POINTER, 2, offsetof(struct MovementState, pedDetect),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PedestrianDetect,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pedDetect"
		},
	{ ATF_POINTER, 1, offsetof(struct MovementState, pedCount),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObjectCount,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pedCount"
		},
};
static ber_tlv_tag_t asn_DEF_MovementState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_MovementState_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* movementName */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneCnt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* laneSet */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* currState */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* pedState */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* specialState */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* timeToChange */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* stateConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* yellState */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* yellPedState */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* yellTimeToChange */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* yellStateConfidence */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* vehicleCount */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* pedDetect */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 } /* pedCount */
};
static asn_SEQUENCE_specifics_t asn_SPC_MovementState_specs_1 = {
	sizeof(struct MovementState),
	offsetof(struct MovementState, _asn_ctx),
	asn_MAP_MovementState_tag2el_1,
	15,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	14,	/* Start extensions */
	16	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_MovementState = {
	"MovementState",
	"MovementState",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MovementState_tags_1,
	sizeof(asn_DEF_MovementState_tags_1)
		/sizeof(asn_DEF_MovementState_tags_1[0]), /* 1 */
	asn_DEF_MovementState_tags_1,	/* Same as above */
	sizeof(asn_DEF_MovementState_tags_1)
		/sizeof(asn_DEF_MovementState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_MovementState_1,
	15,	/* Elements count */
	&asn_SPC_MovementState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NodeList] >>> ***/

#include "Offsets.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< TYPE-DECLS [NodeList] >>> ***/

typedef struct NodeList {
	A_SEQUENCE_OF(Offsets_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} NodeList_t;

/*** <<< FUNC-DECLS [NodeList] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NodeList;

/*** <<< STAT-DEFS [NodeList] >>> ***/

static asn_TYPE_member_t asn_MBR_NodeList_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Offsets,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_NodeList_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_NodeList_specs_1 = {
	sizeof(struct NodeList),
	offsetof(struct NodeList, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_NodeList = {
	"NodeList",
	"NodeList",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_NodeList_tags_1,
	sizeof(asn_DEF_NodeList_tags_1)
		/sizeof(asn_DEF_NodeList_tags_1[0]), /* 1 */
	asn_DEF_NodeList_tags_1,	/* Same as above */
	sizeof(asn_DEF_NodeList_tags_1)
		/sizeof(asn_DEF_NodeList_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_NodeList_1,
	1,	/* Single element */
	&asn_SPC_NodeList_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Offsets] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [Offsets] >>> ***/

typedef OCTET_STRING_t	 Offsets_t;

/*** <<< FUNC-DECLS [Offsets] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Offsets;
asn_struct_free_f Offsets_free;
asn_struct_print_f Offsets_print;
asn_constr_check_f Offsets_constraint;
ber_type_decoder_f Offsets_decode_ber;
der_type_encoder_f Offsets_encode_der;
xer_type_decoder_f Offsets_decode_xer;
xer_type_encoder_f Offsets_encode_xer;

/*** <<< CODE [Offsets] >>> ***/

int
Offsets_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 4 && size <= 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
Offsets_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
Offsets_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Offsets_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Offsets_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Offsets_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Offsets_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Offsets_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Offsets_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Offsets_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Offsets_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Offsets_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Offsets_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Offsets_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Offsets] >>> ***/

static ber_tlv_tag_t asn_DEF_Offsets_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Offsets = {
	"Offsets",
	"Offsets",
	Offsets_free,
	Offsets_print,
	Offsets_constraint,
	Offsets_decode_ber,
	Offsets_encode_der,
	Offsets_decode_xer,
	Offsets_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Offsets_tags_1,
	sizeof(asn_DEF_Offsets_tags_1)
		/sizeof(asn_DEF_Offsets_tags_1[0]), /* 1 */
	asn_DEF_Offsets_tags_1,	/* Same as above */
	sizeof(asn_DEF_Offsets_tags_1)
		/sizeof(asn_DEF_Offsets_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistory] >>> ***/

#include "GPSstatus.h"
#include "Count.h"
#include <OCTET_STRING.h>
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>

/*** <<< DEPS [PathHistory] >>> ***/

typedef enum crumbData_PR {
	crumbData_PR_NOTHING,	/* No components present */
	crumbData_PR_pathHistoryPointSets_01,
	crumbData_PR_pathHistoryPointSets_02,
	crumbData_PR_pathHistoryPointSets_03,
	crumbData_PR_pathHistoryPointSets_04,
	crumbData_PR_pathHistoryPointSets_05,
	crumbData_PR_pathHistoryPointSets_06,
	crumbData_PR_pathHistoryPointSets_07,
	crumbData_PR_pathHistoryPointSets_08,
	crumbData_PR_pathHistoryPointSets_09,
	crumbData_PR_pathHistoryPointSets_10
} crumbData_PR;

/*** <<< FWD-DECLS [PathHistory] >>> ***/

struct FullPositionVector;
struct PathHistoryPointType_01;

/*** <<< TYPE-DECLS [PathHistory] >>> ***/

typedef struct PathHistory {
	struct FullPositionVector	*initialPosition	/* OPTIONAL */;
	GPSstatus_t	*currGPSstatus	/* OPTIONAL */;
	Count_t	*itemCnt	/* OPTIONAL */;
	struct crumbData {
		crumbData_PR present;
		union PathHistory__crumbData_u {
			struct pathHistoryPointSets_01 {
				A_SEQUENCE_OF(struct PathHistoryPointType_01) list;
				
				/* Context for parsing across buffer boundaries */
				asn_struct_ctx_t _asn_ctx;
			} pathHistoryPointSets_01;
			OCTET_STRING_t	 pathHistoryPointSets_02;
			OCTET_STRING_t	 pathHistoryPointSets_03;
			OCTET_STRING_t	 pathHistoryPointSets_04;
			OCTET_STRING_t	 pathHistoryPointSets_05;
			OCTET_STRING_t	 pathHistoryPointSets_06;
			OCTET_STRING_t	 pathHistoryPointSets_07;
			OCTET_STRING_t	 pathHistoryPointSets_08;
			OCTET_STRING_t	 pathHistoryPointSets_09;
			OCTET_STRING_t	 pathHistoryPointSets_10;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} crumbData;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} PathHistory_t;

/*** <<< FUNC-DECLS [PathHistory] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistory;

/*** <<< POST-INCLUDE [PathHistory] >>> ***/

#include "FullPositionVector.h"
#include "PathHistoryPointType-01.h"

/*** <<< CODE [PathHistory] >>> ***/

static int
memb_pathHistoryPointSets_01_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 23)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_02_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 15 && size <= 345)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_03_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 12 && size <= 276)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_04_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 8 && size <= 184)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_05_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 10 && size <= 230)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_06_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 6 && size <= 138)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_07_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 11 && size <= 242)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_08_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 7 && size <= 161)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_09_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 9 && size <= 196)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pathHistoryPointSets_10_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 5 && size <= 104)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [PathHistory] >>> ***/

static asn_TYPE_member_t asn_MBR_pathHistoryPointSets_01_6[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_PathHistoryPointType_01,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_pathHistoryPointSets_01_tags_6[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_pathHistoryPointSets_01_specs_6 = {
	sizeof(struct pathHistoryPointSets_01),
	offsetof(struct pathHistoryPointSets_01, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_pathHistoryPointSets_01_6 = {
	"pathHistoryPointSets-01",
	"pathHistoryPointSets-01",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_pathHistoryPointSets_01_tags_6,
	sizeof(asn_DEF_pathHistoryPointSets_01_tags_6)
		/sizeof(asn_DEF_pathHistoryPointSets_01_tags_6[0]) - 1, /* 1 */
	asn_DEF_pathHistoryPointSets_01_tags_6,	/* Same as above */
	sizeof(asn_DEF_pathHistoryPointSets_01_tags_6)
		/sizeof(asn_DEF_pathHistoryPointSets_01_tags_6[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_pathHistoryPointSets_01_6,
	1,	/* Single element */
	&asn_SPC_pathHistoryPointSets_01_specs_6	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_crumbData_5[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_01),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_pathHistoryPointSets_01_6,
		.memb_constraints = memb_pathHistoryPointSets_01_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-01"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_02),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_02_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-02"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_03),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_03_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-03"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_04),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_04_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-04"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_05),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_05_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-05"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_06),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_06_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-06"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_07),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_07_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-07"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_08),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_08_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-08"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_09),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_09_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-09"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct crumbData, choice.pathHistoryPointSets_10),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_pathHistoryPointSets_10_constraint_5,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistoryPointSets-10"
		},
};
static asn_TYPE_tag2member_t asn_MAP_crumbData_tag2el_5[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* pathHistoryPointSets-01 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* pathHistoryPointSets-02 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* pathHistoryPointSets-03 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* pathHistoryPointSets-04 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* pathHistoryPointSets-05 */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* pathHistoryPointSets-06 */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* pathHistoryPointSets-07 */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* pathHistoryPointSets-08 */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* pathHistoryPointSets-09 */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 } /* pathHistoryPointSets-10 */
};
static asn_CHOICE_specifics_t asn_SPC_crumbData_specs_5 = {
	sizeof(struct crumbData),
	offsetof(struct crumbData, _asn_ctx),
	offsetof(struct crumbData, present),
	sizeof(((struct crumbData *)0)->present),
	asn_MAP_crumbData_tag2el_5,
	10,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_crumbData_5 = {
	"crumbData",
	"crumbData",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_crumbData_5,
	10,	/* Elements count */
	&asn_SPC_crumbData_specs_5	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_PathHistory_1[] = {
	{ ATF_POINTER, 3, offsetof(struct PathHistory, initialPosition),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "initialPosition"
		},
	{ ATF_POINTER, 2, offsetof(struct PathHistory, currGPSstatus),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_GPSstatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "currGPSstatus"
		},
	{ ATF_POINTER, 1, offsetof(struct PathHistory, itemCnt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Count,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "itemCnt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PathHistory, crumbData),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_crumbData_5,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crumbData"
		},
};
static ber_tlv_tag_t asn_DEF_PathHistory_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_PathHistory_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* initialPosition */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* currGPSstatus */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* itemCnt */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* crumbData */
};
static asn_SEQUENCE_specifics_t asn_SPC_PathHistory_specs_1 = {
	sizeof(struct PathHistory),
	offsetof(struct PathHistory, _asn_ctx),
	asn_MAP_PathHistory_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_PathHistory = {
	"PathHistory",
	"PathHistory",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistory_tags_1,
	sizeof(asn_DEF_PathHistory_tags_1)
		/sizeof(asn_DEF_PathHistory_tags_1[0]), /* 1 */
	asn_DEF_PathHistory_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistory_tags_1)
		/sizeof(asn_DEF_PathHistory_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_PathHistory_1,
	4,	/* Elements count */
	&asn_SPC_PathHistory_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [PathHistoryPointType-01] >>> ***/

#include <NativeInteger.h>
#include "PositionalAccuracy.h"
#include "TransmissionAndSpeed.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-01] >>> ***/

typedef struct PathHistoryPointType_01 {
	long	 latOffset;
	long	 longOffset;
	long	*elevationOffset	/* OPTIONAL */;
	long	*timeOffset	/* OPTIONAL */;
	PositionalAccuracy_t	*posAccuracy	/* OPTIONAL */;
	long	*heading	/* OPTIONAL */;
	TransmissionAndSpeed_t	*speed	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} PathHistoryPointType_01_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-01] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_01;

/*** <<< CODE [PathHistoryPointType-01] >>> ***/

static int
memb_latOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -131072 && value <= 131071)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_longOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -131072 && value <= 131071)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_elevationOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -2048 && value <= 2047)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_timeOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_heading_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -128 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [PathHistoryPointType-01] >>> ***/

static asn_TYPE_member_t asn_MBR_PathHistoryPointType_01_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct PathHistoryPointType_01, latOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_latOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "latOffset"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PathHistoryPointType_01, longOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_longOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "longOffset"
		},
	{ ATF_POINTER, 5, offsetof(struct PathHistoryPointType_01, elevationOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_elevationOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "elevationOffset"
		},
	{ ATF_POINTER, 4, offsetof(struct PathHistoryPointType_01, timeOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_timeOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "timeOffset"
		},
	{ ATF_POINTER, 3, offsetof(struct PathHistoryPointType_01, posAccuracy),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PositionalAccuracy,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "posAccuracy"
		},
	{ ATF_POINTER, 2, offsetof(struct PathHistoryPointType_01, heading),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_heading_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "heading"
		},
	{ ATF_POINTER, 1, offsetof(struct PathHistoryPointType_01, speed),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TransmissionAndSpeed,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speed"
		},
};
static ber_tlv_tag_t asn_DEF_PathHistoryPointType_01_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_PathHistoryPointType_01_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* latOffset */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* longOffset */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* elevationOffset */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* timeOffset */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* posAccuracy */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* heading */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 } /* speed */
};
static asn_SEQUENCE_specifics_t asn_SPC_PathHistoryPointType_01_specs_1 = {
	sizeof(struct PathHistoryPointType_01),
	offsetof(struct PathHistoryPointType_01, _asn_ctx),
	asn_MAP_PathHistoryPointType_01_tag2el_1,
	7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_01 = {
	"PathHistoryPointType-01",
	"PathHistoryPointType-01",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_01_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_01_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_01_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_01_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_01_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_01_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_PathHistoryPointType_01_1,
	7,	/* Elements count */
	&asn_SPC_PathHistoryPointType_01_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [PathHistoryPointType-02] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-02] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_02_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-02] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_02;
asn_struct_free_f PathHistoryPointType_02_free;
asn_struct_print_f PathHistoryPointType_02_print;
asn_constr_check_f PathHistoryPointType_02_constraint;
ber_type_decoder_f PathHistoryPointType_02_decode_ber;
der_type_encoder_f PathHistoryPointType_02_encode_der;
xer_type_decoder_f PathHistoryPointType_02_decode_xer;
xer_type_encoder_f PathHistoryPointType_02_encode_xer;

/*** <<< CODE [PathHistoryPointType-02] >>> ***/

int
PathHistoryPointType_02_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 15)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_02_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_02_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_02_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_02_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_02_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_02_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_02_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_02_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_02_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_02_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_02_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_02_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_02_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-02] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_02_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_02 = {
	"PathHistoryPointType-02",
	"PathHistoryPointType-02",
	PathHistoryPointType_02_free,
	PathHistoryPointType_02_print,
	PathHistoryPointType_02_constraint,
	PathHistoryPointType_02_decode_ber,
	PathHistoryPointType_02_encode_der,
	PathHistoryPointType_02_decode_xer,
	PathHistoryPointType_02_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_02_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_02_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_02_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_02_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_02_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_02_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-03] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-03] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_03_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-03] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_03;
asn_struct_free_f PathHistoryPointType_03_free;
asn_struct_print_f PathHistoryPointType_03_print;
asn_constr_check_f PathHistoryPointType_03_constraint;
ber_type_decoder_f PathHistoryPointType_03_decode_ber;
der_type_encoder_f PathHistoryPointType_03_encode_der;
xer_type_decoder_f PathHistoryPointType_03_decode_xer;
xer_type_encoder_f PathHistoryPointType_03_encode_xer;

/*** <<< CODE [PathHistoryPointType-03] >>> ***/

int
PathHistoryPointType_03_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 12)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_03_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_03_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_03_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_03_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_03_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_03_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_03_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_03_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_03_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_03_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_03_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_03_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_03_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-03] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_03_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_03 = {
	"PathHistoryPointType-03",
	"PathHistoryPointType-03",
	PathHistoryPointType_03_free,
	PathHistoryPointType_03_print,
	PathHistoryPointType_03_constraint,
	PathHistoryPointType_03_decode_ber,
	PathHistoryPointType_03_encode_der,
	PathHistoryPointType_03_decode_xer,
	PathHistoryPointType_03_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_03_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_03_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_03_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_03_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_03_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_03_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-04] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-04] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_04_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-04] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_04;
asn_struct_free_f PathHistoryPointType_04_free;
asn_struct_print_f PathHistoryPointType_04_print;
asn_constr_check_f PathHistoryPointType_04_constraint;
ber_type_decoder_f PathHistoryPointType_04_decode_ber;
der_type_encoder_f PathHistoryPointType_04_encode_der;
xer_type_decoder_f PathHistoryPointType_04_decode_xer;
xer_type_encoder_f PathHistoryPointType_04_encode_xer;

/*** <<< CODE [PathHistoryPointType-04] >>> ***/

int
PathHistoryPointType_04_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_04_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_04_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_04_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_04_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_04_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_04_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_04_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_04_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_04_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_04_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_04_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_04_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_04_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-04] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_04_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_04 = {
	"PathHistoryPointType-04",
	"PathHistoryPointType-04",
	PathHistoryPointType_04_free,
	PathHistoryPointType_04_print,
	PathHistoryPointType_04_constraint,
	PathHistoryPointType_04_decode_ber,
	PathHistoryPointType_04_encode_der,
	PathHistoryPointType_04_decode_xer,
	PathHistoryPointType_04_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_04_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_04_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_04_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_04_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_04_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_04_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-05] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-05] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_05_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-05] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_05;
asn_struct_free_f PathHistoryPointType_05_free;
asn_struct_print_f PathHistoryPointType_05_print;
asn_constr_check_f PathHistoryPointType_05_constraint;
ber_type_decoder_f PathHistoryPointType_05_decode_ber;
der_type_encoder_f PathHistoryPointType_05_encode_der;
xer_type_decoder_f PathHistoryPointType_05_decode_xer;
xer_type_encoder_f PathHistoryPointType_05_encode_xer;

/*** <<< CODE [PathHistoryPointType-05] >>> ***/

int
PathHistoryPointType_05_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_05_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_05_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_05_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_05_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_05_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_05_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_05_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_05_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_05_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_05_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_05_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_05_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_05_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-05] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_05_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_05 = {
	"PathHistoryPointType-05",
	"PathHistoryPointType-05",
	PathHistoryPointType_05_free,
	PathHistoryPointType_05_print,
	PathHistoryPointType_05_constraint,
	PathHistoryPointType_05_decode_ber,
	PathHistoryPointType_05_encode_der,
	PathHistoryPointType_05_decode_xer,
	PathHistoryPointType_05_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_05_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_05_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_05_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_05_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_05_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_05_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-06] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-06] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_06_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-06] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_06;
asn_struct_free_f PathHistoryPointType_06_free;
asn_struct_print_f PathHistoryPointType_06_print;
asn_constr_check_f PathHistoryPointType_06_constraint;
ber_type_decoder_f PathHistoryPointType_06_decode_ber;
der_type_encoder_f PathHistoryPointType_06_encode_der;
xer_type_decoder_f PathHistoryPointType_06_decode_xer;
xer_type_encoder_f PathHistoryPointType_06_encode_xer;

/*** <<< CODE [PathHistoryPointType-06] >>> ***/

int
PathHistoryPointType_06_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 6)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_06_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_06_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_06_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_06_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_06_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_06_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_06_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_06_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_06_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_06_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_06_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_06_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_06_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-06] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_06_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_06 = {
	"PathHistoryPointType-06",
	"PathHistoryPointType-06",
	PathHistoryPointType_06_free,
	PathHistoryPointType_06_print,
	PathHistoryPointType_06_constraint,
	PathHistoryPointType_06_decode_ber,
	PathHistoryPointType_06_encode_der,
	PathHistoryPointType_06_decode_xer,
	PathHistoryPointType_06_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_06_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_06_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_06_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_06_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_06_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_06_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-07] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-07] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_07_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-07] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_07;
asn_struct_free_f PathHistoryPointType_07_free;
asn_struct_print_f PathHistoryPointType_07_print;
asn_constr_check_f PathHistoryPointType_07_constraint;
ber_type_decoder_f PathHistoryPointType_07_decode_ber;
der_type_encoder_f PathHistoryPointType_07_encode_der;
xer_type_decoder_f PathHistoryPointType_07_decode_xer;
xer_type_encoder_f PathHistoryPointType_07_encode_xer;

/*** <<< CODE [PathHistoryPointType-07] >>> ***/

int
PathHistoryPointType_07_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 11)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_07_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_07_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_07_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_07_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_07_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_07_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_07_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_07_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_07_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_07_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_07_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_07_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_07_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-07] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_07_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_07 = {
	"PathHistoryPointType-07",
	"PathHistoryPointType-07",
	PathHistoryPointType_07_free,
	PathHistoryPointType_07_print,
	PathHistoryPointType_07_constraint,
	PathHistoryPointType_07_decode_ber,
	PathHistoryPointType_07_encode_der,
	PathHistoryPointType_07_decode_xer,
	PathHistoryPointType_07_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_07_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_07_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_07_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_07_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_07_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_07_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-08] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-08] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_08_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-08] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_08;
asn_struct_free_f PathHistoryPointType_08_free;
asn_struct_print_f PathHistoryPointType_08_print;
asn_constr_check_f PathHistoryPointType_08_constraint;
ber_type_decoder_f PathHistoryPointType_08_decode_ber;
der_type_encoder_f PathHistoryPointType_08_encode_der;
xer_type_decoder_f PathHistoryPointType_08_decode_xer;
xer_type_encoder_f PathHistoryPointType_08_encode_xer;

/*** <<< CODE [PathHistoryPointType-08] >>> ***/

int
PathHistoryPointType_08_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 7)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_08_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_08_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_08_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_08_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_08_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_08_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_08_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_08_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_08_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_08_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_08_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_08_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_08_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-08] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_08_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_08 = {
	"PathHistoryPointType-08",
	"PathHistoryPointType-08",
	PathHistoryPointType_08_free,
	PathHistoryPointType_08_print,
	PathHistoryPointType_08_constraint,
	PathHistoryPointType_08_decode_ber,
	PathHistoryPointType_08_encode_der,
	PathHistoryPointType_08_decode_xer,
	PathHistoryPointType_08_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_08_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_08_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_08_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_08_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_08_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_08_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-09] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-09] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_09_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-09] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_09;
asn_struct_free_f PathHistoryPointType_09_free;
asn_struct_print_f PathHistoryPointType_09_print;
asn_constr_check_f PathHistoryPointType_09_constraint;
ber_type_decoder_f PathHistoryPointType_09_decode_ber;
der_type_encoder_f PathHistoryPointType_09_encode_der;
xer_type_decoder_f PathHistoryPointType_09_decode_xer;
xer_type_encoder_f PathHistoryPointType_09_encode_xer;

/*** <<< CODE [PathHistoryPointType-09] >>> ***/

int
PathHistoryPointType_09_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 9)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_09_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_09_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_09_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_09_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_09_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_09_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_09_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_09_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_09_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_09_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_09_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_09_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_09_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-09] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_09_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_09 = {
	"PathHistoryPointType-09",
	"PathHistoryPointType-09",
	PathHistoryPointType_09_free,
	PathHistoryPointType_09_print,
	PathHistoryPointType_09_constraint,
	PathHistoryPointType_09_decode_ber,
	PathHistoryPointType_09_encode_der,
	PathHistoryPointType_09_decode_xer,
	PathHistoryPointType_09_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_09_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_09_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_09_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_09_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_09_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_09_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathHistoryPointType-10] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PathHistoryPointType-10] >>> ***/

typedef OCTET_STRING_t	 PathHistoryPointType_10_t;

/*** <<< FUNC-DECLS [PathHistoryPointType-10] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_10;
asn_struct_free_f PathHistoryPointType_10_free;
asn_struct_print_f PathHistoryPointType_10_print;
asn_constr_check_f PathHistoryPointType_10_constraint;
ber_type_decoder_f PathHistoryPointType_10_decode_ber;
der_type_encoder_f PathHistoryPointType_10_encode_der;
xer_type_decoder_f PathHistoryPointType_10_decode_xer;
xer_type_encoder_f PathHistoryPointType_10_encode_xer;

/*** <<< CODE [PathHistoryPointType-10] >>> ***/

int
PathHistoryPointType_10_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 5)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PathHistoryPointType_10_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PathHistoryPointType_10_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PathHistoryPointType_10_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PathHistoryPointType_10_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_10_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_10_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PathHistoryPointType_10_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PathHistoryPointType_10_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_10_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PathHistoryPointType_10_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PathHistoryPointType_10_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PathHistoryPointType_10_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PathHistoryPointType_10_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PathHistoryPointType-10] >>> ***/

static ber_tlv_tag_t asn_DEF_PathHistoryPointType_10_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PathHistoryPointType_10 = {
	"PathHistoryPointType-10",
	"PathHistoryPointType-10",
	PathHistoryPointType_10_free,
	PathHistoryPointType_10_print,
	PathHistoryPointType_10_constraint,
	PathHistoryPointType_10_decode_ber,
	PathHistoryPointType_10_encode_der,
	PathHistoryPointType_10_decode_xer,
	PathHistoryPointType_10_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathHistoryPointType_10_tags_1,
	sizeof(asn_DEF_PathHistoryPointType_10_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_10_tags_1[0]), /* 1 */
	asn_DEF_PathHistoryPointType_10_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathHistoryPointType_10_tags_1)
		/sizeof(asn_DEF_PathHistoryPointType_10_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PathPrediction] >>> ***/

#include <NativeInteger.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [PathPrediction] >>> ***/

typedef struct PathPrediction {
	long	 radiusOfCurve;
	long	 confidence;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} PathPrediction_t;

/*** <<< FUNC-DECLS [PathPrediction] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PathPrediction;

/*** <<< CODE [PathPrediction] >>> ***/

static int
memb_radiusOfCurve_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_confidence_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 200)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [PathPrediction] >>> ***/

static asn_TYPE_member_t asn_MBR_PathPrediction_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct PathPrediction, radiusOfCurve),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_radiusOfCurve_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "radiusOfCurve"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PathPrediction, confidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_confidence_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "confidence"
		},
};
static ber_tlv_tag_t asn_DEF_PathPrediction_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_PathPrediction_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* radiusOfCurve */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* confidence */
};
static asn_SEQUENCE_specifics_t asn_SPC_PathPrediction_specs_1 = {
	sizeof(struct PathPrediction),
	offsetof(struct PathPrediction, _asn_ctx),
	asn_MAP_PathPrediction_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	1,	/* Start extensions */
	3	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_PathPrediction = {
	"PathPrediction",
	"PathPrediction",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PathPrediction_tags_1,
	sizeof(asn_DEF_PathPrediction_tags_1)
		/sizeof(asn_DEF_PathPrediction_tags_1[0]), /* 1 */
	asn_DEF_PathPrediction_tags_1,	/* Same as above */
	sizeof(asn_DEF_PathPrediction_tags_1)
		/sizeof(asn_DEF_PathPrediction_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_PathPrediction_1,
	2,	/* Elements count */
	&asn_SPC_PathPrediction_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Position3D] >>> ***/

#include "Latitude.h"
#include "Longitude.h"
#include "Elevation.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [Position3D] >>> ***/

typedef struct Position3D {
	Latitude_t	 lat;
	Longitude_t	 Long;
	Elevation_t	*elevation	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Position3D_t;

/*** <<< FUNC-DECLS [Position3D] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Position3D;

/*** <<< STAT-DEFS [Position3D] >>> ***/

static asn_TYPE_member_t asn_MBR_Position3D_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Position3D, lat),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Latitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lat"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Position3D, Long),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Longitude,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "long"
		},
	{ ATF_POINTER, 1, offsetof(struct Position3D, elevation),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Elevation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "elevation"
		},
};
static ber_tlv_tag_t asn_DEF_Position3D_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Position3D_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* lat */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* long */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* elevation */
};
static asn_SEQUENCE_specifics_t asn_SPC_Position3D_specs_1 = {
	sizeof(struct Position3D),
	offsetof(struct Position3D, _asn_ctx),
	asn_MAP_Position3D_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Position3D = {
	"Position3D",
	"Position3D",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Position3D_tags_1,
	sizeof(asn_DEF_Position3D_tags_1)
		/sizeof(asn_DEF_Position3D_tags_1[0]), /* 1 */
	asn_DEF_Position3D_tags_1,	/* Same as above */
	sizeof(asn_DEF_Position3D_tags_1)
		/sizeof(asn_DEF_Position3D_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Position3D_1,
	3,	/* Elements count */
	&asn_SPC_Position3D_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [PositionalAccuracy] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PositionalAccuracy] >>> ***/

typedef OCTET_STRING_t	 PositionalAccuracy_t;

/*** <<< FUNC-DECLS [PositionalAccuracy] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PositionalAccuracy;
asn_struct_free_f PositionalAccuracy_free;
asn_struct_print_f PositionalAccuracy_print;
asn_constr_check_f PositionalAccuracy_constraint;
ber_type_decoder_f PositionalAccuracy_decode_ber;
der_type_encoder_f PositionalAccuracy_encode_der;
xer_type_decoder_f PositionalAccuracy_decode_xer;
xer_type_encoder_f PositionalAccuracy_encode_xer;

/*** <<< CODE [PositionalAccuracy] >>> ***/

int
PositionalAccuracy_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 4)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PositionalAccuracy_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PositionalAccuracy_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PositionalAccuracy_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PositionalAccuracy_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PositionalAccuracy_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PositionalAccuracy_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PositionalAccuracy_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PositionalAccuracy_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PositionalAccuracy_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PositionalAccuracy_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PositionalAccuracy_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PositionalAccuracy_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PositionalAccuracy_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PositionalAccuracy] >>> ***/

static ber_tlv_tag_t asn_DEF_PositionalAccuracy_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PositionalAccuracy = {
	"PositionalAccuracy",
	"PositionalAccuracy",
	PositionalAccuracy_free,
	PositionalAccuracy_print,
	PositionalAccuracy_constraint,
	PositionalAccuracy_decode_ber,
	PositionalAccuracy_encode_der,
	PositionalAccuracy_decode_xer,
	PositionalAccuracy_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PositionalAccuracy_tags_1,
	sizeof(asn_DEF_PositionalAccuracy_tags_1)
		/sizeof(asn_DEF_PositionalAccuracy_tags_1[0]), /* 1 */
	asn_DEF_PositionalAccuracy_tags_1,	/* Same as above */
	sizeof(asn_DEF_PositionalAccuracy_tags_1)
		/sizeof(asn_DEF_PositionalAccuracy_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PositionConfidenceSet] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PositionConfidenceSet] >>> ***/

typedef OCTET_STRING_t	 PositionConfidenceSet_t;

/*** <<< FUNC-DECLS [PositionConfidenceSet] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PositionConfidenceSet;
asn_struct_free_f PositionConfidenceSet_free;
asn_struct_print_f PositionConfidenceSet_print;
asn_constr_check_f PositionConfidenceSet_constraint;
ber_type_decoder_f PositionConfidenceSet_decode_ber;
der_type_encoder_f PositionConfidenceSet_encode_der;
xer_type_decoder_f PositionConfidenceSet_decode_xer;
xer_type_encoder_f PositionConfidenceSet_encode_xer;

/*** <<< CODE [PositionConfidenceSet] >>> ***/

int
PositionConfidenceSet_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PositionConfidenceSet_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PositionConfidenceSet_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PositionConfidenceSet_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PositionConfidenceSet_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PositionConfidenceSet_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PositionConfidenceSet_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PositionConfidenceSet_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PositionConfidenceSet_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PositionConfidenceSet_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PositionConfidenceSet_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PositionConfidenceSet_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PositionConfidenceSet_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PositionConfidenceSet_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PositionConfidenceSet] >>> ***/

static ber_tlv_tag_t asn_DEF_PositionConfidenceSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PositionConfidenceSet = {
	"PositionConfidenceSet",
	"PositionConfidenceSet",
	PositionConfidenceSet_free,
	PositionConfidenceSet_print,
	PositionConfidenceSet_constraint,
	PositionConfidenceSet_decode_ber,
	PositionConfidenceSet_encode_der,
	PositionConfidenceSet_decode_xer,
	PositionConfidenceSet_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PositionConfidenceSet_tags_1,
	sizeof(asn_DEF_PositionConfidenceSet_tags_1)
		/sizeof(asn_DEF_PositionConfidenceSet_tags_1[0]), /* 1 */
	asn_DEF_PositionConfidenceSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_PositionConfidenceSet_tags_1)
		/sizeof(asn_DEF_PositionConfidenceSet_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [RegionList] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< FWD-DECLS [RegionList] >>> ***/

struct RegionOffsets;

/*** <<< TYPE-DECLS [RegionList] >>> ***/

typedef struct RegionList {
	A_SEQUENCE_OF(struct RegionOffsets) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RegionList_t;

/*** <<< FUNC-DECLS [RegionList] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RegionList;

/*** <<< POST-INCLUDE [RegionList] >>> ***/

#include "RegionOffsets.h"

/*** <<< STAT-DEFS [RegionList] >>> ***/

static asn_TYPE_member_t asn_MBR_RegionList_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_RegionOffsets,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_RegionList_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_RegionList_specs_1 = {
	sizeof(struct RegionList),
	offsetof(struct RegionList, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_RegionList = {
	"RegionList",
	"RegionList",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionList_tags_1,
	sizeof(asn_DEF_RegionList_tags_1)
		/sizeof(asn_DEF_RegionList_tags_1[0]), /* 1 */
	asn_DEF_RegionList_tags_1,	/* Same as above */
	sizeof(asn_DEF_RegionList_tags_1)
		/sizeof(asn_DEF_RegionList_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionList_1,
	1,	/* Single element */
	&asn_SPC_RegionList_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RegionOffsets] >>> ***/

#include <NativeInteger.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [RegionOffsets] >>> ***/

typedef struct RegionOffsets {
	long	 xOffset;
	long	 yOffset;
	long	*zOffset	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RegionOffsets_t;

/*** <<< FUNC-DECLS [RegionOffsets] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RegionOffsets;

/*** <<< CODE [RegionOffsets] >>> ***/

static int
memb_xOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_yOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_zOffset_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [RegionOffsets] >>> ***/

static asn_TYPE_member_t asn_MBR_RegionOffsets_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionOffsets, xOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_xOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "xOffset"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionOffsets, yOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_yOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yOffset"
		},
	{ ATF_POINTER, 1, offsetof(struct RegionOffsets, zOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_zOffset_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "zOffset"
		},
};
static ber_tlv_tag_t asn_DEF_RegionOffsets_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RegionOffsets_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* xOffset */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* yOffset */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* zOffset */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionOffsets_specs_1 = {
	sizeof(struct RegionOffsets),
	offsetof(struct RegionOffsets, _asn_ctx),
	asn_MAP_RegionOffsets_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionOffsets = {
	"RegionOffsets",
	"RegionOffsets",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionOffsets_tags_1,
	sizeof(asn_DEF_RegionOffsets_tags_1)
		/sizeof(asn_DEF_RegionOffsets_tags_1[0]), /* 1 */
	asn_DEF_RegionOffsets_tags_1,	/* Same as above */
	sizeof(asn_DEF_RegionOffsets_tags_1)
		/sizeof(asn_DEF_RegionOffsets_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionOffsets_1,
	3,	/* Elements count */
	&asn_SPC_RegionOffsets_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RegionPointSet] >>> ***/

#include "RegionList.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [RegionPointSet] >>> ***/

struct Position3D;

/*** <<< TYPE-DECLS [RegionPointSet] >>> ***/

typedef struct RegionPointSet {
	struct Position3D	*anchor	/* OPTIONAL */;
	RegionList_t	 nodeList;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RegionPointSet_t;

/*** <<< FUNC-DECLS [RegionPointSet] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RegionPointSet;

/*** <<< POST-INCLUDE [RegionPointSet] >>> ***/

#include "Position3D.h"

/*** <<< STAT-DEFS [RegionPointSet] >>> ***/

static asn_TYPE_member_t asn_MBR_RegionPointSet_1[] = {
	{ ATF_POINTER, 1, offsetof(struct RegionPointSet, anchor),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "anchor"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionPointSet, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RegionList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
};
static ber_tlv_tag_t asn_DEF_RegionPointSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RegionPointSet_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* anchor */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* nodeList */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionPointSet_specs_1 = {
	sizeof(struct RegionPointSet),
	offsetof(struct RegionPointSet, _asn_ctx),
	asn_MAP_RegionPointSet_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	1,	/* Start extensions */
	3	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionPointSet = {
	"RegionPointSet",
	"RegionPointSet",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionPointSet_tags_1,
	sizeof(asn_DEF_RegionPointSet_tags_1)
		/sizeof(asn_DEF_RegionPointSet_tags_1[0]), /* 1 */
	asn_DEF_RegionPointSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_RegionPointSet_tags_1)
		/sizeof(asn_DEF_RegionPointSet_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionPointSet_1,
	2,	/* Elements count */
	&asn_SPC_RegionPointSet_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RoadSignID] >>> ***/

#include "Position3D.h"
#include "HeadingSlice.h"
#include "MUTCDCode.h"
#include "MsgCRC.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [RoadSignID] >>> ***/

typedef struct RoadSignID {
	Position3D_t	 position;
	HeadingSlice_t	 viewAngle;
	MUTCDCode_t	*mutcdCode	/* OPTIONAL */;
	MsgCRC_t	*crc	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RoadSignID_t;

/*** <<< FUNC-DECLS [RoadSignID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RoadSignID;

/*** <<< STAT-DEFS [RoadSignID] >>> ***/

static asn_TYPE_member_t asn_MBR_RoadSignID_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RoadSignID, position),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "position"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RoadSignID, viewAngle),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_HeadingSlice,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "viewAngle"
		},
	{ ATF_POINTER, 2, offsetof(struct RoadSignID, mutcdCode),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MUTCDCode,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "mutcdCode"
		},
	{ ATF_POINTER, 1, offsetof(struct RoadSignID, crc),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_MsgCRC,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "crc"
		},
};
static ber_tlv_tag_t asn_DEF_RoadSignID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RoadSignID_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* position */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* viewAngle */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* mutcdCode */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* crc */
};
static asn_SEQUENCE_specifics_t asn_SPC_RoadSignID_specs_1 = {
	sizeof(struct RoadSignID),
	offsetof(struct RoadSignID, _asn_ctx),
	asn_MAP_RoadSignID_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RoadSignID = {
	"RoadSignID",
	"RoadSignID",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RoadSignID_tags_1,
	sizeof(asn_DEF_RoadSignID_tags_1)
		/sizeof(asn_DEF_RoadSignID_tags_1[0]), /* 1 */
	asn_DEF_RoadSignID_tags_1,	/* Same as above */
	sizeof(asn_DEF_RoadSignID_tags_1)
		/sizeof(asn_DEF_RoadSignID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RoadSignID_1,
	4,	/* Elements count */
	&asn_SPC_RoadSignID_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RTCMHeader] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [RTCMHeader] >>> ***/

typedef OCTET_STRING_t	 RTCMHeader_t;

/*** <<< FUNC-DECLS [RTCMHeader] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCMHeader;
asn_struct_free_f RTCMHeader_free;
asn_struct_print_f RTCMHeader_print;
asn_constr_check_f RTCMHeader_constraint;
ber_type_decoder_f RTCMHeader_decode_ber;
der_type_encoder_f RTCMHeader_encode_der;
xer_type_decoder_f RTCMHeader_decode_xer;
xer_type_encoder_f RTCMHeader_encode_xer;

/*** <<< CODE [RTCMHeader] >>> ***/

int
RTCMHeader_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 5)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
RTCMHeader_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
RTCMHeader_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	RTCMHeader_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
RTCMHeader_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	RTCMHeader_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
RTCMHeader_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	RTCMHeader_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
RTCMHeader_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCMHeader_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
RTCMHeader_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	RTCMHeader_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
RTCMHeader_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCMHeader_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [RTCMHeader] >>> ***/

static ber_tlv_tag_t asn_DEF_RTCMHeader_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_RTCMHeader = {
	"RTCMHeader",
	"RTCMHeader",
	RTCMHeader_free,
	RTCMHeader_print,
	RTCMHeader_constraint,
	RTCMHeader_decode_ber,
	RTCMHeader_encode_der,
	RTCMHeader_decode_xer,
	RTCMHeader_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCMHeader_tags_1,
	sizeof(asn_DEF_RTCMHeader_tags_1)
		/sizeof(asn_DEF_RTCMHeader_tags_1[0]), /* 1 */
	asn_DEF_RTCMHeader_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCMHeader_tags_1)
		/sizeof(asn_DEF_RTCMHeader_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [RTCMmsg] >>> ***/

#include "RTCM-Revision.h"
#include "RTCM-ID.h"
#include "RTCM-Payload.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [RTCMmsg] >>> ***/

typedef struct RTCMmsg {
	RTCM_Revision_t	*rev	/* OPTIONAL */;
	RTCM_ID_t	*rtcmID	/* OPTIONAL */;
	RTCM_Payload_t	 payload;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RTCMmsg_t;

/*** <<< FUNC-DECLS [RTCMmsg] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCMmsg;

/*** <<< STAT-DEFS [RTCMmsg] >>> ***/

static asn_TYPE_member_t asn_MBR_RTCMmsg_1[] = {
	{ ATF_POINTER, 2, offsetof(struct RTCMmsg, rev),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_Revision,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rev"
		},
	{ ATF_POINTER, 1, offsetof(struct RTCMmsg, rtcmID),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_ID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rtcmID"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RTCMmsg, payload),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCM_Payload,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "payload"
		},
};
static ber_tlv_tag_t asn_DEF_RTCMmsg_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RTCMmsg_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* rev */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rtcmID */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* payload */
};
static asn_SEQUENCE_specifics_t asn_SPC_RTCMmsg_specs_1 = {
	sizeof(struct RTCMmsg),
	offsetof(struct RTCMmsg, _asn_ctx),
	asn_MAP_RTCMmsg_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	2,	/* Start extensions */
	4	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RTCMmsg = {
	"RTCMmsg",
	"RTCMmsg",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCMmsg_tags_1,
	sizeof(asn_DEF_RTCMmsg_tags_1)
		/sizeof(asn_DEF_RTCMmsg_tags_1[0]), /* 1 */
	asn_DEF_RTCMmsg_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCMmsg_tags_1)
		/sizeof(asn_DEF_RTCMmsg_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RTCMmsg_1,
	3,	/* Elements count */
	&asn_SPC_RTCMmsg_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RTCMPackage] >>> ***/

#include "RTCMHeader.h"
#include <OCTET_STRING.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [RTCMPackage] >>> ***/

struct FullPositionVector;

/*** <<< TYPE-DECLS [RTCMPackage] >>> ***/

typedef struct RTCMPackage {
	struct FullPositionVector	*anchorPoint	/* OPTIONAL */;
	RTCMHeader_t	 rtcmHeader;
	OCTET_STRING_t	*msg1001	/* OPTIONAL */;
	OCTET_STRING_t	*msg1002	/* OPTIONAL */;
	OCTET_STRING_t	*msg1003	/* OPTIONAL */;
	OCTET_STRING_t	*msg1004	/* OPTIONAL */;
	OCTET_STRING_t	*msg1005	/* OPTIONAL */;
	OCTET_STRING_t	*msg1006	/* OPTIONAL */;
	OCTET_STRING_t	*msg1007	/* OPTIONAL */;
	OCTET_STRING_t	*msg1008	/* OPTIONAL */;
	OCTET_STRING_t	*msg1009	/* OPTIONAL */;
	OCTET_STRING_t	*msg1010	/* OPTIONAL */;
	OCTET_STRING_t	*msg1011	/* OPTIONAL */;
	OCTET_STRING_t	*msg1012	/* OPTIONAL */;
	OCTET_STRING_t	*msg1013	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	OCTET_STRING_t	*msg1014	/* OPTIONAL */;
	OCTET_STRING_t	*msg1015	/* OPTIONAL */;
	OCTET_STRING_t	*msg1016	/* OPTIONAL */;
	OCTET_STRING_t	*msg1017	/* OPTIONAL */;
	OCTET_STRING_t	*msg1019	/* OPTIONAL */;
	OCTET_STRING_t	*msg1020	/* OPTIONAL */;
	OCTET_STRING_t	*msg1021	/* OPTIONAL */;
	OCTET_STRING_t	*msg1022	/* OPTIONAL */;
	OCTET_STRING_t	*msg1023	/* OPTIONAL */;
	OCTET_STRING_t	*msg1024	/* OPTIONAL */;
	OCTET_STRING_t	*msg1025	/* OPTIONAL */;
	OCTET_STRING_t	*msg1026	/* OPTIONAL */;
	OCTET_STRING_t	*msg1027	/* OPTIONAL */;
	OCTET_STRING_t	*msg1029	/* OPTIONAL */;
	OCTET_STRING_t	*msg1030	/* OPTIONAL */;
	OCTET_STRING_t	*msg1031	/* OPTIONAL */;
	OCTET_STRING_t	*msg1032	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} RTCMPackage_t;

/*** <<< FUNC-DECLS [RTCMPackage] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCMPackage;

/*** <<< POST-INCLUDE [RTCMPackage] >>> ***/

#include "FullPositionVector.h"

/*** <<< CODE [RTCMPackage] >>> ***/

static int
memb_msg1001_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 16 && size <= 124)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1002_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 18 && size <= 156)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1003_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 21 && size <= 210)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1004_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 24 && size <= 258)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1005_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 19)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1006_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 21)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1007_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 5 && size <= 36)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1008_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 6 && size <= 68)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1009_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 16 && size <= 136)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1010_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 18 && size <= 166)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1011_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 21 && size <= 222)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1012_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 24 && size <= 268)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1013_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 13 && size <= 27)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1014_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 15)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1015_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 13 && size <= 69)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1016_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 14 && size <= 81)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1017_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 16 && size <= 115)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1019_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 62)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1020_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 45)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1021_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 62)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1022_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 75)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1023_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 73)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1024_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 74)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1025_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 25)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1026_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 30)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1027_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 33)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1029_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 10 && size <= 69)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1030_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 14 && size <= 105)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1031_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 15 && size <= 107)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_msg1032_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 20)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [RTCMPackage] >>> ***/

static asn_TYPE_member_t asn_MBR_RTCMPackage_1[] = {
	{ ATF_POINTER, 1, offsetof(struct RTCMPackage, anchorPoint),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "anchorPoint"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RTCMPackage, rtcmHeader),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCMHeader,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rtcmHeader"
		},
	{ ATF_POINTER, 30, offsetof(struct RTCMPackage, msg1001),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1001_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1001"
		},
	{ ATF_POINTER, 29, offsetof(struct RTCMPackage, msg1002),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1002_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1002"
		},
	{ ATF_POINTER, 28, offsetof(struct RTCMPackage, msg1003),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1003_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1003"
		},
	{ ATF_POINTER, 27, offsetof(struct RTCMPackage, msg1004),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1004_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1004"
		},
	{ ATF_POINTER, 26, offsetof(struct RTCMPackage, msg1005),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1005_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1005"
		},
	{ ATF_POINTER, 25, offsetof(struct RTCMPackage, msg1006),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1006_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1006"
		},
	{ ATF_POINTER, 24, offsetof(struct RTCMPackage, msg1007),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1007_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1007"
		},
	{ ATF_POINTER, 23, offsetof(struct RTCMPackage, msg1008),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1008_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1008"
		},
	{ ATF_POINTER, 22, offsetof(struct RTCMPackage, msg1009),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1009_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1009"
		},
	{ ATF_POINTER, 21, offsetof(struct RTCMPackage, msg1010),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1010_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1010"
		},
	{ ATF_POINTER, 20, offsetof(struct RTCMPackage, msg1011),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1011_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1011"
		},
	{ ATF_POINTER, 19, offsetof(struct RTCMPackage, msg1012),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1012_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1012"
		},
	{ ATF_POINTER, 18, offsetof(struct RTCMPackage, msg1013),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1013_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1013"
		},
	{ ATF_POINTER, 17, offsetof(struct RTCMPackage, msg1014),
		.tag = (ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1014_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1014"
		},
	{ ATF_POINTER, 16, offsetof(struct RTCMPackage, msg1015),
		.tag = (ASN_TAG_CLASS_CONTEXT | (16 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1015_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1015"
		},
	{ ATF_POINTER, 15, offsetof(struct RTCMPackage, msg1016),
		.tag = (ASN_TAG_CLASS_CONTEXT | (17 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1016_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1016"
		},
	{ ATF_POINTER, 14, offsetof(struct RTCMPackage, msg1017),
		.tag = (ASN_TAG_CLASS_CONTEXT | (18 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1017_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1017"
		},
	{ ATF_POINTER, 13, offsetof(struct RTCMPackage, msg1019),
		.tag = (ASN_TAG_CLASS_CONTEXT | (19 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1019_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1019"
		},
	{ ATF_POINTER, 12, offsetof(struct RTCMPackage, msg1020),
		.tag = (ASN_TAG_CLASS_CONTEXT | (20 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1020_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1020"
		},
	{ ATF_POINTER, 11, offsetof(struct RTCMPackage, msg1021),
		.tag = (ASN_TAG_CLASS_CONTEXT | (21 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1021_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1021"
		},
	{ ATF_POINTER, 10, offsetof(struct RTCMPackage, msg1022),
		.tag = (ASN_TAG_CLASS_CONTEXT | (22 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1022_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1022"
		},
	{ ATF_POINTER, 9, offsetof(struct RTCMPackage, msg1023),
		.tag = (ASN_TAG_CLASS_CONTEXT | (23 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1023_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1023"
		},
	{ ATF_POINTER, 8, offsetof(struct RTCMPackage, msg1024),
		.tag = (ASN_TAG_CLASS_CONTEXT | (24 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1024_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1024"
		},
	{ ATF_POINTER, 7, offsetof(struct RTCMPackage, msg1025),
		.tag = (ASN_TAG_CLASS_CONTEXT | (25 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1025_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1025"
		},
	{ ATF_POINTER, 6, offsetof(struct RTCMPackage, msg1026),
		.tag = (ASN_TAG_CLASS_CONTEXT | (26 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1026_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1026"
		},
	{ ATF_POINTER, 5, offsetof(struct RTCMPackage, msg1027),
		.tag = (ASN_TAG_CLASS_CONTEXT | (27 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1027_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1027"
		},
	{ ATF_POINTER, 4, offsetof(struct RTCMPackage, msg1029),
		.tag = (ASN_TAG_CLASS_CONTEXT | (28 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1029_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1029"
		},
	{ ATF_POINTER, 3, offsetof(struct RTCMPackage, msg1030),
		.tag = (ASN_TAG_CLASS_CONTEXT | (29 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1030_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1030"
		},
	{ ATF_POINTER, 2, offsetof(struct RTCMPackage, msg1031),
		.tag = (ASN_TAG_CLASS_CONTEXT | (30 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1031_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1031"
		},
	{ ATF_POINTER, 1, offsetof(struct RTCMPackage, msg1032),
		.tag = (ASN_TAG_CLASS_CONTEXT | (31 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.memb_constraints = memb_msg1032_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "msg1032"
		},
};
static ber_tlv_tag_t asn_DEF_RTCMPackage_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_RTCMPackage_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* anchorPoint */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rtcmHeader */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* msg1001 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* msg1002 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* msg1003 */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* msg1004 */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* msg1005 */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* msg1006 */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* msg1007 */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* msg1008 */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* msg1009 */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* msg1010 */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* msg1011 */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* msg1012 */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* msg1013 */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 }, /* msg1014 */
    { (ASN_TAG_CLASS_CONTEXT | (16 << 2)), 16, 0, 0 }, /* msg1015 */
    { (ASN_TAG_CLASS_CONTEXT | (17 << 2)), 17, 0, 0 }, /* msg1016 */
    { (ASN_TAG_CLASS_CONTEXT | (18 << 2)), 18, 0, 0 }, /* msg1017 */
    { (ASN_TAG_CLASS_CONTEXT | (19 << 2)), 19, 0, 0 }, /* msg1019 */
    { (ASN_TAG_CLASS_CONTEXT | (20 << 2)), 20, 0, 0 }, /* msg1020 */
    { (ASN_TAG_CLASS_CONTEXT | (21 << 2)), 21, 0, 0 }, /* msg1021 */
    { (ASN_TAG_CLASS_CONTEXT | (22 << 2)), 22, 0, 0 }, /* msg1022 */
    { (ASN_TAG_CLASS_CONTEXT | (23 << 2)), 23, 0, 0 }, /* msg1023 */
    { (ASN_TAG_CLASS_CONTEXT | (24 << 2)), 24, 0, 0 }, /* msg1024 */
    { (ASN_TAG_CLASS_CONTEXT | (25 << 2)), 25, 0, 0 }, /* msg1025 */
    { (ASN_TAG_CLASS_CONTEXT | (26 << 2)), 26, 0, 0 }, /* msg1026 */
    { (ASN_TAG_CLASS_CONTEXT | (27 << 2)), 27, 0, 0 }, /* msg1027 */
    { (ASN_TAG_CLASS_CONTEXT | (28 << 2)), 28, 0, 0 }, /* msg1029 */
    { (ASN_TAG_CLASS_CONTEXT | (29 << 2)), 29, 0, 0 }, /* msg1030 */
    { (ASN_TAG_CLASS_CONTEXT | (30 << 2)), 30, 0, 0 }, /* msg1031 */
    { (ASN_TAG_CLASS_CONTEXT | (31 << 2)), 31, 0, 0 } /* msg1032 */
};
static asn_SEQUENCE_specifics_t asn_SPC_RTCMPackage_specs_1 = {
	sizeof(struct RTCMPackage),
	offsetof(struct RTCMPackage, _asn_ctx),
	asn_MAP_RTCMPackage_tag2el_1,
	32,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	14,	/* Start extensions */
	33	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RTCMPackage = {
	"RTCMPackage",
	"RTCMPackage",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCMPackage_tags_1,
	sizeof(asn_DEF_RTCMPackage_tags_1)
		/sizeof(asn_DEF_RTCMPackage_tags_1[0]), /* 1 */
	asn_DEF_RTCMPackage_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCMPackage_tags_1)
		/sizeof(asn_DEF_RTCMPackage_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RTCMPackage_1,
	32,	/* Elements count */
	&asn_SPC_RTCMPackage_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Sample] >>> ***/

#include <NativeInteger.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [Sample] >>> ***/

typedef struct Sample {
	long	 sampleStart;
	long	 sampleEnd;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Sample_t;

/*** <<< FUNC-DECLS [Sample] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Sample;

/*** <<< CODE [Sample] >>> ***/

static int
memb_sampleStart_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_sampleEnd_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [Sample] >>> ***/

static asn_TYPE_member_t asn_MBR_Sample_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Sample, sampleStart),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_sampleStart_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sampleStart"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sample, sampleEnd),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_sampleEnd_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sampleEnd"
		},
};
static ber_tlv_tag_t asn_DEF_Sample_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Sample_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* sampleStart */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* sampleEnd */
};
static asn_SEQUENCE_specifics_t asn_SPC_Sample_specs_1 = {
	sizeof(struct Sample),
	offsetof(struct Sample, _asn_ctx),
	asn_MAP_Sample_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Sample = {
	"Sample",
	"Sample",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Sample_tags_1,
	sizeof(asn_DEF_Sample_tags_1)
		/sizeof(asn_DEF_Sample_tags_1[0]), /* 1 */
	asn_DEF_Sample_tags_1,	/* Same as above */
	sizeof(asn_DEF_Sample_tags_1)
		/sizeof(asn_DEF_Sample_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Sample_1,
	2,	/* Elements count */
	&asn_SPC_Sample_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ShapePointSet] >>> ***/

#include "LaneWidth.h"
#include "DirectionOfUse.h"
#include "NodeList.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [ShapePointSet] >>> ***/

struct Position3D;

/*** <<< TYPE-DECLS [ShapePointSet] >>> ***/

typedef struct ShapePointSet {
	struct Position3D	*anchor	/* OPTIONAL */;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	DirectionOfUse_t	*directionality	/* OPTIONAL */;
	NodeList_t	 nodeList;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ShapePointSet_t;

/*** <<< FUNC-DECLS [ShapePointSet] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ShapePointSet;

/*** <<< POST-INCLUDE [ShapePointSet] >>> ***/

#include "Position3D.h"

/*** <<< STAT-DEFS [ShapePointSet] >>> ***/

static asn_TYPE_member_t asn_MBR_ShapePointSet_1[] = {
	{ ATF_POINTER, 3, offsetof(struct ShapePointSet, anchor),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Position3D,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "anchor"
		},
	{ ATF_POINTER, 2, offsetof(struct ShapePointSet, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_POINTER, 1, offsetof(struct ShapePointSet, directionality),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DirectionOfUse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "directionality"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ShapePointSet, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
};
static ber_tlv_tag_t asn_DEF_ShapePointSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ShapePointSet_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* anchor */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* directionality */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* nodeList */
};
static asn_SEQUENCE_specifics_t asn_SPC_ShapePointSet_specs_1 = {
	sizeof(struct ShapePointSet),
	offsetof(struct ShapePointSet, _asn_ctx),
	asn_MAP_ShapePointSet_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ShapePointSet = {
	"ShapePointSet",
	"ShapePointSet",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ShapePointSet_tags_1,
	sizeof(asn_DEF_ShapePointSet_tags_1)
		/sizeof(asn_DEF_ShapePointSet_tags_1[0]), /* 1 */
	asn_DEF_ShapePointSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_ShapePointSet_tags_1)
		/sizeof(asn_DEF_ShapePointSet_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ShapePointSet_1,
	4,	/* Elements count */
	&asn_SPC_ShapePointSet_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SignalControlZone] >>> ***/

#include "DescriptiveName.h"
#include "SignalReqScheme.h"
#include "LaneNumber.h"
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include "LaneWidth.h"
#include "NodeList.h"
#include <constr_SEQUENCE.h>
#include <constr_CHOICE.h>

/*** <<< DEPS [SignalControlZone] >>> ***/

typedef enum data_PR {
	data_PR_NOTHING,	/* No components present */
	data_PR_laneSet,
	data_PR_zones
} data_PR;

/*** <<< TYPE-DECLS [SignalControlZone] >>> ***/

typedef struct SignalControlZone {
	DescriptiveName_t	*name	/* OPTIONAL */;
	SignalReqScheme_t	 pValue;
	struct data {
		data_PR present;
		union SignalControlZone__data_u {
			struct laneSet {
				A_SEQUENCE_OF(LaneNumber_t) list;
				
				/* Context for parsing across buffer boundaries */
				asn_struct_ctx_t _asn_ctx;
			} laneSet;
			struct zones {
				A_SEQUENCE_OF(struct Member {
					struct enclosed {
						A_SEQUENCE_OF(LaneNumber_t) list;
						
						/* Context for parsing across buffer boundaries */
						asn_struct_ctx_t _asn_ctx;
					} *enclosed;
					LaneWidth_t	*laneWidth	/* OPTIONAL */;
					NodeList_t	 nodeList;
					/*
					 * This type is extensible,
					 * possible extensions are below.
					 */
					
					/* Context for parsing across buffer boundaries */
					asn_struct_ctx_t _asn_ctx;
				} ) list;
				
				/* Context for parsing across buffer boundaries */
				asn_struct_ctx_t _asn_ctx;
			} zones;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} data;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SignalControlZone_t;

/*** <<< FUNC-DECLS [SignalControlZone] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalControlZone;

/*** <<< CODE [SignalControlZone] >>> ***/

static int
memb_enclosed_constraint_8(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_laneSet_constraint_4(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_zones_constraint_4(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Determine the number of elements */
	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
	
	if((size >= 1 && size <= 32)) {
		/* Perform validation of the inner elements */
		return td->check_constraints(td, sptr, ctfailcb, app_key);
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [SignalControlZone] >>> ***/

static asn_TYPE_member_t asn_MBR_laneSet_5[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_laneSet_tags_5[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_laneSet_specs_5 = {
	sizeof(struct laneSet),
	offsetof(struct laneSet, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_laneSet_5 = {
	"laneSet",
	"laneSet",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_laneSet_tags_5,
	sizeof(asn_DEF_laneSet_tags_5)
		/sizeof(asn_DEF_laneSet_tags_5[0]) - 1, /* 1 */
	asn_DEF_laneSet_tags_5,	/* Same as above */
	sizeof(asn_DEF_laneSet_tags_5)
		/sizeof(asn_DEF_laneSet_tags_5[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_laneSet_5,
	1,	/* Single element */
	&asn_SPC_laneSet_specs_5	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_enclosed_9[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_enclosed_tags_9[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_enclosed_specs_9 = {
	sizeof(struct enclosed),
	offsetof(struct enclosed, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_enclosed_9 = {
	"enclosed",
	"enclosed",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_enclosed_tags_9,
	sizeof(asn_DEF_enclosed_tags_9)
		/sizeof(asn_DEF_enclosed_tags_9[0]) - 1, /* 1 */
	asn_DEF_enclosed_tags_9,	/* Same as above */
	sizeof(asn_DEF_enclosed_tags_9)
		/sizeof(asn_DEF_enclosed_tags_9[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_enclosed_9,
	1,	/* Single element */
	&asn_SPC_enclosed_specs_9	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_8[] = {
	{ ATF_POINTER, 2, offsetof(struct Member, enclosed),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_enclosed_9,
		.memb_constraints = memb_enclosed_constraint_8,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "enclosed"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_8[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_8[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* enclosed */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* nodeList */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_8 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_8,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	2,	/* Start extensions */
	4	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_8 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_8,
	sizeof(asn_DEF_Member_tags_8)
		/sizeof(asn_DEF_Member_tags_8[0]), /* 1 */
	asn_DEF_Member_tags_8,	/* Same as above */
	sizeof(asn_DEF_Member_tags_8)
		/sizeof(asn_DEF_Member_tags_8[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_8,
	3,	/* Elements count */
	&asn_SPC_Member_specs_8	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_zones_7[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_8,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_zones_tags_7[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_zones_specs_7 = {
	sizeof(struct zones),
	offsetof(struct zones, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_zones_7 = {
	"zones",
	"zones",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_zones_tags_7,
	sizeof(asn_DEF_zones_tags_7)
		/sizeof(asn_DEF_zones_tags_7[0]) - 1, /* 1 */
	asn_DEF_zones_tags_7,	/* Same as above */
	sizeof(asn_DEF_zones_tags_7)
		/sizeof(asn_DEF_zones_tags_7[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_zones_7,
	1,	/* Single element */
	&asn_SPC_zones_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_data_4[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct data, choice.laneSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_laneSet_5,
		.memb_constraints = memb_laneSet_constraint_4,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneSet"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct data, choice.zones),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_zones_7,
		.memb_constraints = memb_zones_constraint_4,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "zones"
		},
};
static asn_TYPE_tag2member_t asn_MAP_data_tag2el_4[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* laneSet */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* zones */
};
static asn_CHOICE_specifics_t asn_SPC_data_specs_4 = {
	sizeof(struct data),
	offsetof(struct data, _asn_ctx),
	offsetof(struct data, present),
	sizeof(((struct data *)0)->present),
	asn_MAP_data_tag2el_4,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_data_4 = {
	"data",
	"data",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_data_4,
	2,	/* Elements count */
	&asn_SPC_data_specs_4	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_SignalControlZone_1[] = {
	{ ATF_POINTER, 1, offsetof(struct SignalControlZone, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalControlZone, pValue),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalReqScheme,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pValue"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalControlZone, data),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_data_4,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "data"
		},
};
static ber_tlv_tag_t asn_DEF_SignalControlZone_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SignalControlZone_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* pValue */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* data */
};
static asn_SEQUENCE_specifics_t asn_SPC_SignalControlZone_specs_1 = {
	sizeof(struct SignalControlZone),
	offsetof(struct SignalControlZone, _asn_ctx),
	asn_MAP_SignalControlZone_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	2,	/* Start extensions */
	4	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SignalControlZone = {
	"SignalControlZone",
	"SignalControlZone",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalControlZone_tags_1,
	sizeof(asn_DEF_SignalControlZone_tags_1)
		/sizeof(asn_DEF_SignalControlZone_tags_1[0]), /* 1 */
	asn_DEF_SignalControlZone_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalControlZone_tags_1)
		/sizeof(asn_DEF_SignalControlZone_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SignalControlZone_1,
	3,	/* Elements count */
	&asn_SPC_SignalControlZone_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SignalRequest] >>> ***/

#include "IntersectionID.h"
#include "SignalReqScheme.h"
#include "LaneNumber.h"
#include "NTCIPVehicleclass.h"
#include "CodeWord.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [SignalRequest] >>> ***/

typedef struct SignalRequest {
	IntersectionID_t	 id;
	SignalReqScheme_t	*isCancel	/* OPTIONAL */;
	SignalReqScheme_t	*requestedAction	/* OPTIONAL */;
	LaneNumber_t	*inLane	/* OPTIONAL */;
	LaneNumber_t	*outLane	/* OPTIONAL */;
	NTCIPVehicleclass_t	 type;
	CodeWord_t	*codeWord	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SignalRequest_t;

/*** <<< FUNC-DECLS [SignalRequest] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalRequest;

/*** <<< STAT-DEFS [SignalRequest] >>> ***/

static asn_TYPE_member_t asn_MBR_SignalRequest_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SignalRequest, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IntersectionID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_POINTER, 4, offsetof(struct SignalRequest, isCancel),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalReqScheme,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "isCancel"
		},
	{ ATF_POINTER, 3, offsetof(struct SignalRequest, requestedAction),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SignalReqScheme,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "requestedAction"
		},
	{ ATF_POINTER, 2, offsetof(struct SignalRequest, inLane),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "inLane"
		},
	{ ATF_POINTER, 1, offsetof(struct SignalRequest, outLane),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "outLane"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SignalRequest, type),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NTCIPVehicleclass,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "type"
		},
	{ ATF_POINTER, 1, offsetof(struct SignalRequest, codeWord),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CodeWord,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "codeWord"
		},
};
static ber_tlv_tag_t asn_DEF_SignalRequest_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SignalRequest_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* isCancel */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* requestedAction */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* inLane */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* outLane */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* type */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 } /* codeWord */
};
static asn_SEQUENCE_specifics_t asn_SPC_SignalRequest_specs_1 = {
	sizeof(struct SignalRequest),
	offsetof(struct SignalRequest, _asn_ctx),
	asn_MAP_SignalRequest_tag2el_1,
	7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	6,	/* Start extensions */
	8	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SignalRequest = {
	"SignalRequest",
	"SignalRequest",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalRequest_tags_1,
	sizeof(asn_DEF_SignalRequest_tags_1)
		/sizeof(asn_DEF_SignalRequest_tags_1[0]), /* 1 */
	asn_DEF_SignalRequest_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalRequest_tags_1)
		/sizeof(asn_DEF_SignalRequest_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SignalRequest_1,
	7,	/* Elements count */
	&asn_SPC_SignalRequest_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Snapshot] >>> ***/

#include "FullPositionVector.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Snapshot] >>> ***/

struct VehicleSafetyExtension;
struct VehicleStatus;

/*** <<< TYPE-DECLS [Snapshot] >>> ***/

typedef struct Snapshot {
	FullPositionVector_t	 thePosition;
	struct VehicleSafetyExtension	*safetyExt	/* OPTIONAL */;
	struct VehicleStatus	*datSet	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Snapshot_t;

/*** <<< FUNC-DECLS [Snapshot] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Snapshot;

/*** <<< POST-INCLUDE [Snapshot] >>> ***/

#include "VehicleSafetyExtension.h"
#include "VehicleStatus.h"

/*** <<< STAT-DEFS [Snapshot] >>> ***/

static asn_TYPE_member_t asn_MBR_Snapshot_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Snapshot, thePosition),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "thePosition"
		},
	{ ATF_POINTER, 2, offsetof(struct Snapshot, safetyExt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleSafetyExtension,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "safetyExt"
		},
	{ ATF_POINTER, 1, offsetof(struct Snapshot, datSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "datSet"
		},
};
static ber_tlv_tag_t asn_DEF_Snapshot_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Snapshot_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* thePosition */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* safetyExt */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* datSet */
};
static asn_SEQUENCE_specifics_t asn_SPC_Snapshot_specs_1 = {
	sizeof(struct Snapshot),
	offsetof(struct Snapshot, _asn_ctx),
	asn_MAP_Snapshot_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	2,	/* Start extensions */
	4	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Snapshot = {
	"Snapshot",
	"Snapshot",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Snapshot_tags_1,
	sizeof(asn_DEF_Snapshot_tags_1)
		/sizeof(asn_DEF_Snapshot_tags_1[0]), /* 1 */
	asn_DEF_Snapshot_tags_1,	/* Same as above */
	sizeof(asn_DEF_Snapshot_tags_1)
		/sizeof(asn_DEF_Snapshot_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Snapshot_1,
	3,	/* Elements count */
	&asn_SPC_Snapshot_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SnapshotDistance] >>> ***/

#include <NativeInteger.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [SnapshotDistance] >>> ***/

typedef struct SnapshotDistance {
	long	 d1;
	long	 s1;
	long	 d2;
	long	 s2;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SnapshotDistance_t;

/*** <<< FUNC-DECLS [SnapshotDistance] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SnapshotDistance;

/*** <<< CODE [SnapshotDistance] >>> ***/

static int
memb_d1_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 999)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_s1_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 50)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_d2_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 999)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_s2_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 50)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [SnapshotDistance] >>> ***/

static asn_TYPE_member_t asn_MBR_SnapshotDistance_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotDistance, d1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_d1_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "d1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotDistance, s1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_s1_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "s1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotDistance, d2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_d2_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "d2"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotDistance, s2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_s2_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "s2"
		},
};
static ber_tlv_tag_t asn_DEF_SnapshotDistance_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SnapshotDistance_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* d1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* s1 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* d2 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* s2 */
};
static asn_SEQUENCE_specifics_t asn_SPC_SnapshotDistance_specs_1 = {
	sizeof(struct SnapshotDistance),
	offsetof(struct SnapshotDistance, _asn_ctx),
	asn_MAP_SnapshotDistance_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SnapshotDistance = {
	"SnapshotDistance",
	"SnapshotDistance",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SnapshotDistance_tags_1,
	sizeof(asn_DEF_SnapshotDistance_tags_1)
		/sizeof(asn_DEF_SnapshotDistance_tags_1[0]), /* 1 */
	asn_DEF_SnapshotDistance_tags_1,	/* Same as above */
	sizeof(asn_DEF_SnapshotDistance_tags_1)
		/sizeof(asn_DEF_SnapshotDistance_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SnapshotDistance_1,
	4,	/* Elements count */
	&asn_SPC_SnapshotDistance_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SnapshotTime] >>> ***/

#include <NativeInteger.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [SnapshotTime] >>> ***/

typedef struct SnapshotTime {
	long	 t1;
	long	 s1;
	long	 t2;
	long	 s2;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SnapshotTime_t;

/*** <<< FUNC-DECLS [SnapshotTime] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SnapshotTime;

/*** <<< CODE [SnapshotTime] >>> ***/

static int
memb_t1_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 99)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_s1_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 50)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_t2_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 99)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_s2_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 50)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [SnapshotTime] >>> ***/

static asn_TYPE_member_t asn_MBR_SnapshotTime_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotTime, t1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_t1_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "t1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotTime, s1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_s1_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "s1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotTime, t2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_t2_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "t2"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SnapshotTime, s2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_s2_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "s2"
		},
};
static ber_tlv_tag_t asn_DEF_SnapshotTime_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SnapshotTime_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* t1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* s1 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* t2 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* s2 */
};
static asn_SEQUENCE_specifics_t asn_SPC_SnapshotTime_specs_1 = {
	sizeof(struct SnapshotTime),
	offsetof(struct SnapshotTime, _asn_ctx),
	asn_MAP_SnapshotTime_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SnapshotTime = {
	"SnapshotTime",
	"SnapshotTime",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SnapshotTime_tags_1,
	sizeof(asn_DEF_SnapshotTime_tags_1)
		/sizeof(asn_DEF_SnapshotTime_tags_1[0]), /* 1 */
	asn_DEF_SnapshotTime_tags_1,	/* Same as above */
	sizeof(asn_DEF_SnapshotTime_tags_1)
		/sizeof(asn_DEF_SnapshotTime_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SnapshotTime_1,
	4,	/* Elements count */
	&asn_SPC_SnapshotTime_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SpecialLane] >>> ***/

#include "LaneNumber.h"
#include "LaneWidth.h"
#include "SpecialLaneAttributes.h"
#include "NodeList.h"
#include "ConnectsTo.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [SpecialLane] >>> ***/

struct NodeList;

/*** <<< TYPE-DECLS [SpecialLane] >>> ***/

typedef struct SpecialLane {
	LaneNumber_t	 laneNumber;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	SpecialLaneAttributes_t	 laneAttributes;
	NodeList_t	 nodeList;
	struct NodeList	*keepOutList	/* OPTIONAL */;
	ConnectsTo_t	*connectsTo	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SpecialLane_t;

/*** <<< FUNC-DECLS [SpecialLane] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SpecialLane;

/*** <<< POST-INCLUDE [SpecialLane] >>> ***/

#include "NodeList.h"

/*** <<< STAT-DEFS [SpecialLane] >>> ***/

static asn_TYPE_member_t asn_MBR_SpecialLane_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SpecialLane, laneNumber),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneNumber"
		},
	{ ATF_POINTER, 1, offsetof(struct SpecialLane, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SpecialLane, laneAttributes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpecialLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneAttributes"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SpecialLane, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
	{ ATF_POINTER, 2, offsetof(struct SpecialLane, keepOutList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "keepOutList"
		},
	{ ATF_POINTER, 1, offsetof(struct SpecialLane, connectsTo),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConnectsTo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "connectsTo"
		},
};
static ber_tlv_tag_t asn_DEF_SpecialLane_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_SpecialLane_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* laneNumber */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* laneAttributes */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* nodeList */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* keepOutList */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* connectsTo */
};
static asn_SEQUENCE_specifics_t asn_SPC_SpecialLane_specs_1 = {
	sizeof(struct SpecialLane),
	offsetof(struct SpecialLane, _asn_ctx),
	asn_MAP_SpecialLane_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_SpecialLane = {
	"SpecialLane",
	"SpecialLane",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SpecialLane_tags_1,
	sizeof(asn_DEF_SpecialLane_tags_1)
		/sizeof(asn_DEF_SpecialLane_tags_1[0]), /* 1 */
	asn_DEF_SpecialLane_tags_1,	/* Same as above */
	sizeof(asn_DEF_SpecialLane_tags_1)
		/sizeof(asn_DEF_SpecialLane_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SpecialLane_1,
	6,	/* Elements count */
	&asn_SPC_SpecialLane_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SpeedandHeadingandThrottleConfidence] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [SpeedandHeadingandThrottleConfidence] >>> ***/

typedef OCTET_STRING_t	 SpeedandHeadingandThrottleConfidence_t;

/*** <<< FUNC-DECLS [SpeedandHeadingandThrottleConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SpeedandHeadingandThrottleConfidence;
asn_struct_free_f SpeedandHeadingandThrottleConfidence_free;
asn_struct_print_f SpeedandHeadingandThrottleConfidence_print;
asn_constr_check_f SpeedandHeadingandThrottleConfidence_constraint;
ber_type_decoder_f SpeedandHeadingandThrottleConfidence_decode_ber;
der_type_encoder_f SpeedandHeadingandThrottleConfidence_encode_der;
xer_type_decoder_f SpeedandHeadingandThrottleConfidence_decode_xer;
xer_type_encoder_f SpeedandHeadingandThrottleConfidence_encode_xer;

/*** <<< CODE [SpeedandHeadingandThrottleConfidence] >>> ***/

int
SpeedandHeadingandThrottleConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
SpeedandHeadingandThrottleConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SpeedandHeadingandThrottleConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SpeedandHeadingandThrottleConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SpeedandHeadingandThrottleConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SpeedandHeadingandThrottleConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SpeedandHeadingandThrottleConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpeedandHeadingandThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SpeedandHeadingandThrottleConfidence] >>> ***/

static ber_tlv_tag_t asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SpeedandHeadingandThrottleConfidence = {
	"SpeedandHeadingandThrottleConfidence",
	"SpeedandHeadingandThrottleConfidence",
	SpeedandHeadingandThrottleConfidence_free,
	SpeedandHeadingandThrottleConfidence_print,
	SpeedandHeadingandThrottleConfidence_constraint,
	SpeedandHeadingandThrottleConfidence_decode_ber,
	SpeedandHeadingandThrottleConfidence_encode_der,
	SpeedandHeadingandThrottleConfidence_decode_xer,
	SpeedandHeadingandThrottleConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1,
	sizeof(asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1)
		/sizeof(asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1[0]), /* 1 */
	asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1)
		/sizeof(asn_DEF_SpeedandHeadingandThrottleConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SpeedLimit] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include "ITIScodes.h"
#include <IA5String.h>
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< DEPS [SpeedLimit] >>> ***/

typedef enum item_PR {
	item_PR_NOTHING,	/* No components present */
	item_PR_itis,
	item_PR_text
} item_PR;

/*** <<< TYPE-DECLS [SpeedLimit] >>> ***/

typedef struct SpeedLimit {
	A_SEQUENCE_OF(struct Member {
		struct item {
			item_PR present;
			union item_u {
				ITIScodes_t	 itis;
				IA5String_t	 text;
			} choice;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} item;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SpeedLimit_t;

/*** <<< FUNC-DECLS [SpeedLimit] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SpeedLimit;

/*** <<< CTABLES [SpeedLimit] >>> ***/

static int check_permitted_alphabet_5(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [SpeedLimit] >>> ***/

static int
memb_text_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 16)
		 && !check_permitted_alphabet_5(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [SpeedLimit] >>> ***/

static asn_TYPE_member_t asn_MBR_item_3[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.itis),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "itis"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.text),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_text_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "text"
		},
};
static asn_TYPE_tag2member_t asn_MAP_item_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* itis */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* text */
};
static asn_CHOICE_specifics_t asn_SPC_item_specs_3 = {
	sizeof(struct item),
	offsetof(struct item, _asn_ctx),
	offsetof(struct item, present),
	sizeof(((struct item *)0)->present),
	asn_MAP_item_tag2el_3,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_item_3 = {
	"item",
	"item",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_item_3,
	2,	/* Elements count */
	&asn_SPC_item_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, item),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_item_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* item */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_2 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_2,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_2,
	1,	/* Elements count */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_SpeedLimit_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_SpeedLimit_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_SpeedLimit_specs_1 = {
	sizeof(struct SpeedLimit),
	offsetof(struct SpeedLimit, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_SpeedLimit = {
	"SpeedLimit",
	"SpeedLimit",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SpeedLimit_tags_1,
	sizeof(asn_DEF_SpeedLimit_tags_1)
		/sizeof(asn_DEF_SpeedLimit_tags_1[0]), /* 1 */
	asn_DEF_SpeedLimit_tags_1,	/* Same as above */
	sizeof(asn_DEF_SpeedLimit_tags_1)
		/sizeof(asn_DEF_SpeedLimit_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_SpeedLimit_1,
	1,	/* Single element */
	&asn_SPC_SpeedLimit_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TransmissionAndSpeed] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [TransmissionAndSpeed] >>> ***/

typedef OCTET_STRING_t	 TransmissionAndSpeed_t;

/*** <<< FUNC-DECLS [TransmissionAndSpeed] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TransmissionAndSpeed;
asn_struct_free_f TransmissionAndSpeed_free;
asn_struct_print_f TransmissionAndSpeed_print;
asn_constr_check_f TransmissionAndSpeed_constraint;
ber_type_decoder_f TransmissionAndSpeed_decode_ber;
der_type_encoder_f TransmissionAndSpeed_encode_der;
xer_type_decoder_f TransmissionAndSpeed_decode_xer;
xer_type_encoder_f TransmissionAndSpeed_encode_xer;

/*** <<< CODE [TransmissionAndSpeed] >>> ***/

int
TransmissionAndSpeed_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
TransmissionAndSpeed_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
TransmissionAndSpeed_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TransmissionAndSpeed_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TransmissionAndSpeed_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TransmissionAndSpeed_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TransmissionAndSpeed_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TransmissionAndSpeed_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TransmissionAndSpeed_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransmissionAndSpeed_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TransmissionAndSpeed_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TransmissionAndSpeed_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TransmissionAndSpeed_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransmissionAndSpeed_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TransmissionAndSpeed] >>> ***/

static ber_tlv_tag_t asn_DEF_TransmissionAndSpeed_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TransmissionAndSpeed = {
	"TransmissionAndSpeed",
	"TransmissionAndSpeed",
	TransmissionAndSpeed_free,
	TransmissionAndSpeed_print,
	TransmissionAndSpeed_constraint,
	TransmissionAndSpeed_decode_ber,
	TransmissionAndSpeed_encode_der,
	TransmissionAndSpeed_decode_xer,
	TransmissionAndSpeed_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TransmissionAndSpeed_tags_1,
	sizeof(asn_DEF_TransmissionAndSpeed_tags_1)
		/sizeof(asn_DEF_TransmissionAndSpeed_tags_1[0]), /* 1 */
	asn_DEF_TransmissionAndSpeed_tags_1,	/* Same as above */
	sizeof(asn_DEF_TransmissionAndSpeed_tags_1)
		/sizeof(asn_DEF_TransmissionAndSpeed_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ValidRegion] >>> ***/

#include "HeadingSlice.h"
#include "Extent.h"
#include "ShapePointSet.h"
#include "Circle.h"
#include "RegionPointSet.h"
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>

/*** <<< DEPS [ValidRegion] >>> ***/

typedef enum area_PR {
	area_PR_NOTHING,	/* No components present */
	area_PR_shapePointSet,
	area_PR_circle,
	area_PR_regionPointSet
} area_PR;

/*** <<< TYPE-DECLS [ValidRegion] >>> ***/

typedef struct ValidRegion {
	HeadingSlice_t	 direction;
	Extent_t	*extent	/* OPTIONAL */;
	struct area {
		area_PR present;
		union ValidRegion__area_u {
			ShapePointSet_t	 shapePointSet;
			Circle_t	 circle;
			RegionPointSet_t	 regionPointSet;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} area;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ValidRegion_t;

/*** <<< FUNC-DECLS [ValidRegion] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ValidRegion;

/*** <<< STAT-DEFS [ValidRegion] >>> ***/

static asn_TYPE_member_t asn_MBR_area_4[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct area, choice.shapePointSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ShapePointSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "shapePointSet"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct area, choice.circle),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Circle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "circle"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct area, choice.regionPointSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RegionPointSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "regionPointSet"
		},
};
static asn_TYPE_tag2member_t asn_MAP_area_tag2el_4[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* shapePointSet */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* circle */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* regionPointSet */
};
static asn_CHOICE_specifics_t asn_SPC_area_specs_4 = {
	sizeof(struct area),
	offsetof(struct area, _asn_ctx),
	offsetof(struct area, present),
	sizeof(((struct area *)0)->present),
	asn_MAP_area_tag2el_4,
	3,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_area_4 = {
	"area",
	"area",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_area_4,
	3,	/* Elements count */
	&asn_SPC_area_specs_4	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_ValidRegion_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ValidRegion, direction),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_HeadingSlice,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "direction"
		},
	{ ATF_POINTER, 1, offsetof(struct ValidRegion, extent),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Extent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "extent"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ValidRegion, area),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_area_4,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "area"
		},
};
static ber_tlv_tag_t asn_DEF_ValidRegion_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ValidRegion_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* direction */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* extent */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* area */
};
static asn_SEQUENCE_specifics_t asn_SPC_ValidRegion_specs_1 = {
	sizeof(struct ValidRegion),
	offsetof(struct ValidRegion, _asn_ctx),
	asn_MAP_ValidRegion_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ValidRegion = {
	"ValidRegion",
	"ValidRegion",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ValidRegion_tags_1,
	sizeof(asn_DEF_ValidRegion_tags_1)
		/sizeof(asn_DEF_ValidRegion_tags_1[0]), /* 1 */
	asn_DEF_ValidRegion_tags_1,	/* Same as above */
	sizeof(asn_DEF_ValidRegion_tags_1)
		/sizeof(asn_DEF_ValidRegion_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ValidRegion_1,
	3,	/* Elements count */
	&asn_SPC_ValidRegion_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleComputedLane] >>> ***/

#include "LaneNumber.h"
#include "LaneWidth.h"
#include "VehicleLaneAttributes.h"
#include "DrivenLineOffset.h"
#include "ConnectsTo.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [VehicleComputedLane] >>> ***/

struct NodeList;

/*** <<< TYPE-DECLS [VehicleComputedLane] >>> ***/

typedef struct VehicleComputedLane {
	LaneNumber_t	 laneNumber;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	VehicleLaneAttributes_t	*laneAttributes	/* OPTIONAL */;
	LaneNumber_t	 refLaneNum;
	DrivenLineOffset_t	 lineOffset;
	struct NodeList	*keepOutList	/* OPTIONAL */;
	ConnectsTo_t	*connectsTo	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleComputedLane_t;

/*** <<< FUNC-DECLS [VehicleComputedLane] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleComputedLane;

/*** <<< POST-INCLUDE [VehicleComputedLane] >>> ***/

#include "NodeList.h"

/*** <<< STAT-DEFS [VehicleComputedLane] >>> ***/

static asn_TYPE_member_t asn_MBR_VehicleComputedLane_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleComputedLane, laneNumber),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneNumber"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleComputedLane, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleComputedLane, laneAttributes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneAttributes"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleComputedLane, refLaneNum),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "refLaneNum"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleComputedLane, lineOffset),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DrivenLineOffset,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lineOffset"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleComputedLane, keepOutList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "keepOutList"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleComputedLane, connectsTo),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConnectsTo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "connectsTo"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleComputedLane_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleComputedLane_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* laneNumber */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* laneAttributes */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* refLaneNum */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* lineOffset */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* keepOutList */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 } /* connectsTo */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleComputedLane_specs_1 = {
	sizeof(struct VehicleComputedLane),
	offsetof(struct VehicleComputedLane, _asn_ctx),
	asn_MAP_VehicleComputedLane_tag2el_1,
	7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	6,	/* Start extensions */
	8	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleComputedLane = {
	"VehicleComputedLane",
	"VehicleComputedLane",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleComputedLane_tags_1,
	sizeof(asn_DEF_VehicleComputedLane_tags_1)
		/sizeof(asn_DEF_VehicleComputedLane_tags_1[0]), /* 1 */
	asn_DEF_VehicleComputedLane_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleComputedLane_tags_1)
		/sizeof(asn_DEF_VehicleComputedLane_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleComputedLane_1,
	7,	/* Elements count */
	&asn_SPC_VehicleComputedLane_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleIdent] >>> ***/

#include "DescriptiveName.h"
#include "VINstring.h"
#include <IA5String.h>
#include "TemporaryID.h"
#include "VehicleType.h"
#include "VehicleGroupAffected.h"
#include "ResponderGroupAffected.h"
#include "IncidentResponseEquipment.h"
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>

/*** <<< DEPS [VehicleIdent] >>> ***/

typedef enum vehicleClass_PR {
	vehicleClass_PR_NOTHING,	/* No components present */
	vehicleClass_PR_vGroup,
	vehicleClass_PR_rGroup,
	vehicleClass_PR_rEquip
} vehicleClass_PR;

/*** <<< TYPE-DECLS [VehicleIdent] >>> ***/

typedef struct VehicleIdent {
	DescriptiveName_t	*name	/* OPTIONAL */;
	VINstring_t	*vin	/* OPTIONAL */;
	IA5String_t	*ownerCode	/* OPTIONAL */;
	TemporaryID_t	*id	/* OPTIONAL */;
	VehicleType_t	*vehicleType	/* OPTIONAL */;
	struct vehicleClass {
		vehicleClass_PR present;
		union VehicleIdent__vehicleClass_u {
			VehicleGroupAffected_t	 vGroup;
			ResponderGroupAffected_t	 rGroup;
			IncidentResponseEquipment_t	 rEquip;
		} choice;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *vehicleClass;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleIdent_t;

/*** <<< FUNC-DECLS [VehicleIdent] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleIdent;

/*** <<< CTABLES [VehicleIdent] >>> ***/

static int check_permitted_alphabet_4(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [VehicleIdent] >>> ***/

static int
memb_ownerCode_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 32)
		 && !check_permitted_alphabet_4(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [VehicleIdent] >>> ***/

static asn_TYPE_member_t asn_MBR_vehicleClass_7[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleClass, choice.vGroup),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleGroupAffected,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vGroup"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleClass, choice.rGroup),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ResponderGroupAffected,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rGroup"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleClass, choice.rEquip),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IncidentResponseEquipment,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rEquip"
		},
};
static asn_TYPE_tag2member_t asn_MAP_vehicleClass_tag2el_7[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* vGroup */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rGroup */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* rEquip */
};
static asn_CHOICE_specifics_t asn_SPC_vehicleClass_specs_7 = {
	sizeof(struct vehicleClass),
	offsetof(struct vehicleClass, _asn_ctx),
	offsetof(struct vehicleClass, present),
	sizeof(((struct vehicleClass *)0)->present),
	asn_MAP_vehicleClass_tag2el_7,
	3,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_vehicleClass_7 = {
	"vehicleClass",
	"vehicleClass",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_vehicleClass_7,
	3,	/* Elements count */
	&asn_SPC_vehicleClass_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_VehicleIdent_1[] = {
	{ ATF_POINTER, 6, offsetof(struct VehicleIdent, name),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DescriptiveName,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "name"
		},
	{ ATF_POINTER, 5, offsetof(struct VehicleIdent, vin),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VINstring,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vin"
		},
	{ ATF_POINTER, 4, offsetof(struct VehicleIdent, ownerCode),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_ownerCode_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "ownerCode"
		},
	{ ATF_POINTER, 3, offsetof(struct VehicleIdent, id),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TemporaryID,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "id"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleIdent, vehicleType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleType"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleIdent, vehicleClass),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_vehicleClass_7,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleClass"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleIdent_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleIdent_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* name */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* vin */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* ownerCode */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* vehicleType */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* vehicleClass */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleIdent_specs_1 = {
	sizeof(struct VehicleIdent),
	offsetof(struct VehicleIdent, _asn_ctx),
	asn_MAP_VehicleIdent_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleIdent = {
	"VehicleIdent",
	"VehicleIdent",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleIdent_tags_1,
	sizeof(asn_DEF_VehicleIdent_tags_1)
		/sizeof(asn_DEF_VehicleIdent_tags_1[0]), /* 1 */
	asn_DEF_VehicleIdent_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleIdent_tags_1)
		/sizeof(asn_DEF_VehicleIdent_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleIdent_1,
	6,	/* Elements count */
	&asn_SPC_VehicleIdent_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleReferenceLane] >>> ***/

#include "LaneNumber.h"
#include "LaneWidth.h"
#include "VehicleLaneAttributes.h"
#include "NodeList.h"
#include "ConnectsTo.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [VehicleReferenceLane] >>> ***/

struct NodeList;

/*** <<< TYPE-DECLS [VehicleReferenceLane] >>> ***/

typedef struct VehicleReferenceLane {
	LaneNumber_t	 laneNumber;
	LaneWidth_t	*laneWidth	/* OPTIONAL */;
	VehicleLaneAttributes_t	 laneAttributes;
	NodeList_t	 nodeList;
	struct NodeList	*keepOutList	/* OPTIONAL */;
	ConnectsTo_t	*connectsTo	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleReferenceLane_t;

/*** <<< FUNC-DECLS [VehicleReferenceLane] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleReferenceLane;

/*** <<< POST-INCLUDE [VehicleReferenceLane] >>> ***/

#include "NodeList.h"

/*** <<< STAT-DEFS [VehicleReferenceLane] >>> ***/

static asn_TYPE_member_t asn_MBR_VehicleReferenceLane_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleReferenceLane, laneNumber),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneNumber,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneNumber"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleReferenceLane, laneWidth),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LaneWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneWidth"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleReferenceLane, laneAttributes),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleLaneAttributes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "laneAttributes"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleReferenceLane, nodeList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "nodeList"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleReferenceLane, keepOutList),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NodeList,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "keepOutList"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleReferenceLane, connectsTo),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConnectsTo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "connectsTo"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleReferenceLane_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleReferenceLane_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* laneNumber */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* laneWidth */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* laneAttributes */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* nodeList */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* keepOutList */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 } /* connectsTo */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleReferenceLane_specs_1 = {
	sizeof(struct VehicleReferenceLane),
	offsetof(struct VehicleReferenceLane, _asn_ctx),
	asn_MAP_VehicleReferenceLane_tag2el_1,
	6,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	5,	/* Start extensions */
	7	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleReferenceLane = {
	"VehicleReferenceLane",
	"VehicleReferenceLane",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleReferenceLane_tags_1,
	sizeof(asn_DEF_VehicleReferenceLane_tags_1)
		/sizeof(asn_DEF_VehicleReferenceLane_tags_1[0]), /* 1 */
	asn_DEF_VehicleReferenceLane_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleReferenceLane_tags_1)
		/sizeof(asn_DEF_VehicleReferenceLane_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleReferenceLane_1,
	6,	/* Elements count */
	&asn_SPC_VehicleReferenceLane_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleSafetyExtension] >>> ***/

#include "EventFlags.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [VehicleSafetyExtension] >>> ***/

struct PathHistory;
struct PathPrediction;
struct RTCMPackage;

/*** <<< TYPE-DECLS [VehicleSafetyExtension] >>> ***/

typedef struct VehicleSafetyExtension {
	EventFlags_t	*events	/* OPTIONAL */;
	struct PathHistory	*pathHistory	/* OPTIONAL */;
	struct PathPrediction	*pathPrediction	/* OPTIONAL */;
	struct RTCMPackage	*theRTCM	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleSafetyExtension_t;

/*** <<< FUNC-DECLS [VehicleSafetyExtension] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleSafetyExtension;

/*** <<< POST-INCLUDE [VehicleSafetyExtension] >>> ***/

#include "PathHistory.h"
#include "PathPrediction.h"
#include "RTCMPackage.h"

/*** <<< STAT-DEFS [VehicleSafetyExtension] >>> ***/

static asn_TYPE_member_t asn_MBR_VehicleSafetyExtension_1[] = {
	{ ATF_POINTER, 4, offsetof(struct VehicleSafetyExtension, events),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EventFlags,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "events"
		},
	{ ATF_POINTER, 3, offsetof(struct VehicleSafetyExtension, pathHistory),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathHistory,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathHistory"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleSafetyExtension, pathPrediction),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PathPrediction,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "pathPrediction"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleSafetyExtension, theRTCM),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RTCMPackage,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "theRTCM"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleSafetyExtension_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleSafetyExtension_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* events */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* pathHistory */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* pathPrediction */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* theRTCM */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleSafetyExtension_specs_1 = {
	sizeof(struct VehicleSafetyExtension),
	offsetof(struct VehicleSafetyExtension, _asn_ctx),
	asn_MAP_VehicleSafetyExtension_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleSafetyExtension = {
	"VehicleSafetyExtension",
	"VehicleSafetyExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleSafetyExtension_tags_1,
	sizeof(asn_DEF_VehicleSafetyExtension_tags_1)
		/sizeof(asn_DEF_VehicleSafetyExtension_tags_1[0]), /* 1 */
	asn_DEF_VehicleSafetyExtension_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleSafetyExtension_tags_1)
		/sizeof(asn_DEF_VehicleSafetyExtension_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleSafetyExtension_1,
	4,	/* Elements count */
	&asn_SPC_VehicleSafetyExtension_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleSize] >>> ***/

#include "VehicleWidth.h"
#include "VehicleLength.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [VehicleSize] >>> ***/

typedef struct VehicleSize {
	VehicleWidth_t	 width;
	VehicleLength_t	 length;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleSize_t;

/*** <<< FUNC-DECLS [VehicleSize] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleSize;

/*** <<< STAT-DEFS [VehicleSize] >>> ***/

static asn_TYPE_member_t asn_MBR_VehicleSize_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleSize, width),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleWidth,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "width"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleSize, length),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleLength,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "length"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleSize_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleSize_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* width */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* length */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleSize_specs_1 = {
	sizeof(struct VehicleSize),
	offsetof(struct VehicleSize, _asn_ctx),
	asn_MAP_VehicleSize_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleSize = {
	"VehicleSize",
	"VehicleSize",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleSize_tags_1,
	sizeof(asn_DEF_VehicleSize_tags_1)
		/sizeof(asn_DEF_VehicleSize_tags_1[0]), /* 1 */
	asn_DEF_VehicleSize_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleSize_tags_1)
		/sizeof(asn_DEF_VehicleSize_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleSize_1,
	2,	/* Elements count */
	&asn_SPC_VehicleSize_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleStatus] >>> ***/

#include "ExteriorLights.h"
#include "LightbarInUse.h"
#include "BrakeSystemStatus.h"
#include "BrakeAppliedPressure.h"
#include "CoefficientOfFriction.h"
#include "SunSensor.h"
#include "RainSensor.h"
#include "AmbientAirTemperature.h"
#include "AmbientAirPressure.h"
#include "ThrottlePosition.h"
#include "SpeedandHeadingandThrottleConfidence.h"
#include "SpeedConfidence.h"
#include "GPSstatus.h"
#include "WiperStatusFront.h"
#include "WiperRate.h"
#include "WiperStatusRear.h"
#include <constr_SEQUENCE.h>
#include "SteeringWheelAngle.h"
#include "SteeringWheelAngleConfidence.h"
#include "SteeringWheelAngleRateOfChange.h"
#include "DrivingWheelAngle.h"
#include "AccelerationSet4Way.h"
#include "VerticalAccelerationThreshold.h"
#include "YawRateConfidence.h"
#include "AccelerationConfidence.h"
#include "ObstacleDistance.h"
#include "ObstacleDirection.h"
#include "DDateTime.h"
#include "VehicleHeight.h"
#include "BumperHeights.h"
#include "VehicleMass.h"
#include "TrailerWeight.h"
#include "VehicleType.h"
#include "EssPrecipYesNo.h"
#include "EssPrecipRate.h"
#include "EssPrecipSituation.h"
#include "EssSolarRadiation.h"
#include "EssMobileFriction.h"

/*** <<< FWD-DECLS [VehicleStatus] >>> ***/

struct FullPositionVector;
struct VehicleIdent;
struct J1939data;
struct ConfidenceSet;

/*** <<< TYPE-DECLS [VehicleStatus] >>> ***/

typedef struct VehicleStatus {
	ExteriorLights_t	*lights	/* OPTIONAL */;
	LightbarInUse_t	*lightBar	/* OPTIONAL */;
	struct wipers {
		WiperStatusFront_t	 statusFront;
		WiperRate_t	 rateFront;
		WiperStatusRear_t	*statusRear	/* OPTIONAL */;
		WiperRate_t	*rateRear	/* OPTIONAL */;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *wipers;
	BrakeSystemStatus_t	*brakeStatus	/* OPTIONAL */;
	BrakeAppliedPressure_t	*brakePressure	/* OPTIONAL */;
	CoefficientOfFriction_t	*roadFriction	/* OPTIONAL */;
	SunSensor_t	*sunData	/* OPTIONAL */;
	RainSensor_t	*rainData	/* OPTIONAL */;
	AmbientAirTemperature_t	*airTemp	/* OPTIONAL */;
	AmbientAirPressure_t	*airPres	/* OPTIONAL */;
	struct steering {
		SteeringWheelAngle_t	 angle;
		SteeringWheelAngleConfidence_t	*confidence	/* OPTIONAL */;
		SteeringWheelAngleRateOfChange_t	*rate	/* OPTIONAL */;
		DrivingWheelAngle_t	*wheels	/* OPTIONAL */;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *steering;
	struct accelSets {
		AccelerationSet4Way_t	*accel4way	/* OPTIONAL */;
		VerticalAccelerationThreshold_t	*vertAccelThres	/* OPTIONAL */;
		YawRateConfidence_t	*yawRateCon	/* OPTIONAL */;
		AccelerationConfidence_t	*hozAccelCon	/* OPTIONAL */;
		struct ConfidenceSet	*confidenceSet	/* OPTIONAL */;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *accelSets;
	struct object {
		ObstacleDistance_t	 obDist;
		ObstacleDirection_t	 obDirect;
		DDateTime_t	 dateTime;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *object;
	struct FullPositionVector	*fullPos	/* OPTIONAL */;
	ThrottlePosition_t	*throttlePos	/* OPTIONAL */;
	SpeedandHeadingandThrottleConfidence_t	*speedHeadC	/* OPTIONAL */;
	SpeedConfidence_t	*speedC	/* OPTIONAL */;
	struct vehicleData {
		VehicleHeight_t	 height;
		BumperHeights_t	 bumpers;
		VehicleMass_t	 mass;
		TrailerWeight_t	 trailerWeight;
		VehicleType_t	 type;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *vehicleData;
	struct VehicleIdent	*vehicleIdent	/* OPTIONAL */;
	struct J1939data	*j1939data	/* OPTIONAL */;
	struct weatherReport {
		EssPrecipYesNo_t	 isRaining;
		EssPrecipRate_t	*rainRate	/* OPTIONAL */;
		EssPrecipSituation_t	*precipSituation	/* OPTIONAL */;
		EssSolarRadiation_t	*solarRadiation	/* OPTIONAL */;
		EssMobileFriction_t	*friction	/* OPTIONAL */;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *weatherReport;
	GPSstatus_t	*gpsStatus	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleStatus_t;

/*** <<< FUNC-DECLS [VehicleStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleStatus;

/*** <<< POST-INCLUDE [VehicleStatus] >>> ***/

#include "FullPositionVector.h"
#include "VehicleIdent.h"
#include "J1939data.h"
#include "ConfidenceSet.h"

/*** <<< STAT-DEFS [VehicleStatus] >>> ***/

static asn_TYPE_member_t asn_MBR_wipers_4[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct wipers, statusFront),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatusFront,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "statusFront"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct wipers, rateFront),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rateFront"
		},
	{ ATF_POINTER, 2, offsetof(struct wipers, statusRear),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatusRear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "statusRear"
		},
	{ ATF_POINTER, 1, offsetof(struct wipers, rateRear),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rateRear"
		},
};
static ber_tlv_tag_t asn_DEF_wipers_tags_4[] = {
	(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_wipers_tag2el_4[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* statusFront */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rateFront */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* statusRear */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* rateRear */
};
static asn_SEQUENCE_specifics_t asn_SPC_wipers_specs_4 = {
	sizeof(struct wipers),
	offsetof(struct wipers, _asn_ctx),
	asn_MAP_wipers_tag2el_4,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_wipers_4 = {
	"wipers",
	"wipers",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_wipers_tags_4,
	sizeof(asn_DEF_wipers_tags_4)
		/sizeof(asn_DEF_wipers_tags_4[0]) - 1, /* 1 */
	asn_DEF_wipers_tags_4,	/* Same as above */
	sizeof(asn_DEF_wipers_tags_4)
		/sizeof(asn_DEF_wipers_tags_4[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_wipers_4,
	4,	/* Elements count */
	&asn_SPC_wipers_specs_4	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_steering_16[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct steering, angle),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "angle"
		},
	{ ATF_POINTER, 3, offsetof(struct steering, confidence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "confidence"
		},
	{ ATF_POINTER, 2, offsetof(struct steering, rate),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SteeringWheelAngleRateOfChange,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rate"
		},
	{ ATF_POINTER, 1, offsetof(struct steering, wheels),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DrivingWheelAngle,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "wheels"
		},
};
static ber_tlv_tag_t asn_DEF_steering_tags_16[] = {
	(ASN_TAG_CLASS_CONTEXT | (10 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_steering_tag2el_16[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* angle */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* confidence */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* rate */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* wheels */
};
static asn_SEQUENCE_specifics_t asn_SPC_steering_specs_16 = {
	sizeof(struct steering),
	offsetof(struct steering, _asn_ctx),
	asn_MAP_steering_tag2el_16,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_steering_16 = {
	"steering",
	"steering",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_steering_tags_16,
	sizeof(asn_DEF_steering_tags_16)
		/sizeof(asn_DEF_steering_tags_16[0]) - 1, /* 1 */
	asn_DEF_steering_tags_16,	/* Same as above */
	sizeof(asn_DEF_steering_tags_16)
		/sizeof(asn_DEF_steering_tags_16[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_steering_16,
	4,	/* Elements count */
	&asn_SPC_steering_specs_16	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_accelSets_21[] = {
	{ ATF_POINTER, 5, offsetof(struct accelSets, accel4way),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelerationSet4Way,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "accel4way"
		},
	{ ATF_POINTER, 4, offsetof(struct accelSets, vertAccelThres),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VerticalAccelerationThreshold,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vertAccelThres"
		},
	{ ATF_POINTER, 3, offsetof(struct accelSets, yawRateCon),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_YawRateConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "yawRateCon"
		},
	{ ATF_POINTER, 2, offsetof(struct accelSets, hozAccelCon),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AccelerationConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "hozAccelCon"
		},
	{ ATF_POINTER, 1, offsetof(struct accelSets, confidenceSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ConfidenceSet,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "confidenceSet"
		},
};
static ber_tlv_tag_t asn_DEF_accelSets_tags_21[] = {
	(ASN_TAG_CLASS_CONTEXT | (11 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_accelSets_tag2el_21[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* accel4way */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* vertAccelThres */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* yawRateCon */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* hozAccelCon */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* confidenceSet */
};
static asn_SEQUENCE_specifics_t asn_SPC_accelSets_specs_21 = {
	sizeof(struct accelSets),
	offsetof(struct accelSets, _asn_ctx),
	asn_MAP_accelSets_tag2el_21,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_accelSets_21 = {
	"accelSets",
	"accelSets",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_accelSets_tags_21,
	sizeof(asn_DEF_accelSets_tags_21)
		/sizeof(asn_DEF_accelSets_tags_21[0]) - 1, /* 1 */
	asn_DEF_accelSets_tags_21,	/* Same as above */
	sizeof(asn_DEF_accelSets_tags_21)
		/sizeof(asn_DEF_accelSets_tags_21[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_accelSets_21,
	5,	/* Elements count */
	&asn_SPC_accelSets_specs_21	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_object_27[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct object, obDist),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObstacleDistance,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "obDist"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct object, obDirect),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ObstacleDirection,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "obDirect"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct object, dateTime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_DDateTime,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "dateTime"
		},
};
static ber_tlv_tag_t asn_DEF_object_tags_27[] = {
	(ASN_TAG_CLASS_CONTEXT | (12 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_object_tag2el_27[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* obDist */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* obDirect */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* dateTime */
};
static asn_SEQUENCE_specifics_t asn_SPC_object_specs_27 = {
	sizeof(struct object),
	offsetof(struct object, _asn_ctx),
	asn_MAP_object_tag2el_27,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_object_27 = {
	"object",
	"object",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_object_tags_27,
	sizeof(asn_DEF_object_tags_27)
		/sizeof(asn_DEF_object_tags_27[0]) - 1, /* 1 */
	asn_DEF_object_tags_27,	/* Same as above */
	sizeof(asn_DEF_object_tags_27)
		/sizeof(asn_DEF_object_tags_27[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_object_27,
	3,	/* Elements count */
	&asn_SPC_object_specs_27	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_vehicleData_35[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleData, height),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleHeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "height"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleData, bumpers),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BumperHeights,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "bumpers"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleData, mass),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleMass,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "mass"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleData, trailerWeight),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TrailerWeight,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "trailerWeight"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct vehicleData, type),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleType,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "type"
		},
};
static ber_tlv_tag_t asn_DEF_vehicleData_tags_35[] = {
	(ASN_TAG_CLASS_CONTEXT | (17 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_vehicleData_tag2el_35[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* height */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* bumpers */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* mass */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* trailerWeight */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* type */
};
static asn_SEQUENCE_specifics_t asn_SPC_vehicleData_specs_35 = {
	sizeof(struct vehicleData),
	offsetof(struct vehicleData, _asn_ctx),
	asn_MAP_vehicleData_tag2el_35,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_vehicleData_35 = {
	"vehicleData",
	"vehicleData",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_vehicleData_tags_35,
	sizeof(asn_DEF_vehicleData_tags_35)
		/sizeof(asn_DEF_vehicleData_tags_35[0]) - 1, /* 1 */
	asn_DEF_vehicleData_tags_35,	/* Same as above */
	sizeof(asn_DEF_vehicleData_tags_35)
		/sizeof(asn_DEF_vehicleData_tags_35[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_vehicleData_35,
	5,	/* Elements count */
	&asn_SPC_vehicleData_specs_35	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_weatherReport_43[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct weatherReport, isRaining),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssPrecipYesNo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "isRaining"
		},
	{ ATF_POINTER, 4, offsetof(struct weatherReport, rainRate),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssPrecipRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rainRate"
		},
	{ ATF_POINTER, 3, offsetof(struct weatherReport, precipSituation),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssPrecipSituation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "precipSituation"
		},
	{ ATF_POINTER, 2, offsetof(struct weatherReport, solarRadiation),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssSolarRadiation,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "solarRadiation"
		},
	{ ATF_POINTER, 1, offsetof(struct weatherReport, friction),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_EssMobileFriction,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "friction"
		},
};
static ber_tlv_tag_t asn_DEF_weatherReport_tags_43[] = {
	(ASN_TAG_CLASS_CONTEXT | (20 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_weatherReport_tag2el_43[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* isRaining */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rainRate */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* precipSituation */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* solarRadiation */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* friction */
};
static asn_SEQUENCE_specifics_t asn_SPC_weatherReport_specs_43 = {
	sizeof(struct weatherReport),
	offsetof(struct weatherReport, _asn_ctx),
	asn_MAP_weatherReport_tag2el_43,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_weatherReport_43 = {
	"weatherReport",
	"weatherReport",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_weatherReport_tags_43,
	sizeof(asn_DEF_weatherReport_tags_43)
		/sizeof(asn_DEF_weatherReport_tags_43[0]) - 1, /* 1 */
	asn_DEF_weatherReport_tags_43,	/* Same as above */
	sizeof(asn_DEF_weatherReport_tags_43)
		/sizeof(asn_DEF_weatherReport_tags_43[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_weatherReport_43,
	5,	/* Elements count */
	&asn_SPC_weatherReport_specs_43	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_VehicleStatus_1[] = {
	{ ATF_POINTER, 22, offsetof(struct VehicleStatus, lights),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExteriorLights,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lights"
		},
	{ ATF_POINTER, 21, offsetof(struct VehicleStatus, lightBar),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_LightbarInUse,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "lightBar"
		},
	{ ATF_POINTER, 20, offsetof(struct VehicleStatus, wipers),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_wipers_4,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "wipers"
		},
	{ ATF_POINTER, 19, offsetof(struct VehicleStatus, brakeStatus),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeSystemStatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "brakeStatus"
		},
	{ ATF_POINTER, 18, offsetof(struct VehicleStatus, brakePressure),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BrakeAppliedPressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "brakePressure"
		},
	{ ATF_POINTER, 17, offsetof(struct VehicleStatus, roadFriction),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_CoefficientOfFriction,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "roadFriction"
		},
	{ ATF_POINTER, 16, offsetof(struct VehicleStatus, sunData),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SunSensor,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sunData"
		},
	{ ATF_POINTER, 15, offsetof(struct VehicleStatus, rainData),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RainSensor,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rainData"
		},
	{ ATF_POINTER, 14, offsetof(struct VehicleStatus, airTemp),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AmbientAirTemperature,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "airTemp"
		},
	{ ATF_POINTER, 13, offsetof(struct VehicleStatus, airPres),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_AmbientAirPressure,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "airPres"
		},
	{ ATF_POINTER, 12, offsetof(struct VehicleStatus, steering),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_steering_16,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "steering"
		},
	{ ATF_POINTER, 11, offsetof(struct VehicleStatus, accelSets),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_accelSets_21,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "accelSets"
		},
	{ ATF_POINTER, 10, offsetof(struct VehicleStatus, object),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_object_27,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "object"
		},
	{ ATF_POINTER, 9, offsetof(struct VehicleStatus, fullPos),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_FullPositionVector,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "fullPos"
		},
	{ ATF_POINTER, 8, offsetof(struct VehicleStatus, throttlePos),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ThrottlePosition,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "throttlePos"
		},
	{ ATF_POINTER, 7, offsetof(struct VehicleStatus, speedHeadC),
		.tag = (ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedandHeadingandThrottleConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speedHeadC"
		},
	{ ATF_POINTER, 6, offsetof(struct VehicleStatus, speedC),
		.tag = (ASN_TAG_CLASS_CONTEXT | (16 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SpeedConfidence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "speedC"
		},
	{ ATF_POINTER, 5, offsetof(struct VehicleStatus, vehicleData),
		.tag = (ASN_TAG_CLASS_CONTEXT | (17 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_vehicleData_35,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleData"
		},
	{ ATF_POINTER, 4, offsetof(struct VehicleStatus, vehicleIdent),
		.tag = (ASN_TAG_CLASS_CONTEXT | (18 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleIdent,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "vehicleIdent"
		},
	{ ATF_POINTER, 3, offsetof(struct VehicleStatus, j1939data),
		.tag = (ASN_TAG_CLASS_CONTEXT | (19 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_J1939data,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "j1939data"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleStatus, weatherReport),
		.tag = (ASN_TAG_CLASS_CONTEXT | (20 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_weatherReport_43,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "weatherReport"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleStatus, gpsStatus),
		.tag = (ASN_TAG_CLASS_CONTEXT | (21 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_GPSstatus,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "gpsStatus"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleStatus_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* lights */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* lightBar */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* wipers */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* brakeStatus */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* brakePressure */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* roadFriction */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* sunData */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* rainData */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* airTemp */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* airPres */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* steering */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* accelSets */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* object */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* fullPos */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* throttlePos */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 }, /* speedHeadC */
    { (ASN_TAG_CLASS_CONTEXT | (16 << 2)), 16, 0, 0 }, /* speedC */
    { (ASN_TAG_CLASS_CONTEXT | (17 << 2)), 17, 0, 0 }, /* vehicleData */
    { (ASN_TAG_CLASS_CONTEXT | (18 << 2)), 18, 0, 0 }, /* vehicleIdent */
    { (ASN_TAG_CLASS_CONTEXT | (19 << 2)), 19, 0, 0 }, /* j1939data */
    { (ASN_TAG_CLASS_CONTEXT | (20 << 2)), 20, 0, 0 }, /* weatherReport */
    { (ASN_TAG_CLASS_CONTEXT | (21 << 2)), 21, 0, 0 } /* gpsStatus */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleStatus_specs_1 = {
	sizeof(struct VehicleStatus),
	offsetof(struct VehicleStatus, _asn_ctx),
	asn_MAP_VehicleStatus_tag2el_1,
	22,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	21,	/* Start extensions */
	23	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleStatus = {
	"VehicleStatus",
	"VehicleStatus",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleStatus_tags_1,
	sizeof(asn_DEF_VehicleStatus_tags_1)
		/sizeof(asn_DEF_VehicleStatus_tags_1[0]), /* 1 */
	asn_DEF_VehicleStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleStatus_tags_1)
		/sizeof(asn_DEF_VehicleStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleStatus_1,
	22,	/* Elements count */
	&asn_SPC_VehicleStatus_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleStatusRequest] >>> ***/

#include "VehicleStatusDeviceTypeTag.h"
#include <NativeInteger.h>
#include <BOOLEAN.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [VehicleStatusRequest] >>> ***/

typedef struct VehicleStatusRequest {
	VehicleStatusDeviceTypeTag_t	 dataType;
	long	*subType	/* OPTIONAL */;
	long	*sendOnLessThenValue	/* OPTIONAL */;
	long	*sendOnMoreThenValue	/* OPTIONAL */;
	BOOLEAN_t	*sendAll	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} VehicleStatusRequest_t;

/*** <<< FUNC-DECLS [VehicleStatusRequest] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequest;

/*** <<< CODE [VehicleStatusRequest] >>> ***/

static int
memb_subType_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 15)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_sendOnLessThenValue_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_sendOnMoreThenValue_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [VehicleStatusRequest] >>> ***/

static asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct VehicleStatusRequest, dataType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VehicleStatusDeviceTypeTag,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "dataType"
		},
	{ ATF_POINTER, 4, offsetof(struct VehicleStatusRequest, subType),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_subType_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "subType"
		},
	{ ATF_POINTER, 3, offsetof(struct VehicleStatusRequest, sendOnLessThenValue),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_sendOnLessThenValue_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sendOnLessThenValue"
		},
	{ ATF_POINTER, 2, offsetof(struct VehicleStatusRequest, sendOnMoreThenValue),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeInteger,
		.memb_constraints = memb_sendOnMoreThenValue_constraint_1,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sendOnMoreThenValue"
		},
	{ ATF_POINTER, 1, offsetof(struct VehicleStatusRequest, sendAll),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BOOLEAN,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "sendAll"
		},
};
static ber_tlv_tag_t asn_DEF_VehicleStatusRequest_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_VehicleStatusRequest_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* dataType */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* subType */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* sendOnLessThenValue */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* sendOnMoreThenValue */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* sendAll */
};
static asn_SEQUENCE_specifics_t asn_SPC_VehicleStatusRequest_specs_1 = {
	sizeof(struct VehicleStatusRequest),
	offsetof(struct VehicleStatusRequest, _asn_ctx),
	asn_MAP_VehicleStatusRequest_tag2el_1,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	4,	/* Start extensions */
	6	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequest = {
	"VehicleStatusRequest",
	"VehicleStatusRequest",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleStatusRequest_tags_1,
	sizeof(asn_DEF_VehicleStatusRequest_tags_1)
		/sizeof(asn_DEF_VehicleStatusRequest_tags_1[0]), /* 1 */
	asn_DEF_VehicleStatusRequest_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleStatusRequest_tags_1)
		/sizeof(asn_DEF_VehicleStatusRequest_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_VehicleStatusRequest_1,
	5,	/* Elements count */
	&asn_SPC_VehicleStatusRequest_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [WiperStatus] >>> ***/

#include "WiperStatusFront.h"
#include "WiperRate.h"
#include "WiperStatusRear.h"
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [WiperStatus] >>> ***/

typedef struct WiperStatus {
	WiperStatusFront_t	 statusFront;
	WiperRate_t	 rateFront;
	WiperStatusRear_t	*statusRear	/* OPTIONAL */;
	WiperRate_t	*rateRear	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} WiperStatus_t;

/*** <<< FUNC-DECLS [WiperStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WiperStatus;

/*** <<< STAT-DEFS [WiperStatus] >>> ***/

static asn_TYPE_member_t asn_MBR_WiperStatus_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct WiperStatus, statusFront),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatusFront,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "statusFront"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct WiperStatus, rateFront),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rateFront"
		},
	{ ATF_POINTER, 2, offsetof(struct WiperStatus, statusRear),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperStatusRear,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "statusRear"
		},
	{ ATF_POINTER, 1, offsetof(struct WiperStatus, rateRear),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_WiperRate,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "rateRear"
		},
};
static ber_tlv_tag_t asn_DEF_WiperStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_WiperStatus_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* statusFront */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* rateFront */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* statusRear */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* rateRear */
};
static asn_SEQUENCE_specifics_t asn_SPC_WiperStatus_specs_1 = {
	sizeof(struct WiperStatus),
	offsetof(struct WiperStatus, _asn_ctx),
	asn_MAP_WiperStatus_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_WiperStatus = {
	"WiperStatus",
	"WiperStatus",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WiperStatus_tags_1,
	sizeof(asn_DEF_WiperStatus_tags_1)
		/sizeof(asn_DEF_WiperStatus_tags_1[0]), /* 1 */
	asn_DEF_WiperStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_WiperStatus_tags_1)
		/sizeof(asn_DEF_WiperStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_WiperStatus_1,
	4,	/* Elements count */
	&asn_SPC_WiperStatus_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [WorkZone] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include "ITIScodes.h"
#include <IA5String.h>
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< DEPS [WorkZone] >>> ***/

typedef enum item_PR {
	item_PR_NOTHING,	/* No components present */
	item_PR_itis,
	item_PR_text
} item_PR;

/*** <<< TYPE-DECLS [WorkZone] >>> ***/

typedef struct WorkZone {
	A_SEQUENCE_OF(struct Member {
		struct item {
			item_PR present;
			union item_u {
				ITIScodes_t	 itis;
				IA5String_t	 text;
			} choice;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} item;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} WorkZone_t;

/*** <<< FUNC-DECLS [WorkZone] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WorkZone;

/*** <<< CTABLES [WorkZone] >>> ***/

static int check_permitted_alphabet_5(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [WorkZone] >>> ***/

static int
memb_text_constraint_3(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 16)
		 && !check_permitted_alphabet_5(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [WorkZone] >>> ***/

static asn_TYPE_member_t asn_MBR_item_3[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.itis),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "itis"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.text),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.memb_constraints = memb_text_constraint_3,
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "text"
		},
};
static asn_TYPE_tag2member_t asn_MAP_item_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* itis */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* text */
};
static asn_CHOICE_specifics_t asn_SPC_item_specs_3 = {
	sizeof(struct item),
	offsetof(struct item, _asn_ctx),
	offsetof(struct item, present),
	sizeof(((struct item *)0)->present),
	asn_MAP_item_tag2el_3,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_item_3 = {
	"item",
	"item",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_item_3,
	2,	/* Elements count */
	&asn_SPC_item_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, item),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_item_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* item */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_2 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_2,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_2,
	1,	/* Elements count */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_WorkZone_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_WorkZone_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_WorkZone_specs_1 = {
	sizeof(struct WorkZone),
	offsetof(struct WorkZone, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_WorkZone = {
	"WorkZone",
	"WorkZone",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WorkZone_tags_1,
	sizeof(asn_DEF_WorkZone_tags_1)
		/sizeof(asn_DEF_WorkZone_tags_1[0]), /* 1 */
	asn_DEF_WorkZone_tags_1,	/* Same as above */
	sizeof(asn_DEF_WorkZone_tags_1)
		/sizeof(asn_DEF_WorkZone_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_WorkZone_1,
	1,	/* Single element */
	&asn_SPC_WorkZone_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Acceleration] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Acceleration] >>> ***/

typedef long	 Acceleration_t;

/*** <<< FUNC-DECLS [Acceleration] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Acceleration;
asn_struct_free_f Acceleration_free;
asn_struct_print_f Acceleration_print;
asn_constr_check_f Acceleration_constraint;
ber_type_decoder_f Acceleration_decode_ber;
der_type_encoder_f Acceleration_encode_der;
xer_type_decoder_f Acceleration_decode_xer;
xer_type_encoder_f Acceleration_encode_xer;

/*** <<< CODE [Acceleration] >>> ***/

int
Acceleration_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -2000 && value <= 2001)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
Acceleration_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
Acceleration_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Acceleration_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Acceleration_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Acceleration_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Acceleration_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Acceleration_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Acceleration_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Acceleration_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Acceleration_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Acceleration_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Acceleration_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Acceleration_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Acceleration] >>> ***/

static ber_tlv_tag_t asn_DEF_Acceleration_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Acceleration = {
	"Acceleration",
	"Acceleration",
	Acceleration_free,
	Acceleration_print,
	Acceleration_constraint,
	Acceleration_decode_ber,
	Acceleration_encode_der,
	Acceleration_decode_xer,
	Acceleration_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Acceleration_tags_1,
	sizeof(asn_DEF_Acceleration_tags_1)
		/sizeof(asn_DEF_Acceleration_tags_1[0]), /* 1 */
	asn_DEF_Acceleration_tags_1,	/* Same as above */
	sizeof(asn_DEF_Acceleration_tags_1)
		/sizeof(asn_DEF_Acceleration_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [AccelerationConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [AccelerationConfidence] >>> ***/

typedef enum AccelerationConfidence {
	AccelerationConfidence_unavailable	= 0,
	AccelerationConfidence_accl_100_00	= 1,
	AccelerationConfidence_accl_010_00	= 2,
	AccelerationConfidence_accl_005_00	= 3,
	AccelerationConfidence_accl_001_00	= 4,
	AccelerationConfidence_accl_000_10	= 5,
	AccelerationConfidence_accl_000_05	= 6,
	AccelerationConfidence_accl_000_01	= 7
} e_AccelerationConfidence;

/*** <<< TYPE-DECLS [AccelerationConfidence] >>> ***/

typedef long	 AccelerationConfidence_t;

/*** <<< FUNC-DECLS [AccelerationConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AccelerationConfidence;
asn_struct_free_f AccelerationConfidence_free;
asn_struct_print_f AccelerationConfidence_print;
asn_constr_check_f AccelerationConfidence_constraint;
ber_type_decoder_f AccelerationConfidence_decode_ber;
der_type_encoder_f AccelerationConfidence_encode_der;
xer_type_decoder_f AccelerationConfidence_decode_xer;
xer_type_encoder_f AccelerationConfidence_encode_xer;

/*** <<< CODE [AccelerationConfidence] >>> ***/

int
AccelerationConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
AccelerationConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
AccelerationConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AccelerationConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AccelerationConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AccelerationConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AccelerationConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AccelerationConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AccelerationConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AccelerationConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AccelerationConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AccelerationConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AccelerationConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AccelerationConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AccelerationConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_AccelerationConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	11,	"accl-100-00" },
	{ 2,	11,	"accl-010-00" },
	{ 3,	11,	"accl-005-00" },
	{ 4,	11,	"accl-001-00" },
	{ 5,	11,	"accl-000-10" },
	{ 6,	11,	"accl-000-05" },
	{ 7,	11,	"accl-000-01" }
};
static unsigned int asn_MAP_AccelerationConfidence_enum2value_1[] = {
	7,	/* accl-000-01(7) */
	6,	/* accl-000-05(6) */
	5,	/* accl-000-10(5) */
	4,	/* accl-001-00(4) */
	3,	/* accl-005-00(3) */
	2,	/* accl-010-00(2) */
	1,	/* accl-100-00(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_AccelerationConfidence_specs_1 = {
	asn_MAP_AccelerationConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_AccelerationConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_AccelerationConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AccelerationConfidence = {
	"AccelerationConfidence",
	"AccelerationConfidence",
	AccelerationConfidence_free,
	AccelerationConfidence_print,
	AccelerationConfidence_constraint,
	AccelerationConfidence_decode_ber,
	AccelerationConfidence_encode_der,
	AccelerationConfidence_decode_xer,
	AccelerationConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AccelerationConfidence_tags_1,
	sizeof(asn_DEF_AccelerationConfidence_tags_1)
		/sizeof(asn_DEF_AccelerationConfidence_tags_1[0]), /* 1 */
	asn_DEF_AccelerationConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_AccelerationConfidence_tags_1)
		/sizeof(asn_DEF_AccelerationConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_AccelerationConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [AmbientAirPressure] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [AmbientAirPressure] >>> ***/

typedef long	 AmbientAirPressure_t;

/*** <<< FUNC-DECLS [AmbientAirPressure] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AmbientAirPressure;
asn_struct_free_f AmbientAirPressure_free;
asn_struct_print_f AmbientAirPressure_print;
asn_constr_check_f AmbientAirPressure_constraint;
ber_type_decoder_f AmbientAirPressure_decode_ber;
der_type_encoder_f AmbientAirPressure_encode_der;
xer_type_decoder_f AmbientAirPressure_decode_xer;
xer_type_encoder_f AmbientAirPressure_encode_xer;

/*** <<< CODE [AmbientAirPressure] >>> ***/

int
AmbientAirPressure_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
AmbientAirPressure_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
AmbientAirPressure_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AmbientAirPressure_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AmbientAirPressure_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AmbientAirPressure_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AmbientAirPressure_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AmbientAirPressure_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AmbientAirPressure_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AmbientAirPressure_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AmbientAirPressure_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AmbientAirPressure_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AmbientAirPressure_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AmbientAirPressure_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AmbientAirPressure] >>> ***/

static ber_tlv_tag_t asn_DEF_AmbientAirPressure_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AmbientAirPressure = {
	"AmbientAirPressure",
	"AmbientAirPressure",
	AmbientAirPressure_free,
	AmbientAirPressure_print,
	AmbientAirPressure_constraint,
	AmbientAirPressure_decode_ber,
	AmbientAirPressure_encode_der,
	AmbientAirPressure_decode_xer,
	AmbientAirPressure_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AmbientAirPressure_tags_1,
	sizeof(asn_DEF_AmbientAirPressure_tags_1)
		/sizeof(asn_DEF_AmbientAirPressure_tags_1[0]), /* 1 */
	asn_DEF_AmbientAirPressure_tags_1,	/* Same as above */
	sizeof(asn_DEF_AmbientAirPressure_tags_1)
		/sizeof(asn_DEF_AmbientAirPressure_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [AmbientAirTemperature] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [AmbientAirTemperature] >>> ***/

typedef long	 AmbientAirTemperature_t;

/*** <<< FUNC-DECLS [AmbientAirTemperature] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AmbientAirTemperature;
asn_struct_free_f AmbientAirTemperature_free;
asn_struct_print_f AmbientAirTemperature_print;
asn_constr_check_f AmbientAirTemperature_constraint;
ber_type_decoder_f AmbientAirTemperature_decode_ber;
der_type_encoder_f AmbientAirTemperature_encode_der;
xer_type_decoder_f AmbientAirTemperature_decode_xer;
xer_type_encoder_f AmbientAirTemperature_encode_xer;

/*** <<< CODE [AmbientAirTemperature] >>> ***/

int
AmbientAirTemperature_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 191)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
AmbientAirTemperature_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
AmbientAirTemperature_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AmbientAirTemperature_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AmbientAirTemperature_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AmbientAirTemperature_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AmbientAirTemperature_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AmbientAirTemperature_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AmbientAirTemperature_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AmbientAirTemperature_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AmbientAirTemperature_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AmbientAirTemperature_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AmbientAirTemperature_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AmbientAirTemperature_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AmbientAirTemperature] >>> ***/

static ber_tlv_tag_t asn_DEF_AmbientAirTemperature_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AmbientAirTemperature = {
	"AmbientAirTemperature",
	"AmbientAirTemperature",
	AmbientAirTemperature_free,
	AmbientAirTemperature_print,
	AmbientAirTemperature_constraint,
	AmbientAirTemperature_decode_ber,
	AmbientAirTemperature_encode_der,
	AmbientAirTemperature_decode_xer,
	AmbientAirTemperature_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AmbientAirTemperature_tags_1,
	sizeof(asn_DEF_AmbientAirTemperature_tags_1)
		/sizeof(asn_DEF_AmbientAirTemperature_tags_1[0]), /* 1 */
	asn_DEF_AmbientAirTemperature_tags_1,	/* Same as above */
	sizeof(asn_DEF_AmbientAirTemperature_tags_1)
		/sizeof(asn_DEF_AmbientAirTemperature_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [AntiLockBrakeStatus] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [AntiLockBrakeStatus] >>> ***/

typedef enum AntiLockBrakeStatus {
	AntiLockBrakeStatus_unavailable	= 0,
	AntiLockBrakeStatus_off	= 1,
	AntiLockBrakeStatus_on	= 2,
	AntiLockBrakeStatus_engaged	= 3
} e_AntiLockBrakeStatus;

/*** <<< TYPE-DECLS [AntiLockBrakeStatus] >>> ***/

typedef long	 AntiLockBrakeStatus_t;

/*** <<< FUNC-DECLS [AntiLockBrakeStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AntiLockBrakeStatus;
asn_struct_free_f AntiLockBrakeStatus_free;
asn_struct_print_f AntiLockBrakeStatus_print;
asn_constr_check_f AntiLockBrakeStatus_constraint;
ber_type_decoder_f AntiLockBrakeStatus_decode_ber;
der_type_encoder_f AntiLockBrakeStatus_encode_der;
xer_type_decoder_f AntiLockBrakeStatus_decode_xer;
xer_type_encoder_f AntiLockBrakeStatus_encode_xer;

/*** <<< CODE [AntiLockBrakeStatus] >>> ***/

int
AntiLockBrakeStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
AntiLockBrakeStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
AntiLockBrakeStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AntiLockBrakeStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AntiLockBrakeStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AntiLockBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AntiLockBrakeStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AntiLockBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AntiLockBrakeStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AntiLockBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AntiLockBrakeStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AntiLockBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AntiLockBrakeStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AntiLockBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AntiLockBrakeStatus] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_AntiLockBrakeStatus_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	2,	"on" },
	{ 3,	7,	"engaged" }
};
static unsigned int asn_MAP_AntiLockBrakeStatus_enum2value_1[] = {
	3,	/* engaged(3) */
	1,	/* off(1) */
	2,	/* on(2) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_AntiLockBrakeStatus_specs_1 = {
	asn_MAP_AntiLockBrakeStatus_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_AntiLockBrakeStatus_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_AntiLockBrakeStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AntiLockBrakeStatus = {
	"AntiLockBrakeStatus",
	"AntiLockBrakeStatus",
	AntiLockBrakeStatus_free,
	AntiLockBrakeStatus_print,
	AntiLockBrakeStatus_constraint,
	AntiLockBrakeStatus_decode_ber,
	AntiLockBrakeStatus_encode_der,
	AntiLockBrakeStatus_decode_xer,
	AntiLockBrakeStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AntiLockBrakeStatus_tags_1,
	sizeof(asn_DEF_AntiLockBrakeStatus_tags_1)
		/sizeof(asn_DEF_AntiLockBrakeStatus_tags_1[0]), /* 1 */
	asn_DEF_AntiLockBrakeStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_AntiLockBrakeStatus_tags_1)
		/sizeof(asn_DEF_AntiLockBrakeStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_AntiLockBrakeStatus_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ApproachNumber] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ApproachNumber] >>> ***/

typedef long	 ApproachNumber_t;

/*** <<< FUNC-DECLS [ApproachNumber] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ApproachNumber;
asn_struct_free_f ApproachNumber_free;
asn_struct_print_f ApproachNumber_print;
asn_constr_check_f ApproachNumber_constraint;
ber_type_decoder_f ApproachNumber_decode_ber;
der_type_encoder_f ApproachNumber_encode_der;
xer_type_decoder_f ApproachNumber_decode_xer;
xer_type_encoder_f ApproachNumber_encode_xer;

/*** <<< CODE [ApproachNumber] >>> ***/

int
ApproachNumber_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ApproachNumber_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ApproachNumber_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ApproachNumber_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ApproachNumber_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ApproachNumber_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ApproachNumber_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ApproachNumber_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ApproachNumber_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ApproachNumber_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ApproachNumber_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ApproachNumber_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ApproachNumber_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ApproachNumber_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ApproachNumber] >>> ***/

static ber_tlv_tag_t asn_DEF_ApproachNumber_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ApproachNumber = {
	"ApproachNumber",
	"ApproachNumber",
	ApproachNumber_free,
	ApproachNumber_print,
	ApproachNumber_constraint,
	ApproachNumber_decode_ber,
	ApproachNumber_encode_der,
	ApproachNumber_decode_xer,
	ApproachNumber_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ApproachNumber_tags_1,
	sizeof(asn_DEF_ApproachNumber_tags_1)
		/sizeof(asn_DEF_ApproachNumber_tags_1[0]), /* 1 */
	asn_DEF_ApproachNumber_tags_1,	/* Same as above */
	sizeof(asn_DEF_ApproachNumber_tags_1)
		/sizeof(asn_DEF_ApproachNumber_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [AuxiliaryBrakeStatus] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [AuxiliaryBrakeStatus] >>> ***/

typedef enum AuxiliaryBrakeStatus {
	AuxiliaryBrakeStatus_unavailable	= 0,
	AuxiliaryBrakeStatus_off	= 1,
	AuxiliaryBrakeStatus_on	= 2,
	AuxiliaryBrakeStatus_reserved	= 3
} e_AuxiliaryBrakeStatus;

/*** <<< TYPE-DECLS [AuxiliaryBrakeStatus] >>> ***/

typedef long	 AuxiliaryBrakeStatus_t;

/*** <<< FUNC-DECLS [AuxiliaryBrakeStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AuxiliaryBrakeStatus;
asn_struct_free_f AuxiliaryBrakeStatus_free;
asn_struct_print_f AuxiliaryBrakeStatus_print;
asn_constr_check_f AuxiliaryBrakeStatus_constraint;
ber_type_decoder_f AuxiliaryBrakeStatus_decode_ber;
der_type_encoder_f AuxiliaryBrakeStatus_encode_der;
xer_type_decoder_f AuxiliaryBrakeStatus_decode_xer;
xer_type_encoder_f AuxiliaryBrakeStatus_encode_xer;

/*** <<< CODE [AuxiliaryBrakeStatus] >>> ***/

int
AuxiliaryBrakeStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
AuxiliaryBrakeStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AuxiliaryBrakeStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AuxiliaryBrakeStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AuxiliaryBrakeStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AuxiliaryBrakeStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AuxiliaryBrakeStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AuxiliaryBrakeStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AuxiliaryBrakeStatus] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_AuxiliaryBrakeStatus_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	2,	"on" },
	{ 3,	8,	"reserved" }
};
static unsigned int asn_MAP_AuxiliaryBrakeStatus_enum2value_1[] = {
	1,	/* off(1) */
	2,	/* on(2) */
	3,	/* reserved(3) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_AuxiliaryBrakeStatus_specs_1 = {
	asn_MAP_AuxiliaryBrakeStatus_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_AuxiliaryBrakeStatus_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_AuxiliaryBrakeStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AuxiliaryBrakeStatus = {
	"AuxiliaryBrakeStatus",
	"AuxiliaryBrakeStatus",
	AuxiliaryBrakeStatus_free,
	AuxiliaryBrakeStatus_print,
	AuxiliaryBrakeStatus_constraint,
	AuxiliaryBrakeStatus_decode_ber,
	AuxiliaryBrakeStatus_encode_der,
	AuxiliaryBrakeStatus_decode_xer,
	AuxiliaryBrakeStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AuxiliaryBrakeStatus_tags_1,
	sizeof(asn_DEF_AuxiliaryBrakeStatus_tags_1)
		/sizeof(asn_DEF_AuxiliaryBrakeStatus_tags_1[0]), /* 1 */
	asn_DEF_AuxiliaryBrakeStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_AuxiliaryBrakeStatus_tags_1)
		/sizeof(asn_DEF_AuxiliaryBrakeStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_AuxiliaryBrakeStatus_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [AxleLocation] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [AxleLocation] >>> ***/

typedef long	 AxleLocation_t;

/*** <<< FUNC-DECLS [AxleLocation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AxleLocation;
asn_struct_free_f AxleLocation_free;
asn_struct_print_f AxleLocation_print;
asn_constr_check_f AxleLocation_constraint;
ber_type_decoder_f AxleLocation_decode_ber;
der_type_encoder_f AxleLocation_encode_der;
xer_type_decoder_f AxleLocation_decode_xer;
xer_type_encoder_f AxleLocation_encode_xer;

/*** <<< CODE [AxleLocation] >>> ***/

int
AxleLocation_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
AxleLocation_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
AxleLocation_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AxleLocation_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AxleLocation_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AxleLocation_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AxleLocation_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AxleLocation_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AxleLocation_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AxleLocation_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AxleLocation_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AxleLocation_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AxleLocation_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AxleLocation_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AxleLocation] >>> ***/

static ber_tlv_tag_t asn_DEF_AxleLocation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AxleLocation = {
	"AxleLocation",
	"AxleLocation",
	AxleLocation_free,
	AxleLocation_print,
	AxleLocation_constraint,
	AxleLocation_decode_ber,
	AxleLocation_encode_der,
	AxleLocation_decode_xer,
	AxleLocation_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AxleLocation_tags_1,
	sizeof(asn_DEF_AxleLocation_tags_1)
		/sizeof(asn_DEF_AxleLocation_tags_1[0]), /* 1 */
	asn_DEF_AxleLocation_tags_1,	/* Same as above */
	sizeof(asn_DEF_AxleLocation_tags_1)
		/sizeof(asn_DEF_AxleLocation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [AxleWeight] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [AxleWeight] >>> ***/

typedef long	 AxleWeight_t;

/*** <<< FUNC-DECLS [AxleWeight] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_AxleWeight;
asn_struct_free_f AxleWeight_free;
asn_struct_print_f AxleWeight_print;
asn_constr_check_f AxleWeight_constraint;
ber_type_decoder_f AxleWeight_decode_ber;
der_type_encoder_f AxleWeight_encode_der;
xer_type_decoder_f AxleWeight_decode_xer;
xer_type_encoder_f AxleWeight_encode_xer;

/*** <<< CODE [AxleWeight] >>> ***/

int
AxleWeight_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
AxleWeight_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
AxleWeight_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	AxleWeight_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
AxleWeight_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	AxleWeight_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
AxleWeight_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	AxleWeight_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
AxleWeight_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AxleWeight_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
AxleWeight_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	AxleWeight_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
AxleWeight_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	AxleWeight_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [AxleWeight] >>> ***/

static ber_tlv_tag_t asn_DEF_AxleWeight_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_AxleWeight = {
	"AxleWeight",
	"AxleWeight",
	AxleWeight_free,
	AxleWeight_print,
	AxleWeight_constraint,
	AxleWeight_decode_ber,
	AxleWeight_encode_der,
	AxleWeight_decode_xer,
	AxleWeight_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_AxleWeight_tags_1,
	sizeof(asn_DEF_AxleWeight_tags_1)
		/sizeof(asn_DEF_AxleWeight_tags_1[0]), /* 1 */
	asn_DEF_AxleWeight_tags_1,	/* Same as above */
	sizeof(asn_DEF_AxleWeight_tags_1)
		/sizeof(asn_DEF_AxleWeight_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [BarrierAttributes] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [BarrierAttributes] >>> ***/

typedef long	 BarrierAttributes_t;

/*** <<< FUNC-DECLS [BarrierAttributes] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BarrierAttributes;
asn_struct_free_f BarrierAttributes_free;
asn_struct_print_f BarrierAttributes_print;
asn_constr_check_f BarrierAttributes_constraint;
ber_type_decoder_f BarrierAttributes_decode_ber;
der_type_encoder_f BarrierAttributes_encode_der;
xer_type_decoder_f BarrierAttributes_decode_xer;
xer_type_encoder_f BarrierAttributes_encode_xer;

/*** <<< CODE [BarrierAttributes] >>> ***/

int
BarrierAttributes_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 8192)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
BarrierAttributes_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
BarrierAttributes_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BarrierAttributes_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BarrierAttributes_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BarrierAttributes_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BarrierAttributes_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BarrierAttributes_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BarrierAttributes_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BarrierAttributes_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BarrierAttributes_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BarrierAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BarrierAttributes_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BarrierAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BarrierAttributes] >>> ***/

static ber_tlv_tag_t asn_DEF_BarrierAttributes_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BarrierAttributes = {
	"BarrierAttributes",
	"BarrierAttributes",
	BarrierAttributes_free,
	BarrierAttributes_print,
	BarrierAttributes_constraint,
	BarrierAttributes_decode_ber,
	BarrierAttributes_encode_der,
	BarrierAttributes_decode_xer,
	BarrierAttributes_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BarrierAttributes_tags_1,
	sizeof(asn_DEF_BarrierAttributes_tags_1)
		/sizeof(asn_DEF_BarrierAttributes_tags_1[0]), /* 1 */
	asn_DEF_BarrierAttributes_tags_1,	/* Same as above */
	sizeof(asn_DEF_BarrierAttributes_tags_1)
		/sizeof(asn_DEF_BarrierAttributes_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [BrakeAppliedPressure] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [BrakeAppliedPressure] >>> ***/

typedef enum BrakeAppliedPressure {
	BrakeAppliedPressure_unavailable	= 0,
	BrakeAppliedPressure_minPressure	= 1,
	BrakeAppliedPressure_bkLvl_2	= 2,
	BrakeAppliedPressure_bkLvl_3	= 3,
	BrakeAppliedPressure_bkLvl_4	= 4,
	BrakeAppliedPressure_bkLvl_5	= 5,
	BrakeAppliedPressure_bkLvl_6	= 6,
	BrakeAppliedPressure_bkLvl_7	= 7,
	BrakeAppliedPressure_bkLvl_8	= 8,
	BrakeAppliedPressure_bkLvl_9	= 9,
	BrakeAppliedPressure_bkLvl_10	= 10,
	BrakeAppliedPressure_bkLvl_11	= 11,
	BrakeAppliedPressure_bkLvl_12	= 12,
	BrakeAppliedPressure_bkLvl_13	= 13,
	BrakeAppliedPressure_bkLvl_14	= 14,
	BrakeAppliedPressure_maxPressure	= 15
} e_BrakeAppliedPressure;

/*** <<< TYPE-DECLS [BrakeAppliedPressure] >>> ***/

typedef long	 BrakeAppliedPressure_t;

/*** <<< FUNC-DECLS [BrakeAppliedPressure] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedPressure;
asn_struct_free_f BrakeAppliedPressure_free;
asn_struct_print_f BrakeAppliedPressure_print;
asn_constr_check_f BrakeAppliedPressure_constraint;
ber_type_decoder_f BrakeAppliedPressure_decode_ber;
der_type_encoder_f BrakeAppliedPressure_encode_der;
xer_type_decoder_f BrakeAppliedPressure_decode_xer;
xer_type_encoder_f BrakeAppliedPressure_encode_xer;

/*** <<< CODE [BrakeAppliedPressure] >>> ***/

int
BrakeAppliedPressure_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
BrakeAppliedPressure_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
BrakeAppliedPressure_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BrakeAppliedPressure_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BrakeAppliedPressure_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeAppliedPressure_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BrakeAppliedPressure_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BrakeAppliedPressure_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BrakeAppliedPressure_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeAppliedPressure_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BrakeAppliedPressure_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BrakeAppliedPressure_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BrakeAppliedPressure_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeAppliedPressure_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BrakeAppliedPressure] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_BrakeAppliedPressure_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	11,	"minPressure" },
	{ 2,	7,	"bkLvl-2" },
	{ 3,	7,	"bkLvl-3" },
	{ 4,	7,	"bkLvl-4" },
	{ 5,	7,	"bkLvl-5" },
	{ 6,	7,	"bkLvl-6" },
	{ 7,	7,	"bkLvl-7" },
	{ 8,	7,	"bkLvl-8" },
	{ 9,	7,	"bkLvl-9" },
	{ 10,	8,	"bkLvl-10" },
	{ 11,	8,	"bkLvl-11" },
	{ 12,	8,	"bkLvl-12" },
	{ 13,	8,	"bkLvl-13" },
	{ 14,	8,	"bkLvl-14" },
	{ 15,	11,	"maxPressure" }
};
static unsigned int asn_MAP_BrakeAppliedPressure_enum2value_1[] = {
	10,	/* bkLvl-10(10) */
	11,	/* bkLvl-11(11) */
	12,	/* bkLvl-12(12) */
	13,	/* bkLvl-13(13) */
	14,	/* bkLvl-14(14) */
	2,	/* bkLvl-2(2) */
	3,	/* bkLvl-3(3) */
	4,	/* bkLvl-4(4) */
	5,	/* bkLvl-5(5) */
	6,	/* bkLvl-6(6) */
	7,	/* bkLvl-7(7) */
	8,	/* bkLvl-8(8) */
	9,	/* bkLvl-9(9) */
	15,	/* maxPressure(15) */
	1,	/* minPressure(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_BrakeAppliedPressure_specs_1 = {
	asn_MAP_BrakeAppliedPressure_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_BrakeAppliedPressure_enum2value_1,	/* N => "tag"; sorted by N */
	16,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_BrakeAppliedPressure_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BrakeAppliedPressure = {
	"BrakeAppliedPressure",
	"BrakeAppliedPressure",
	BrakeAppliedPressure_free,
	BrakeAppliedPressure_print,
	BrakeAppliedPressure_constraint,
	BrakeAppliedPressure_decode_ber,
	BrakeAppliedPressure_encode_der,
	BrakeAppliedPressure_decode_xer,
	BrakeAppliedPressure_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BrakeAppliedPressure_tags_1,
	sizeof(asn_DEF_BrakeAppliedPressure_tags_1)
		/sizeof(asn_DEF_BrakeAppliedPressure_tags_1[0]), /* 1 */
	asn_DEF_BrakeAppliedPressure_tags_1,	/* Same as above */
	sizeof(asn_DEF_BrakeAppliedPressure_tags_1)
		/sizeof(asn_DEF_BrakeAppliedPressure_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_BrakeAppliedPressure_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [BrakeAppliedStatus] >>> ***/

#include <BIT_STRING.h>

/*** <<< DEPS [BrakeAppliedStatus] >>> ***/

typedef enum BrakeAppliedStatus {
	BrakeAppliedStatus_allOff	= 0,
	BrakeAppliedStatus_leftFront	= 1,
	BrakeAppliedStatus_leftRear	= 2,
	BrakeAppliedStatus_rightFront	= 4,
	BrakeAppliedStatus_rightRear	= 8
} e_BrakeAppliedStatus;

/*** <<< TYPE-DECLS [BrakeAppliedStatus] >>> ***/

typedef BIT_STRING_t	 BrakeAppliedStatus_t;

/*** <<< FUNC-DECLS [BrakeAppliedStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedStatus;
asn_struct_free_f BrakeAppliedStatus_free;
asn_struct_print_f BrakeAppliedStatus_print;
asn_constr_check_f BrakeAppliedStatus_constraint;
ber_type_decoder_f BrakeAppliedStatus_decode_ber;
der_type_encoder_f BrakeAppliedStatus_encode_der;
xer_type_decoder_f BrakeAppliedStatus_decode_xer;
xer_type_encoder_f BrakeAppliedStatus_encode_xer;

/*** <<< CODE [BrakeAppliedStatus] >>> ***/

int
BrakeAppliedStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using BIT_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
BrakeAppliedStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_BIT_STRING.free_struct;
	td->print_struct   = asn_DEF_BIT_STRING.print_struct;
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_BIT_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_BIT_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_BIT_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_BIT_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_BIT_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_BIT_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_BIT_STRING.per_constraints;
	td->elements       = asn_DEF_BIT_STRING.elements;
	td->elements_count = asn_DEF_BIT_STRING.elements_count;
	td->specifics      = asn_DEF_BIT_STRING.specifics;
}

void
BrakeAppliedStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BrakeAppliedStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BrakeAppliedStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeAppliedStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BrakeAppliedStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BrakeAppliedStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BrakeAppliedStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeAppliedStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BrakeAppliedStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BrakeAppliedStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BrakeAppliedStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeAppliedStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BrakeAppliedStatus] >>> ***/

static ber_tlv_tag_t asn_DEF_BrakeAppliedStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (3 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BrakeAppliedStatus = {
	"BrakeAppliedStatus",
	"BrakeAppliedStatus",
	BrakeAppliedStatus_free,
	BrakeAppliedStatus_print,
	BrakeAppliedStatus_constraint,
	BrakeAppliedStatus_decode_ber,
	BrakeAppliedStatus_encode_der,
	BrakeAppliedStatus_decode_xer,
	BrakeAppliedStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BrakeAppliedStatus_tags_1,
	sizeof(asn_DEF_BrakeAppliedStatus_tags_1)
		/sizeof(asn_DEF_BrakeAppliedStatus_tags_1[0]), /* 1 */
	asn_DEF_BrakeAppliedStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_BrakeAppliedStatus_tags_1)
		/sizeof(asn_DEF_BrakeAppliedStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	0	/* No specifics */
};


/*** <<< INCLUDES [BrakeBoostApplied] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [BrakeBoostApplied] >>> ***/

typedef enum BrakeBoostApplied {
	BrakeBoostApplied_unavailable	= 0,
	BrakeBoostApplied_off	= 1,
	BrakeBoostApplied_on	= 2
} e_BrakeBoostApplied;

/*** <<< TYPE-DECLS [BrakeBoostApplied] >>> ***/

typedef long	 BrakeBoostApplied_t;

/*** <<< FUNC-DECLS [BrakeBoostApplied] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BrakeBoostApplied;
asn_struct_free_f BrakeBoostApplied_free;
asn_struct_print_f BrakeBoostApplied_print;
asn_constr_check_f BrakeBoostApplied_constraint;
ber_type_decoder_f BrakeBoostApplied_decode_ber;
der_type_encoder_f BrakeBoostApplied_encode_der;
xer_type_decoder_f BrakeBoostApplied_decode_xer;
xer_type_encoder_f BrakeBoostApplied_encode_xer;

/*** <<< CODE [BrakeBoostApplied] >>> ***/

int
BrakeBoostApplied_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
BrakeBoostApplied_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
BrakeBoostApplied_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BrakeBoostApplied_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BrakeBoostApplied_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeBoostApplied_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BrakeBoostApplied_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BrakeBoostApplied_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BrakeBoostApplied_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeBoostApplied_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BrakeBoostApplied_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BrakeBoostApplied_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BrakeBoostApplied_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BrakeBoostApplied_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BrakeBoostApplied] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_BrakeBoostApplied_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	2,	"on" }
};
static unsigned int asn_MAP_BrakeBoostApplied_enum2value_1[] = {
	1,	/* off(1) */
	2,	/* on(2) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_BrakeBoostApplied_specs_1 = {
	asn_MAP_BrakeBoostApplied_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_BrakeBoostApplied_enum2value_1,	/* N => "tag"; sorted by N */
	3,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_BrakeBoostApplied_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BrakeBoostApplied = {
	"BrakeBoostApplied",
	"BrakeBoostApplied",
	BrakeBoostApplied_free,
	BrakeBoostApplied_print,
	BrakeBoostApplied_constraint,
	BrakeBoostApplied_decode_ber,
	BrakeBoostApplied_encode_der,
	BrakeBoostApplied_decode_xer,
	BrakeBoostApplied_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BrakeBoostApplied_tags_1,
	sizeof(asn_DEF_BrakeBoostApplied_tags_1)
		/sizeof(asn_DEF_BrakeBoostApplied_tags_1[0]), /* 1 */
	asn_DEF_BrakeBoostApplied_tags_1,	/* Same as above */
	sizeof(asn_DEF_BrakeBoostApplied_tags_1)
		/sizeof(asn_DEF_BrakeBoostApplied_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_BrakeBoostApplied_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [BumperHeightFront] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [BumperHeightFront] >>> ***/

typedef long	 BumperHeightFront_t;

/*** <<< FUNC-DECLS [BumperHeightFront] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BumperHeightFront;
asn_struct_free_f BumperHeightFront_free;
asn_struct_print_f BumperHeightFront_print;
asn_constr_check_f BumperHeightFront_constraint;
ber_type_decoder_f BumperHeightFront_decode_ber;
der_type_encoder_f BumperHeightFront_encode_der;
xer_type_decoder_f BumperHeightFront_decode_xer;
xer_type_encoder_f BumperHeightFront_encode_xer;

/*** <<< CODE [BumperHeightFront] >>> ***/

int
BumperHeightFront_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
BumperHeightFront_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
BumperHeightFront_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BumperHeightFront_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BumperHeightFront_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BumperHeightFront_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BumperHeightFront_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BumperHeightFront_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BumperHeightFront_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BumperHeightFront_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BumperHeightFront_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BumperHeightFront_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BumperHeightFront_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BumperHeightFront_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BumperHeightFront] >>> ***/

static ber_tlv_tag_t asn_DEF_BumperHeightFront_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BumperHeightFront = {
	"BumperHeightFront",
	"BumperHeightFront",
	BumperHeightFront_free,
	BumperHeightFront_print,
	BumperHeightFront_constraint,
	BumperHeightFront_decode_ber,
	BumperHeightFront_encode_der,
	BumperHeightFront_decode_xer,
	BumperHeightFront_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BumperHeightFront_tags_1,
	sizeof(asn_DEF_BumperHeightFront_tags_1)
		/sizeof(asn_DEF_BumperHeightFront_tags_1[0]), /* 1 */
	asn_DEF_BumperHeightFront_tags_1,	/* Same as above */
	sizeof(asn_DEF_BumperHeightFront_tags_1)
		/sizeof(asn_DEF_BumperHeightFront_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [BumperHeightRear] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [BumperHeightRear] >>> ***/

typedef long	 BumperHeightRear_t;

/*** <<< FUNC-DECLS [BumperHeightRear] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_BumperHeightRear;
asn_struct_free_f BumperHeightRear_free;
asn_struct_print_f BumperHeightRear_print;
asn_constr_check_f BumperHeightRear_constraint;
ber_type_decoder_f BumperHeightRear_decode_ber;
der_type_encoder_f BumperHeightRear_encode_der;
xer_type_decoder_f BumperHeightRear_decode_xer;
xer_type_encoder_f BumperHeightRear_encode_xer;

/*** <<< CODE [BumperHeightRear] >>> ***/

int
BumperHeightRear_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
BumperHeightRear_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
BumperHeightRear_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	BumperHeightRear_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
BumperHeightRear_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	BumperHeightRear_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
BumperHeightRear_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	BumperHeightRear_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
BumperHeightRear_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BumperHeightRear_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
BumperHeightRear_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	BumperHeightRear_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
BumperHeightRear_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	BumperHeightRear_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [BumperHeightRear] >>> ***/

static ber_tlv_tag_t asn_DEF_BumperHeightRear_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_BumperHeightRear = {
	"BumperHeightRear",
	"BumperHeightRear",
	BumperHeightRear_free,
	BumperHeightRear_print,
	BumperHeightRear_constraint,
	BumperHeightRear_decode_ber,
	BumperHeightRear_encode_der,
	BumperHeightRear_decode_xer,
	BumperHeightRear_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_BumperHeightRear_tags_1,
	sizeof(asn_DEF_BumperHeightRear_tags_1)
		/sizeof(asn_DEF_BumperHeightRear_tags_1[0]), /* 1 */
	asn_DEF_BumperHeightRear_tags_1,	/* Same as above */
	sizeof(asn_DEF_BumperHeightRear_tags_1)
		/sizeof(asn_DEF_BumperHeightRear_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [CargoWeight] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [CargoWeight] >>> ***/

typedef long	 CargoWeight_t;

/*** <<< FUNC-DECLS [CargoWeight] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_CargoWeight;
asn_struct_free_f CargoWeight_free;
asn_struct_print_f CargoWeight_print;
asn_constr_check_f CargoWeight_constraint;
ber_type_decoder_f CargoWeight_decode_ber;
der_type_encoder_f CargoWeight_encode_der;
xer_type_decoder_f CargoWeight_decode_xer;
xer_type_encoder_f CargoWeight_encode_xer;

/*** <<< CODE [CargoWeight] >>> ***/

int
CargoWeight_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
CargoWeight_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
CargoWeight_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	CargoWeight_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
CargoWeight_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	CargoWeight_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
CargoWeight_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	CargoWeight_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
CargoWeight_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CargoWeight_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
CargoWeight_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	CargoWeight_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
CargoWeight_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CargoWeight_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [CargoWeight] >>> ***/

static ber_tlv_tag_t asn_DEF_CargoWeight_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_CargoWeight = {
	"CargoWeight",
	"CargoWeight",
	CargoWeight_free,
	CargoWeight_print,
	CargoWeight_constraint,
	CargoWeight_decode_ber,
	CargoWeight_encode_der,
	CargoWeight_decode_xer,
	CargoWeight_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CargoWeight_tags_1,
	sizeof(asn_DEF_CargoWeight_tags_1)
		/sizeof(asn_DEF_CargoWeight_tags_1[0]), /* 1 */
	asn_DEF_CargoWeight_tags_1,	/* Same as above */
	sizeof(asn_DEF_CargoWeight_tags_1)
		/sizeof(asn_DEF_CargoWeight_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [CodeWord] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [CodeWord] >>> ***/

typedef OCTET_STRING_t	 CodeWord_t;

/*** <<< FUNC-DECLS [CodeWord] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_CodeWord;
asn_struct_free_f CodeWord_free;
asn_struct_print_f CodeWord_print;
asn_constr_check_f CodeWord_constraint;
ber_type_decoder_f CodeWord_decode_ber;
der_type_encoder_f CodeWord_encode_der;
xer_type_decoder_f CodeWord_decode_xer;
xer_type_encoder_f CodeWord_encode_xer;

/*** <<< CODE [CodeWord] >>> ***/

int
CodeWord_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
CodeWord_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
CodeWord_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	CodeWord_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
CodeWord_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	CodeWord_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
CodeWord_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	CodeWord_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
CodeWord_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CodeWord_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
CodeWord_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	CodeWord_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
CodeWord_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CodeWord_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [CodeWord] >>> ***/

static ber_tlv_tag_t asn_DEF_CodeWord_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_CodeWord = {
	"CodeWord",
	"CodeWord",
	CodeWord_free,
	CodeWord_print,
	CodeWord_constraint,
	CodeWord_decode_ber,
	CodeWord_encode_der,
	CodeWord_decode_xer,
	CodeWord_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CodeWord_tags_1,
	sizeof(asn_DEF_CodeWord_tags_1)
		/sizeof(asn_DEF_CodeWord_tags_1[0]), /* 1 */
	asn_DEF_CodeWord_tags_1,	/* Same as above */
	sizeof(asn_DEF_CodeWord_tags_1)
		/sizeof(asn_DEF_CodeWord_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [CoefficientOfFriction] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [CoefficientOfFriction] >>> ***/

typedef long	 CoefficientOfFriction_t;

/*** <<< FUNC-DECLS [CoefficientOfFriction] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_CoefficientOfFriction;
asn_struct_free_f CoefficientOfFriction_free;
asn_struct_print_f CoefficientOfFriction_print;
asn_constr_check_f CoefficientOfFriction_constraint;
ber_type_decoder_f CoefficientOfFriction_decode_ber;
der_type_encoder_f CoefficientOfFriction_encode_der;
xer_type_decoder_f CoefficientOfFriction_decode_xer;
xer_type_encoder_f CoefficientOfFriction_encode_xer;

/*** <<< CODE [CoefficientOfFriction] >>> ***/

int
CoefficientOfFriction_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 50)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
CoefficientOfFriction_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
CoefficientOfFriction_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	CoefficientOfFriction_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
CoefficientOfFriction_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	CoefficientOfFriction_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
CoefficientOfFriction_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	CoefficientOfFriction_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
CoefficientOfFriction_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CoefficientOfFriction_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
CoefficientOfFriction_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	CoefficientOfFriction_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
CoefficientOfFriction_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CoefficientOfFriction_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [CoefficientOfFriction] >>> ***/

static ber_tlv_tag_t asn_DEF_CoefficientOfFriction_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_CoefficientOfFriction = {
	"CoefficientOfFriction",
	"CoefficientOfFriction",
	CoefficientOfFriction_free,
	CoefficientOfFriction_print,
	CoefficientOfFriction_constraint,
	CoefficientOfFriction_decode_ber,
	CoefficientOfFriction_encode_der,
	CoefficientOfFriction_decode_xer,
	CoefficientOfFriction_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CoefficientOfFriction_tags_1,
	sizeof(asn_DEF_CoefficientOfFriction_tags_1)
		/sizeof(asn_DEF_CoefficientOfFriction_tags_1[0]), /* 1 */
	asn_DEF_CoefficientOfFriction_tags_1,	/* Same as above */
	sizeof(asn_DEF_CoefficientOfFriction_tags_1)
		/sizeof(asn_DEF_CoefficientOfFriction_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ColorState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [ColorState] >>> ***/

typedef enum ColorState {
	ColorState_dark	= 0,
	ColorState_green	= 1,
	ColorState_green_flashing	= 9,
	ColorState_yellow	= 2,
	ColorState_yellow_flashing	= 10,
	ColorState_red	= 4,
	ColorState_red_flashing	= 12
} e_ColorState;

/*** <<< TYPE-DECLS [ColorState] >>> ***/

typedef long	 ColorState_t;

/*** <<< FUNC-DECLS [ColorState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ColorState;
asn_struct_free_f ColorState_free;
asn_struct_print_f ColorState_print;
asn_constr_check_f ColorState_constraint;
ber_type_decoder_f ColorState_decode_ber;
der_type_encoder_f ColorState_encode_der;
xer_type_decoder_f ColorState_decode_xer;
xer_type_encoder_f ColorState_encode_xer;

/*** <<< CODE [ColorState] >>> ***/

int
ColorState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
ColorState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
ColorState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ColorState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ColorState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ColorState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ColorState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ColorState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ColorState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ColorState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ColorState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ColorState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ColorState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ColorState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ColorState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_ColorState_value2enum_1[] = {
	{ 0,	4,	"dark" },
	{ 1,	5,	"green" },
	{ 2,	6,	"yellow" },
	{ 4,	3,	"red" },
	{ 9,	14,	"green-flashing" },
	{ 10,	15,	"yellow-flashing" },
	{ 12,	12,	"red-flashing" }
};
static unsigned int asn_MAP_ColorState_enum2value_1[] = {
	0,	/* dark(0) */
	1,	/* green(1) */
	4,	/* green-flashing(9) */
	3,	/* red(4) */
	6,	/* red-flashing(12) */
	2,	/* yellow(2) */
	5	/* yellow-flashing(10) */
};
static asn_INTEGER_specifics_t asn_SPC_ColorState_specs_1 = {
	asn_MAP_ColorState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_ColorState_enum2value_1,	/* N => "tag"; sorted by N */
	7,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_ColorState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ColorState = {
	"ColorState",
	"ColorState",
	ColorState_free,
	ColorState_print,
	ColorState_constraint,
	ColorState_decode_ber,
	ColorState_encode_der,
	ColorState_decode_xer,
	ColorState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ColorState_tags_1,
	sizeof(asn_DEF_ColorState_tags_1)
		/sizeof(asn_DEF_ColorState_tags_1[0]), /* 1 */
	asn_DEF_ColorState_tags_1,	/* Same as above */
	sizeof(asn_DEF_ColorState_tags_1)
		/sizeof(asn_DEF_ColorState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ColorState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Count] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Count] >>> ***/

typedef long	 Count_t;

/*** <<< FUNC-DECLS [Count] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Count;
asn_struct_free_f Count_free;
asn_struct_print_f Count_print;
asn_constr_check_f Count_constraint;
ber_type_decoder_f Count_decode_ber;
der_type_encoder_f Count_encode_der;
xer_type_decoder_f Count_decode_xer;
xer_type_encoder_f Count_encode_xer;

/*** <<< CODE [Count] >>> ***/

int
Count_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
Count_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
Count_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Count_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Count_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Count_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Count_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Count_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Count_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Count_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Count_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Count_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Count_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Count_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Count] >>> ***/

static ber_tlv_tag_t asn_DEF_Count_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Count = {
	"Count",
	"Count",
	Count_free,
	Count_print,
	Count_constraint,
	Count_decode_ber,
	Count_encode_der,
	Count_decode_xer,
	Count_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Count_tags_1,
	sizeof(asn_DEF_Count_tags_1)
		/sizeof(asn_DEF_Count_tags_1[0]), /* 1 */
	asn_DEF_Count_tags_1,	/* Same as above */
	sizeof(asn_DEF_Count_tags_1)
		/sizeof(asn_DEF_Count_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [CrosswalkLaneAttributes] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [CrosswalkLaneAttributes] >>> ***/

typedef enum CrosswalkLaneAttributes {
	CrosswalkLaneAttributes_noData	= 0,
	CrosswalkLaneAttributes_twoWayPath	= 1,
	CrosswalkLaneAttributes_pedestrianCrosswalk	= 2,
	CrosswalkLaneAttributes_bikeLane	= 4,
	CrosswalkLaneAttributes_railRoadTrackPresent	= 8,
	CrosswalkLaneAttributes_oneWayPathOfTravel	= 16,
	CrosswalkLaneAttributes_pedestrianCrosswalkTypeA	= 32,
	CrosswalkLaneAttributes_pedestrianCrosswalkTypeB	= 64,
	CrosswalkLaneAttributes_pedestrianCrosswalkTypeC	= 128
} e_CrosswalkLaneAttributes;

/*** <<< TYPE-DECLS [CrosswalkLaneAttributes] >>> ***/

typedef long	 CrosswalkLaneAttributes_t;

/*** <<< FUNC-DECLS [CrosswalkLaneAttributes] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_CrosswalkLaneAttributes;
asn_struct_free_f CrosswalkLaneAttributes_free;
asn_struct_print_f CrosswalkLaneAttributes_print;
asn_constr_check_f CrosswalkLaneAttributes_constraint;
ber_type_decoder_f CrosswalkLaneAttributes_decode_ber;
der_type_encoder_f CrosswalkLaneAttributes_encode_der;
xer_type_decoder_f CrosswalkLaneAttributes_decode_xer;
xer_type_encoder_f CrosswalkLaneAttributes_encode_xer;

/*** <<< CODE [CrosswalkLaneAttributes] >>> ***/

int
CrosswalkLaneAttributes_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
CrosswalkLaneAttributes_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
CrosswalkLaneAttributes_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
CrosswalkLaneAttributes_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
CrosswalkLaneAttributes_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
CrosswalkLaneAttributes_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
CrosswalkLaneAttributes_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	CrosswalkLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [CrosswalkLaneAttributes] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_CrosswalkLaneAttributes_value2enum_1[] = {
	{ 0,	6,	"noData" },
	{ 1,	10,	"twoWayPath" },
	{ 2,	19,	"pedestrianCrosswalk" },
	{ 4,	8,	"bikeLane" },
	{ 8,	20,	"railRoadTrackPresent" },
	{ 16,	18,	"oneWayPathOfTravel" },
	{ 32,	24,	"pedestrianCrosswalkTypeA" },
	{ 64,	24,	"pedestrianCrosswalkTypeB" },
	{ 128,	24,	"pedestrianCrosswalkTypeC" }
};
static unsigned int asn_MAP_CrosswalkLaneAttributes_enum2value_1[] = {
	3,	/* bikeLane(4) */
	0,	/* noData(0) */
	5,	/* oneWayPathOfTravel(16) */
	2,	/* pedestrianCrosswalk(2) */
	6,	/* pedestrianCrosswalkTypeA(32) */
	7,	/* pedestrianCrosswalkTypeB(64) */
	8,	/* pedestrianCrosswalkTypeC(128) */
	4,	/* railRoadTrackPresent(8) */
	1	/* twoWayPath(1) */
};
static asn_INTEGER_specifics_t asn_SPC_CrosswalkLaneAttributes_specs_1 = {
	asn_MAP_CrosswalkLaneAttributes_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_CrosswalkLaneAttributes_enum2value_1,	/* N => "tag"; sorted by N */
	9,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_CrosswalkLaneAttributes_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_CrosswalkLaneAttributes = {
	"CrosswalkLaneAttributes",
	"CrosswalkLaneAttributes",
	CrosswalkLaneAttributes_free,
	CrosswalkLaneAttributes_print,
	CrosswalkLaneAttributes_constraint,
	CrosswalkLaneAttributes_decode_ber,
	CrosswalkLaneAttributes_encode_der,
	CrosswalkLaneAttributes_decode_xer,
	CrosswalkLaneAttributes_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CrosswalkLaneAttributes_tags_1,
	sizeof(asn_DEF_CrosswalkLaneAttributes_tags_1)
		/sizeof(asn_DEF_CrosswalkLaneAttributes_tags_1[0]), /* 1 */
	asn_DEF_CrosswalkLaneAttributes_tags_1,	/* Same as above */
	sizeof(asn_DEF_CrosswalkLaneAttributes_tags_1)
		/sizeof(asn_DEF_CrosswalkLaneAttributes_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_CrosswalkLaneAttributes_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DDay] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DDay] >>> ***/

typedef long	 DDay_t;

/*** <<< FUNC-DECLS [DDay] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DDay;
asn_struct_free_f DDay_free;
asn_struct_print_f DDay_print;
asn_constr_check_f DDay_constraint;
ber_type_decoder_f DDay_decode_ber;
der_type_encoder_f DDay_encode_der;
xer_type_decoder_f DDay_decode_xer;
xer_type_encoder_f DDay_encode_xer;

/*** <<< CODE [DDay] >>> ***/

int
DDay_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 31)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DDay_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DDay_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DDay_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DDay_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DDay_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DDay_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DDay_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DDay_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DDay_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DDay_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DDay_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DDay_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DDay_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DDay] >>> ***/

static ber_tlv_tag_t asn_DEF_DDay_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DDay = {
	"DDay",
	"DDay",
	DDay_free,
	DDay_print,
	DDay_constraint,
	DDay_decode_ber,
	DDay_encode_der,
	DDay_decode_xer,
	DDay_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DDay_tags_1,
	sizeof(asn_DEF_DDay_tags_1)
		/sizeof(asn_DEF_DDay_tags_1[0]), /* 1 */
	asn_DEF_DDay_tags_1,	/* Same as above */
	sizeof(asn_DEF_DDay_tags_1)
		/sizeof(asn_DEF_DDay_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DescriptiveName] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [DescriptiveName] >>> ***/

typedef IA5String_t	 DescriptiveName_t;

/*** <<< FUNC-DECLS [DescriptiveName] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DescriptiveName;
asn_struct_free_f DescriptiveName_free;
asn_struct_print_f DescriptiveName_print;
asn_constr_check_f DescriptiveName_constraint;
ber_type_decoder_f DescriptiveName_decode_ber;
der_type_encoder_f DescriptiveName_encode_der;
xer_type_decoder_f DescriptiveName_decode_xer;
xer_type_encoder_f DescriptiveName_encode_xer;

/*** <<< CTABLES [DescriptiveName] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [DescriptiveName] >>> ***/

int
DescriptiveName_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 63)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */
static void
DescriptiveName_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_IA5String.free_struct;
	td->print_struct   = asn_DEF_IA5String.print_struct;
	td->check_constraints = asn_DEF_IA5String.check_constraints;
	td->ber_decoder    = asn_DEF_IA5String.ber_decoder;
	td->der_encoder    = asn_DEF_IA5String.der_encoder;
	td->xer_decoder    = asn_DEF_IA5String.xer_decoder;
	td->xer_encoder    = asn_DEF_IA5String.xer_encoder;
	td->uper_decoder   = asn_DEF_IA5String.uper_decoder;
	td->uper_encoder   = asn_DEF_IA5String.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_IA5String.per_constraints;
	td->elements       = asn_DEF_IA5String.elements;
	td->elements_count = asn_DEF_IA5String.elements_count;
	td->specifics      = asn_DEF_IA5String.specifics;
}

void
DescriptiveName_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DescriptiveName_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DescriptiveName_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DescriptiveName_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DescriptiveName_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DescriptiveName_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DescriptiveName_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DescriptiveName_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DescriptiveName_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DescriptiveName_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DescriptiveName_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DescriptiveName_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DescriptiveName] >>> ***/

static ber_tlv_tag_t asn_DEF_DescriptiveName_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DescriptiveName = {
	"DescriptiveName",
	"DescriptiveName",
	DescriptiveName_free,
	DescriptiveName_print,
	DescriptiveName_constraint,
	DescriptiveName_decode_ber,
	DescriptiveName_encode_der,
	DescriptiveName_decode_xer,
	DescriptiveName_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DescriptiveName_tags_1,
	sizeof(asn_DEF_DescriptiveName_tags_1)
		/sizeof(asn_DEF_DescriptiveName_tags_1[0]), /* 1 */
	asn_DEF_DescriptiveName_tags_1,	/* Same as above */
	sizeof(asn_DEF_DescriptiveName_tags_1)
		/sizeof(asn_DEF_DescriptiveName_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DHour] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DHour] >>> ***/

typedef long	 DHour_t;

/*** <<< FUNC-DECLS [DHour] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DHour;
asn_struct_free_f DHour_free;
asn_struct_print_f DHour_print;
asn_constr_check_f DHour_constraint;
ber_type_decoder_f DHour_decode_ber;
der_type_encoder_f DHour_encode_der;
xer_type_decoder_f DHour_decode_xer;
xer_type_encoder_f DHour_encode_xer;

/*** <<< CODE [DHour] >>> ***/

int
DHour_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 31)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DHour_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DHour_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DHour_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DHour_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DHour_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DHour_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DHour_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DHour_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DHour_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DHour_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DHour_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DHour_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DHour_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DHour] >>> ***/

static ber_tlv_tag_t asn_DEF_DHour_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DHour = {
	"DHour",
	"DHour",
	DHour_free,
	DHour_print,
	DHour_constraint,
	DHour_decode_ber,
	DHour_encode_der,
	DHour_decode_xer,
	DHour_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DHour_tags_1,
	sizeof(asn_DEF_DHour_tags_1)
		/sizeof(asn_DEF_DHour_tags_1[0]), /* 1 */
	asn_DEF_DHour_tags_1,	/* Same as above */
	sizeof(asn_DEF_DHour_tags_1)
		/sizeof(asn_DEF_DHour_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DirectionOfUse] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [DirectionOfUse] >>> ***/

typedef enum DirectionOfUse {
	DirectionOfUse_forward	= 0,
	DirectionOfUse_reverse	= 1,
	DirectionOfUse_both	= 2
	/*
	 * Enumeration is extensible
	 */
} e_DirectionOfUse;

/*** <<< TYPE-DECLS [DirectionOfUse] >>> ***/

typedef long	 DirectionOfUse_t;

/*** <<< FUNC-DECLS [DirectionOfUse] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DirectionOfUse;
asn_struct_free_f DirectionOfUse_free;
asn_struct_print_f DirectionOfUse_print;
asn_constr_check_f DirectionOfUse_constraint;
ber_type_decoder_f DirectionOfUse_decode_ber;
der_type_encoder_f DirectionOfUse_encode_der;
xer_type_decoder_f DirectionOfUse_decode_xer;
xer_type_encoder_f DirectionOfUse_encode_xer;

/*** <<< CODE [DirectionOfUse] >>> ***/

int
DirectionOfUse_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
DirectionOfUse_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
DirectionOfUse_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DirectionOfUse_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DirectionOfUse_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DirectionOfUse_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DirectionOfUse_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DirectionOfUse_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DirectionOfUse_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DirectionOfUse_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DirectionOfUse_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DirectionOfUse_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DirectionOfUse_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DirectionOfUse_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DirectionOfUse] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_DirectionOfUse_value2enum_1[] = {
	{ 0,	7,	"forward" },
	{ 1,	7,	"reverse" },
	{ 2,	4,	"both" }
	/* This list is extensible */
};
static unsigned int asn_MAP_DirectionOfUse_enum2value_1[] = {
	2,	/* both(2) */
	0,	/* forward(0) */
	1	/* reverse(1) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_DirectionOfUse_specs_1 = {
	asn_MAP_DirectionOfUse_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_DirectionOfUse_enum2value_1,	/* N => "tag"; sorted by N */
	3,	/* Number of elements in the maps */
	4,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_DirectionOfUse_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DirectionOfUse = {
	"DirectionOfUse",
	"DirectionOfUse",
	DirectionOfUse_free,
	DirectionOfUse_print,
	DirectionOfUse_constraint,
	DirectionOfUse_decode_ber,
	DirectionOfUse_encode_der,
	DirectionOfUse_decode_xer,
	DirectionOfUse_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DirectionOfUse_tags_1,
	sizeof(asn_DEF_DirectionOfUse_tags_1)
		/sizeof(asn_DEF_DirectionOfUse_tags_1[0]), /* 1 */
	asn_DEF_DirectionOfUse_tags_1,	/* Same as above */
	sizeof(asn_DEF_DirectionOfUse_tags_1)
		/sizeof(asn_DEF_DirectionOfUse_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_DirectionOfUse_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DMinute] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DMinute] >>> ***/

typedef long	 DMinute_t;

/*** <<< FUNC-DECLS [DMinute] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DMinute;
asn_struct_free_f DMinute_free;
asn_struct_print_f DMinute_print;
asn_constr_check_f DMinute_constraint;
ber_type_decoder_f DMinute_decode_ber;
der_type_encoder_f DMinute_encode_der;
xer_type_decoder_f DMinute_decode_xer;
xer_type_encoder_f DMinute_encode_xer;

/*** <<< CODE [DMinute] >>> ***/

int
DMinute_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 63)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DMinute_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DMinute_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DMinute_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DMinute_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DMinute_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DMinute_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DMinute_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DMinute_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DMinute_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DMinute_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DMinute_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DMinute_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DMinute_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DMinute] >>> ***/

static ber_tlv_tag_t asn_DEF_DMinute_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DMinute = {
	"DMinute",
	"DMinute",
	DMinute_free,
	DMinute_print,
	DMinute_constraint,
	DMinute_decode_ber,
	DMinute_encode_der,
	DMinute_decode_xer,
	DMinute_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DMinute_tags_1,
	sizeof(asn_DEF_DMinute_tags_1)
		/sizeof(asn_DEF_DMinute_tags_1[0]), /* 1 */
	asn_DEF_DMinute_tags_1,	/* Same as above */
	sizeof(asn_DEF_DMinute_tags_1)
		/sizeof(asn_DEF_DMinute_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DMonth] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DMonth] >>> ***/

typedef long	 DMonth_t;

/*** <<< FUNC-DECLS [DMonth] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DMonth;
asn_struct_free_f DMonth_free;
asn_struct_print_f DMonth_print;
asn_constr_check_f DMonth_constraint;
ber_type_decoder_f DMonth_decode_ber;
der_type_encoder_f DMonth_encode_der;
xer_type_decoder_f DMonth_decode_xer;
xer_type_encoder_f DMonth_encode_xer;

/*** <<< CODE [DMonth] >>> ***/

int
DMonth_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 15)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DMonth_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DMonth_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DMonth_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DMonth_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DMonth_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DMonth_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DMonth_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DMonth_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DMonth_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DMonth_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DMonth_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DMonth_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DMonth_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DMonth] >>> ***/

static ber_tlv_tag_t asn_DEF_DMonth_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DMonth = {
	"DMonth",
	"DMonth",
	DMonth_free,
	DMonth_print,
	DMonth_constraint,
	DMonth_decode_ber,
	DMonth_encode_der,
	DMonth_decode_xer,
	DMonth_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DMonth_tags_1,
	sizeof(asn_DEF_DMonth_tags_1)
		/sizeof(asn_DEF_DMonth_tags_1[0]), /* 1 */
	asn_DEF_DMonth_tags_1,	/* Same as above */
	sizeof(asn_DEF_DMonth_tags_1)
		/sizeof(asn_DEF_DMonth_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DOffset] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DOffset] >>> ***/

typedef long	 DOffset_t;

/*** <<< FUNC-DECLS [DOffset] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DOffset;
asn_struct_free_f DOffset_free;
asn_struct_print_f DOffset_print;
asn_constr_check_f DOffset_constraint;
ber_type_decoder_f DOffset_decode_ber;
der_type_encoder_f DOffset_encode_der;
xer_type_decoder_f DOffset_decode_xer;
xer_type_encoder_f DOffset_encode_xer;

/*** <<< CODE [DOffset] >>> ***/

int
DOffset_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -840 && value <= 840)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DOffset_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DOffset_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DOffset_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DOffset_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DOffset_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DOffset_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DOffset_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DOffset_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DOffset_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DOffset_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DOffset_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DOffset_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DOffset_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DOffset] >>> ***/

static ber_tlv_tag_t asn_DEF_DOffset_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DOffset = {
	"DOffset",
	"DOffset",
	DOffset_free,
	DOffset_print,
	DOffset_constraint,
	DOffset_decode_ber,
	DOffset_encode_der,
	DOffset_decode_xer,
	DOffset_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DOffset_tags_1,
	sizeof(asn_DEF_DOffset_tags_1)
		/sizeof(asn_DEF_DOffset_tags_1[0]), /* 1 */
	asn_DEF_DOffset_tags_1,	/* Same as above */
	sizeof(asn_DEF_DOffset_tags_1)
		/sizeof(asn_DEF_DOffset_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DriveAxleLiftAirPressure] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DriveAxleLiftAirPressure] >>> ***/

typedef long	 DriveAxleLiftAirPressure_t;

/*** <<< FUNC-DECLS [DriveAxleLiftAirPressure] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLiftAirPressure;
asn_struct_free_f DriveAxleLiftAirPressure_free;
asn_struct_print_f DriveAxleLiftAirPressure_print;
asn_constr_check_f DriveAxleLiftAirPressure_constraint;
ber_type_decoder_f DriveAxleLiftAirPressure_decode_ber;
der_type_encoder_f DriveAxleLiftAirPressure_encode_der;
xer_type_decoder_f DriveAxleLiftAirPressure_decode_xer;
xer_type_encoder_f DriveAxleLiftAirPressure_encode_xer;

/*** <<< CODE [DriveAxleLiftAirPressure] >>> ***/

int
DriveAxleLiftAirPressure_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 1000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DriveAxleLiftAirPressure_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DriveAxleLiftAirPressure_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DriveAxleLiftAirPressure_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DriveAxleLiftAirPressure_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DriveAxleLiftAirPressure_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DriveAxleLiftAirPressure_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLiftAirPressure_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DriveAxleLiftAirPressure] >>> ***/

static ber_tlv_tag_t asn_DEF_DriveAxleLiftAirPressure_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DriveAxleLiftAirPressure = {
	"DriveAxleLiftAirPressure",
	"DriveAxleLiftAirPressure",
	DriveAxleLiftAirPressure_free,
	DriveAxleLiftAirPressure_print,
	DriveAxleLiftAirPressure_constraint,
	DriveAxleLiftAirPressure_decode_ber,
	DriveAxleLiftAirPressure_encode_der,
	DriveAxleLiftAirPressure_decode_xer,
	DriveAxleLiftAirPressure_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DriveAxleLiftAirPressure_tags_1,
	sizeof(asn_DEF_DriveAxleLiftAirPressure_tags_1)
		/sizeof(asn_DEF_DriveAxleLiftAirPressure_tags_1[0]), /* 1 */
	asn_DEF_DriveAxleLiftAirPressure_tags_1,	/* Same as above */
	sizeof(asn_DEF_DriveAxleLiftAirPressure_tags_1)
		/sizeof(asn_DEF_DriveAxleLiftAirPressure_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DriveAxleLocation] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DriveAxleLocation] >>> ***/

typedef long	 DriveAxleLocation_t;

/*** <<< FUNC-DECLS [DriveAxleLocation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLocation;
asn_struct_free_f DriveAxleLocation_free;
asn_struct_print_f DriveAxleLocation_print;
asn_constr_check_f DriveAxleLocation_constraint;
ber_type_decoder_f DriveAxleLocation_decode_ber;
der_type_encoder_f DriveAxleLocation_encode_der;
xer_type_decoder_f DriveAxleLocation_decode_xer;
xer_type_encoder_f DriveAxleLocation_encode_xer;

/*** <<< CODE [DriveAxleLocation] >>> ***/

int
DriveAxleLocation_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DriveAxleLocation_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DriveAxleLocation_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DriveAxleLocation_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DriveAxleLocation_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLocation_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DriveAxleLocation_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DriveAxleLocation_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DriveAxleLocation_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLocation_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DriveAxleLocation_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DriveAxleLocation_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DriveAxleLocation_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLocation_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DriveAxleLocation] >>> ***/

static ber_tlv_tag_t asn_DEF_DriveAxleLocation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DriveAxleLocation = {
	"DriveAxleLocation",
	"DriveAxleLocation",
	DriveAxleLocation_free,
	DriveAxleLocation_print,
	DriveAxleLocation_constraint,
	DriveAxleLocation_decode_ber,
	DriveAxleLocation_encode_der,
	DriveAxleLocation_decode_xer,
	DriveAxleLocation_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DriveAxleLocation_tags_1,
	sizeof(asn_DEF_DriveAxleLocation_tags_1)
		/sizeof(asn_DEF_DriveAxleLocation_tags_1[0]), /* 1 */
	asn_DEF_DriveAxleLocation_tags_1,	/* Same as above */
	sizeof(asn_DEF_DriveAxleLocation_tags_1)
		/sizeof(asn_DEF_DriveAxleLocation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DriveAxleLubePressure] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DriveAxleLubePressure] >>> ***/

typedef long	 DriveAxleLubePressure_t;

/*** <<< FUNC-DECLS [DriveAxleLubePressure] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLubePressure;
asn_struct_free_f DriveAxleLubePressure_free;
asn_struct_print_f DriveAxleLubePressure_print;
asn_constr_check_f DriveAxleLubePressure_constraint;
ber_type_decoder_f DriveAxleLubePressure_decode_ber;
der_type_encoder_f DriveAxleLubePressure_encode_der;
xer_type_decoder_f DriveAxleLubePressure_decode_xer;
xer_type_encoder_f DriveAxleLubePressure_encode_xer;

/*** <<< CODE [DriveAxleLubePressure] >>> ***/

int
DriveAxleLubePressure_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 1000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DriveAxleLubePressure_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DriveAxleLubePressure_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DriveAxleLubePressure_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DriveAxleLubePressure_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DriveAxleLubePressure_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DriveAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DriveAxleLubePressure_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DriveAxleLubePressure_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DriveAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DriveAxleLubePressure_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DriveAxleLubePressure] >>> ***/

static ber_tlv_tag_t asn_DEF_DriveAxleLubePressure_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DriveAxleLubePressure = {
	"DriveAxleLubePressure",
	"DriveAxleLubePressure",
	DriveAxleLubePressure_free,
	DriveAxleLubePressure_print,
	DriveAxleLubePressure_constraint,
	DriveAxleLubePressure_decode_ber,
	DriveAxleLubePressure_encode_der,
	DriveAxleLubePressure_decode_xer,
	DriveAxleLubePressure_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DriveAxleLubePressure_tags_1,
	sizeof(asn_DEF_DriveAxleLubePressure_tags_1)
		/sizeof(asn_DEF_DriveAxleLubePressure_tags_1[0]), /* 1 */
	asn_DEF_DriveAxleLubePressure_tags_1,	/* Same as above */
	sizeof(asn_DEF_DriveAxleLubePressure_tags_1)
		/sizeof(asn_DEF_DriveAxleLubePressure_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DriveAxleTemperature] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DriveAxleTemperature] >>> ***/

typedef long	 DriveAxleTemperature_t;

/*** <<< FUNC-DECLS [DriveAxleTemperature] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DriveAxleTemperature;
asn_struct_free_f DriveAxleTemperature_free;
asn_struct_print_f DriveAxleTemperature_print;
asn_constr_check_f DriveAxleTemperature_constraint;
ber_type_decoder_f DriveAxleTemperature_decode_ber;
der_type_encoder_f DriveAxleTemperature_encode_der;
xer_type_decoder_f DriveAxleTemperature_decode_xer;
xer_type_encoder_f DriveAxleTemperature_encode_xer;

/*** <<< CODE [DriveAxleTemperature] >>> ***/

int
DriveAxleTemperature_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -40 && value <= 210)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DriveAxleTemperature_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DriveAxleTemperature_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DriveAxleTemperature_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DriveAxleTemperature_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DriveAxleTemperature_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DriveAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DriveAxleTemperature_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DriveAxleTemperature_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DriveAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DriveAxleTemperature_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DriveAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DriveAxleTemperature] >>> ***/

static ber_tlv_tag_t asn_DEF_DriveAxleTemperature_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DriveAxleTemperature = {
	"DriveAxleTemperature",
	"DriveAxleTemperature",
	DriveAxleTemperature_free,
	DriveAxleTemperature_print,
	DriveAxleTemperature_constraint,
	DriveAxleTemperature_decode_ber,
	DriveAxleTemperature_encode_der,
	DriveAxleTemperature_decode_xer,
	DriveAxleTemperature_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DriveAxleTemperature_tags_1,
	sizeof(asn_DEF_DriveAxleTemperature_tags_1)
		/sizeof(asn_DEF_DriveAxleTemperature_tags_1[0]), /* 1 */
	asn_DEF_DriveAxleTemperature_tags_1,	/* Same as above */
	sizeof(asn_DEF_DriveAxleTemperature_tags_1)
		/sizeof(asn_DEF_DriveAxleTemperature_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DrivenLineOffset] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DrivenLineOffset] >>> ***/

typedef long	 DrivenLineOffset_t;

/*** <<< FUNC-DECLS [DrivenLineOffset] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DrivenLineOffset;
asn_struct_free_f DrivenLineOffset_free;
asn_struct_print_f DrivenLineOffset_print;
asn_constr_check_f DrivenLineOffset_constraint;
ber_type_decoder_f DrivenLineOffset_decode_ber;
der_type_encoder_f DrivenLineOffset_encode_der;
xer_type_decoder_f DrivenLineOffset_decode_xer;
xer_type_encoder_f DrivenLineOffset_encode_xer;

/*** <<< CODE [DrivenLineOffset] >>> ***/

int
DrivenLineOffset_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DrivenLineOffset_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DrivenLineOffset_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DrivenLineOffset_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DrivenLineOffset_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DrivenLineOffset_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DrivenLineOffset_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DrivenLineOffset_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DrivenLineOffset_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DrivenLineOffset_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DrivenLineOffset_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DrivenLineOffset_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DrivenLineOffset_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DrivenLineOffset_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DrivenLineOffset] >>> ***/

static ber_tlv_tag_t asn_DEF_DrivenLineOffset_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DrivenLineOffset = {
	"DrivenLineOffset",
	"DrivenLineOffset",
	DrivenLineOffset_free,
	DrivenLineOffset_print,
	DrivenLineOffset_constraint,
	DrivenLineOffset_decode_ber,
	DrivenLineOffset_encode_der,
	DrivenLineOffset_decode_xer,
	DrivenLineOffset_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DrivenLineOffset_tags_1,
	sizeof(asn_DEF_DrivenLineOffset_tags_1)
		/sizeof(asn_DEF_DrivenLineOffset_tags_1[0]), /* 1 */
	asn_DEF_DrivenLineOffset_tags_1,	/* Same as above */
	sizeof(asn_DEF_DrivenLineOffset_tags_1)
		/sizeof(asn_DEF_DrivenLineOffset_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DrivingWheelAngle] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DrivingWheelAngle] >>> ***/

typedef long	 DrivingWheelAngle_t;

/*** <<< FUNC-DECLS [DrivingWheelAngle] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DrivingWheelAngle;
asn_struct_free_f DrivingWheelAngle_free;
asn_struct_print_f DrivingWheelAngle_print;
asn_constr_check_f DrivingWheelAngle_constraint;
ber_type_decoder_f DrivingWheelAngle_decode_ber;
der_type_encoder_f DrivingWheelAngle_encode_der;
xer_type_decoder_f DrivingWheelAngle_decode_xer;
xer_type_encoder_f DrivingWheelAngle_encode_xer;

/*** <<< CODE [DrivingWheelAngle] >>> ***/

int
DrivingWheelAngle_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -127 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DrivingWheelAngle_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DrivingWheelAngle_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DrivingWheelAngle_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DrivingWheelAngle_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DrivingWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DrivingWheelAngle_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DrivingWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DrivingWheelAngle_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DrivingWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DrivingWheelAngle_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DrivingWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DrivingWheelAngle_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DrivingWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DrivingWheelAngle] >>> ***/

static ber_tlv_tag_t asn_DEF_DrivingWheelAngle_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DrivingWheelAngle = {
	"DrivingWheelAngle",
	"DrivingWheelAngle",
	DrivingWheelAngle_free,
	DrivingWheelAngle_print,
	DrivingWheelAngle_constraint,
	DrivingWheelAngle_decode_ber,
	DrivingWheelAngle_encode_der,
	DrivingWheelAngle_decode_xer,
	DrivingWheelAngle_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DrivingWheelAngle_tags_1,
	sizeof(asn_DEF_DrivingWheelAngle_tags_1)
		/sizeof(asn_DEF_DrivingWheelAngle_tags_1[0]), /* 1 */
	asn_DEF_DrivingWheelAngle_tags_1,	/* Same as above */
	sizeof(asn_DEF_DrivingWheelAngle_tags_1)
		/sizeof(asn_DEF_DrivingWheelAngle_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DSecond] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DSecond] >>> ***/

typedef long	 DSecond_t;

/*** <<< FUNC-DECLS [DSecond] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DSecond;
asn_struct_free_f DSecond_free;
asn_struct_print_f DSecond_print;
asn_constr_check_f DSecond_constraint;
ber_type_decoder_f DSecond_decode_ber;
der_type_encoder_f DSecond_encode_der;
xer_type_decoder_f DSecond_decode_xer;
xer_type_encoder_f DSecond_encode_xer;

/*** <<< CODE [DSecond] >>> ***/

int
DSecond_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DSecond_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DSecond_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DSecond_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DSecond_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DSecond_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DSecond_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DSecond_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DSecond_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DSecond_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DSecond_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DSecond_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DSecond_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DSecond_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DSecond] >>> ***/

static ber_tlv_tag_t asn_DEF_DSecond_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DSecond = {
	"DSecond",
	"DSecond",
	DSecond_free,
	DSecond_print,
	DSecond_constraint,
	DSecond_decode_ber,
	DSecond_encode_der,
	DSecond_decode_xer,
	DSecond_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DSecond_tags_1,
	sizeof(asn_DEF_DSecond_tags_1)
		/sizeof(asn_DEF_DSecond_tags_1[0]), /* 1 */
	asn_DEF_DSecond_tags_1,	/* Same as above */
	sizeof(asn_DEF_DSecond_tags_1)
		/sizeof(asn_DEF_DSecond_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DSignalSeconds] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DSignalSeconds] >>> ***/

typedef long	 DSignalSeconds_t;

/*** <<< FUNC-DECLS [DSignalSeconds] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DSignalSeconds;
asn_struct_free_f DSignalSeconds_free;
asn_struct_print_f DSignalSeconds_print;
asn_constr_check_f DSignalSeconds_constraint;
ber_type_decoder_f DSignalSeconds_decode_ber;
der_type_encoder_f DSignalSeconds_encode_der;
xer_type_decoder_f DSignalSeconds_decode_xer;
xer_type_encoder_f DSignalSeconds_encode_xer;

/*** <<< CODE [DSignalSeconds] >>> ***/

int
DSignalSeconds_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 30000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DSignalSeconds_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DSignalSeconds_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DSignalSeconds_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DSignalSeconds_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DSignalSeconds_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DSignalSeconds_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DSignalSeconds_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DSignalSeconds_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DSignalSeconds_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DSignalSeconds_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DSignalSeconds_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DSignalSeconds_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DSignalSeconds_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DSignalSeconds] >>> ***/

static ber_tlv_tag_t asn_DEF_DSignalSeconds_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DSignalSeconds = {
	"DSignalSeconds",
	"DSignalSeconds",
	DSignalSeconds_free,
	DSignalSeconds_print,
	DSignalSeconds_constraint,
	DSignalSeconds_decode_ber,
	DSignalSeconds_encode_der,
	DSignalSeconds_decode_xer,
	DSignalSeconds_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DSignalSeconds_tags_1,
	sizeof(asn_DEF_DSignalSeconds_tags_1)
		/sizeof(asn_DEF_DSignalSeconds_tags_1[0]), /* 1 */
	asn_DEF_DSignalSeconds_tags_1,	/* Same as above */
	sizeof(asn_DEF_DSignalSeconds_tags_1)
		/sizeof(asn_DEF_DSignalSeconds_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [DSRCmsgID] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [DSRCmsgID] >>> ***/

typedef enum DSRCmsgID {
	DSRCmsgID_reserved	= 0,
	DSRCmsgID_alaCarteMessage	= 1,
	DSRCmsgID_basicSafetyMessage	= 2,
	DSRCmsgID_basicSafetyMessageVerbose	= 3,
	DSRCmsgID_commonSafetyRequest	= 4,
	DSRCmsgID_emergencyVehicleAlert	= 5,
	DSRCmsgID_intersectionCollisionAlert	= 6,
	DSRCmsgID_mapData	= 7,
	DSRCmsgID_nmeaCorrections	= 8,
	DSRCmsgID_probeDataManagement	= 9,
	DSRCmsgID_probeVehicleData	= 10,
	DSRCmsgID_roadSideAlert	= 11,
	DSRCmsgID_rtcmCorrections	= 12,
	DSRCmsgID_signalPhaseAndTimingMessage	= 13,
	DSRCmsgID_signalRequestMessage	= 14,
	DSRCmsgID_signalStatusMessage	= 15,
	DSRCmsgID_travelerInformation	= 16
	/*
	 * Enumeration is extensible
	 */
} e_DSRCmsgID;

/*** <<< TYPE-DECLS [DSRCmsgID] >>> ***/

typedef long	 DSRCmsgID_t;

/*** <<< FUNC-DECLS [DSRCmsgID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DSRCmsgID;
asn_struct_free_f DSRCmsgID_free;
asn_struct_print_f DSRCmsgID_print;
asn_constr_check_f DSRCmsgID_constraint;
ber_type_decoder_f DSRCmsgID_decode_ber;
der_type_encoder_f DSRCmsgID_encode_der;
xer_type_decoder_f DSRCmsgID_decode_xer;
xer_type_encoder_f DSRCmsgID_encode_xer;

/*** <<< CODE [DSRCmsgID] >>> ***/

int
DSRCmsgID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
DSRCmsgID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
DSRCmsgID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DSRCmsgID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DSRCmsgID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DSRCmsgID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DSRCmsgID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DSRCmsgID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DSRCmsgID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DSRCmsgID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DSRCmsgID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DSRCmsgID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DSRCmsgID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DSRCmsgID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DSRCmsgID] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_DSRCmsgID_value2enum_1[] = {
	{ 0,	8,	"reserved" },
	{ 1,	15,	"alaCarteMessage" },
	{ 2,	18,	"basicSafetyMessage" },
	{ 3,	25,	"basicSafetyMessageVerbose" },
	{ 4,	19,	"commonSafetyRequest" },
	{ 5,	21,	"emergencyVehicleAlert" },
	{ 6,	26,	"intersectionCollisionAlert" },
	{ 7,	7,	"mapData" },
	{ 8,	15,	"nmeaCorrections" },
	{ 9,	19,	"probeDataManagement" },
	{ 10,	16,	"probeVehicleData" },
	{ 11,	13,	"roadSideAlert" },
	{ 12,	15,	"rtcmCorrections" },
	{ 13,	27,	"signalPhaseAndTimingMessage" },
	{ 14,	20,	"signalRequestMessage" },
	{ 15,	19,	"signalStatusMessage" },
	{ 16,	19,	"travelerInformation" }
	/* This list is extensible */
};
static unsigned int asn_MAP_DSRCmsgID_enum2value_1[] = {
	1,	/* alaCarteMessage(1) */
	2,	/* basicSafetyMessage(2) */
	3,	/* basicSafetyMessageVerbose(3) */
	4,	/* commonSafetyRequest(4) */
	5,	/* emergencyVehicleAlert(5) */
	6,	/* intersectionCollisionAlert(6) */
	7,	/* mapData(7) */
	8,	/* nmeaCorrections(8) */
	9,	/* probeDataManagement(9) */
	10,	/* probeVehicleData(10) */
	0,	/* reserved(0) */
	11,	/* roadSideAlert(11) */
	12,	/* rtcmCorrections(12) */
	13,	/* signalPhaseAndTimingMessage(13) */
	14,	/* signalRequestMessage(14) */
	15,	/* signalStatusMessage(15) */
	16	/* travelerInformation(16) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_DSRCmsgID_specs_1 = {
	asn_MAP_DSRCmsgID_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_DSRCmsgID_enum2value_1,	/* N => "tag"; sorted by N */
	17,	/* Number of elements in the maps */
	18,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_DSRCmsgID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DSRCmsgID = {
	"DSRCmsgID",
	"DSRCmsgID",
	DSRCmsgID_free,
	DSRCmsgID_print,
	DSRCmsgID_constraint,
	DSRCmsgID_decode_ber,
	DSRCmsgID_encode_der,
	DSRCmsgID_decode_xer,
	DSRCmsgID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DSRCmsgID_tags_1,
	sizeof(asn_DEF_DSRCmsgID_tags_1)
		/sizeof(asn_DEF_DSRCmsgID_tags_1[0]), /* 1 */
	asn_DEF_DSRCmsgID_tags_1,	/* Same as above */
	sizeof(asn_DEF_DSRCmsgID_tags_1)
		/sizeof(asn_DEF_DSRCmsgID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_DSRCmsgID_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [DYear] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [DYear] >>> ***/

typedef long	 DYear_t;

/*** <<< FUNC-DECLS [DYear] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_DYear;
asn_struct_free_f DYear_free;
asn_struct_print_f DYear_print;
asn_constr_check_f DYear_constraint;
ber_type_decoder_f DYear_decode_ber;
der_type_encoder_f DYear_encode_der;
xer_type_decoder_f DYear_decode_xer;
xer_type_encoder_f DYear_encode_xer;

/*** <<< CODE [DYear] >>> ***/

int
DYear_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 9999)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
DYear_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
DYear_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	DYear_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
DYear_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	DYear_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
DYear_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	DYear_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
DYear_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DYear_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
DYear_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	DYear_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
DYear_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	DYear_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [DYear] >>> ***/

static ber_tlv_tag_t asn_DEF_DYear_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_DYear = {
	"DYear",
	"DYear",
	DYear_free,
	DYear_print,
	DYear_constraint,
	DYear_decode_ber,
	DYear_encode_der,
	DYear_decode_xer,
	DYear_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_DYear_tags_1,
	sizeof(asn_DEF_DYear_tags_1)
		/sizeof(asn_DEF_DYear_tags_1[0]), /* 1 */
	asn_DEF_DYear_tags_1,	/* Same as above */
	sizeof(asn_DEF_DYear_tags_1)
		/sizeof(asn_DEF_DYear_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Elevation] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [Elevation] >>> ***/

typedef OCTET_STRING_t	 Elevation_t;

/*** <<< FUNC-DECLS [Elevation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Elevation;
asn_struct_free_f Elevation_free;
asn_struct_print_f Elevation_print;
asn_constr_check_f Elevation_constraint;
ber_type_decoder_f Elevation_decode_ber;
der_type_encoder_f Elevation_encode_der;
xer_type_decoder_f Elevation_decode_xer;
xer_type_encoder_f Elevation_encode_xer;

/*** <<< CODE [Elevation] >>> ***/

int
Elevation_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
Elevation_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
Elevation_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Elevation_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Elevation_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Elevation_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Elevation_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Elevation_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Elevation_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Elevation_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Elevation_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Elevation_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Elevation_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Elevation_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Elevation] >>> ***/

static ber_tlv_tag_t asn_DEF_Elevation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Elevation = {
	"Elevation",
	"Elevation",
	Elevation_free,
	Elevation_print,
	Elevation_constraint,
	Elevation_decode_ber,
	Elevation_encode_der,
	Elevation_decode_xer,
	Elevation_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Elevation_tags_1,
	sizeof(asn_DEF_Elevation_tags_1)
		/sizeof(asn_DEF_Elevation_tags_1[0]), /* 1 */
	asn_DEF_Elevation_tags_1,	/* Same as above */
	sizeof(asn_DEF_Elevation_tags_1)
		/sizeof(asn_DEF_Elevation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ElevationConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [ElevationConfidence] >>> ***/

typedef enum ElevationConfidence {
	ElevationConfidence_unavailable	= 0,
	ElevationConfidence_elev_500_00	= 1,
	ElevationConfidence_elev_200_00	= 2,
	ElevationConfidence_elev_100_00	= 3,
	ElevationConfidence_elev_050_00	= 4,
	ElevationConfidence_elev_020_00	= 5,
	ElevationConfidence_elev_010_00	= 6,
	ElevationConfidence_elev_005_00	= 7,
	ElevationConfidence_elev_002_00	= 8,
	ElevationConfidence_elev_001_00	= 9,
	ElevationConfidence_elev_000_50	= 10,
	ElevationConfidence_elev_000_20	= 11,
	ElevationConfidence_elev_000_10	= 12,
	ElevationConfidence_elev_000_05	= 13,
	ElevationConfidence_elev_000_02	= 14,
	ElevationConfidence_elev_000_01	= 15
} e_ElevationConfidence;

/*** <<< TYPE-DECLS [ElevationConfidence] >>> ***/

typedef long	 ElevationConfidence_t;

/*** <<< FUNC-DECLS [ElevationConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ElevationConfidence;
asn_struct_free_f ElevationConfidence_free;
asn_struct_print_f ElevationConfidence_print;
asn_constr_check_f ElevationConfidence_constraint;
ber_type_decoder_f ElevationConfidence_decode_ber;
der_type_encoder_f ElevationConfidence_encode_der;
xer_type_decoder_f ElevationConfidence_decode_xer;
xer_type_encoder_f ElevationConfidence_encode_xer;

/*** <<< CODE [ElevationConfidence] >>> ***/

int
ElevationConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
ElevationConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
ElevationConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ElevationConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ElevationConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ElevationConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ElevationConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ElevationConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ElevationConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ElevationConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ElevationConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ElevationConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ElevationConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ElevationConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ElevationConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_ElevationConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	11,	"elev-500-00" },
	{ 2,	11,	"elev-200-00" },
	{ 3,	11,	"elev-100-00" },
	{ 4,	11,	"elev-050-00" },
	{ 5,	11,	"elev-020-00" },
	{ 6,	11,	"elev-010-00" },
	{ 7,	11,	"elev-005-00" },
	{ 8,	11,	"elev-002-00" },
	{ 9,	11,	"elev-001-00" },
	{ 10,	11,	"elev-000-50" },
	{ 11,	11,	"elev-000-20" },
	{ 12,	11,	"elev-000-10" },
	{ 13,	11,	"elev-000-05" },
	{ 14,	11,	"elev-000-02" },
	{ 15,	11,	"elev-000-01" }
};
static unsigned int asn_MAP_ElevationConfidence_enum2value_1[] = {
	15,	/* elev-000-01(15) */
	14,	/* elev-000-02(14) */
	13,	/* elev-000-05(13) */
	12,	/* elev-000-10(12) */
	11,	/* elev-000-20(11) */
	10,	/* elev-000-50(10) */
	9,	/* elev-001-00(9) */
	8,	/* elev-002-00(8) */
	7,	/* elev-005-00(7) */
	6,	/* elev-010-00(6) */
	5,	/* elev-020-00(5) */
	4,	/* elev-050-00(4) */
	3,	/* elev-100-00(3) */
	2,	/* elev-200-00(2) */
	1,	/* elev-500-00(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_ElevationConfidence_specs_1 = {
	asn_MAP_ElevationConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_ElevationConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	16,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_ElevationConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ElevationConfidence = {
	"ElevationConfidence",
	"ElevationConfidence",
	ElevationConfidence_free,
	ElevationConfidence_print,
	ElevationConfidence_constraint,
	ElevationConfidence_decode_ber,
	ElevationConfidence_encode_der,
	ElevationConfidence_decode_xer,
	ElevationConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ElevationConfidence_tags_1,
	sizeof(asn_DEF_ElevationConfidence_tags_1)
		/sizeof(asn_DEF_ElevationConfidence_tags_1[0]), /* 1 */
	asn_DEF_ElevationConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_ElevationConfidence_tags_1)
		/sizeof(asn_DEF_ElevationConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ElevationConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [EmergencyDetails] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [EmergencyDetails] >>> ***/

typedef long	 EmergencyDetails_t;

/*** <<< FUNC-DECLS [EmergencyDetails] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EmergencyDetails;
asn_struct_free_f EmergencyDetails_free;
asn_struct_print_f EmergencyDetails_print;
asn_constr_check_f EmergencyDetails_constraint;
ber_type_decoder_f EmergencyDetails_decode_ber;
der_type_encoder_f EmergencyDetails_encode_der;
xer_type_decoder_f EmergencyDetails_decode_xer;
xer_type_encoder_f EmergencyDetails_encode_xer;

/*** <<< CODE [EmergencyDetails] >>> ***/

int
EmergencyDetails_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 63)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
EmergencyDetails_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
EmergencyDetails_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EmergencyDetails_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EmergencyDetails_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EmergencyDetails_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EmergencyDetails_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EmergencyDetails_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EmergencyDetails_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EmergencyDetails_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EmergencyDetails_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EmergencyDetails_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EmergencyDetails_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EmergencyDetails_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EmergencyDetails] >>> ***/

static ber_tlv_tag_t asn_DEF_EmergencyDetails_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EmergencyDetails = {
	"EmergencyDetails",
	"EmergencyDetails",
	EmergencyDetails_free,
	EmergencyDetails_print,
	EmergencyDetails_constraint,
	EmergencyDetails_decode_ber,
	EmergencyDetails_encode_der,
	EmergencyDetails_decode_xer,
	EmergencyDetails_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EmergencyDetails_tags_1,
	sizeof(asn_DEF_EmergencyDetails_tags_1)
		/sizeof(asn_DEF_EmergencyDetails_tags_1[0]), /* 1 */
	asn_DEF_EmergencyDetails_tags_1,	/* Same as above */
	sizeof(asn_DEF_EmergencyDetails_tags_1)
		/sizeof(asn_DEF_EmergencyDetails_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [EventFlags] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [EventFlags] >>> ***/

typedef long	 EventFlags_t;

/*** <<< FUNC-DECLS [EventFlags] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EventFlags;
asn_struct_free_f EventFlags_free;
asn_struct_print_f EventFlags_print;
asn_constr_check_f EventFlags_constraint;
ber_type_decoder_f EventFlags_decode_ber;
der_type_encoder_f EventFlags_encode_der;
xer_type_decoder_f EventFlags_decode_xer;
xer_type_encoder_f EventFlags_encode_xer;

/*** <<< CODE [EventFlags] >>> ***/

int
EventFlags_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 8192)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
EventFlags_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
EventFlags_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EventFlags_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EventFlags_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EventFlags_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EventFlags_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EventFlags_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EventFlags_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EventFlags_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EventFlags_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EventFlags_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EventFlags_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EventFlags_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EventFlags] >>> ***/

static ber_tlv_tag_t asn_DEF_EventFlags_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EventFlags = {
	"EventFlags",
	"EventFlags",
	EventFlags_free,
	EventFlags_print,
	EventFlags_constraint,
	EventFlags_decode_ber,
	EventFlags_encode_der,
	EventFlags_decode_xer,
	EventFlags_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EventFlags_tags_1,
	sizeof(asn_DEF_EventFlags_tags_1)
		/sizeof(asn_DEF_EventFlags_tags_1[0]), /* 1 */
	asn_DEF_EventFlags_tags_1,	/* Same as above */
	sizeof(asn_DEF_EventFlags_tags_1)
		/sizeof(asn_DEF_EventFlags_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Extent] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [Extent] >>> ***/

typedef enum Extent {
	Extent_useInstantlyOnly	= 0,
	Extent_useFor3meters	= 1,
	Extent_useFor10meters	= 2,
	Extent_useFor50meters	= 3,
	Extent_useFor100meters	= 4,
	Extent_useFor500meters	= 5,
	Extent_useFor1000meters	= 6,
	Extent_useFor5000meters	= 7,
	Extent_useFor10000meters	= 8,
	Extent_useFor50000meters	= 9,
	Extent_useFor100000meters	= 10,
	Extent_forever	= 127
} e_Extent;

/*** <<< TYPE-DECLS [Extent] >>> ***/

typedef long	 Extent_t;

/*** <<< FUNC-DECLS [Extent] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Extent;
asn_struct_free_f Extent_free;
asn_struct_print_f Extent_print;
asn_constr_check_f Extent_constraint;
ber_type_decoder_f Extent_decode_ber;
der_type_encoder_f Extent_encode_der;
xer_type_decoder_f Extent_decode_xer;
xer_type_encoder_f Extent_encode_xer;

/*** <<< CODE [Extent] >>> ***/

int
Extent_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
Extent_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
Extent_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Extent_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Extent_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Extent_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Extent_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Extent_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Extent_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Extent_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Extent_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Extent_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Extent_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Extent_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Extent] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_Extent_value2enum_1[] = {
	{ 0,	16,	"useInstantlyOnly" },
	{ 1,	13,	"useFor3meters" },
	{ 2,	14,	"useFor10meters" },
	{ 3,	14,	"useFor50meters" },
	{ 4,	15,	"useFor100meters" },
	{ 5,	15,	"useFor500meters" },
	{ 6,	16,	"useFor1000meters" },
	{ 7,	16,	"useFor5000meters" },
	{ 8,	17,	"useFor10000meters" },
	{ 9,	17,	"useFor50000meters" },
	{ 10,	18,	"useFor100000meters" },
	{ 127,	7,	"forever" }
};
static unsigned int asn_MAP_Extent_enum2value_1[] = {
	11,	/* forever(127) */
	10,	/* useFor100000meters(10) */
	8,	/* useFor10000meters(8) */
	6,	/* useFor1000meters(6) */
	4,	/* useFor100meters(4) */
	2,	/* useFor10meters(2) */
	1,	/* useFor3meters(1) */
	9,	/* useFor50000meters(9) */
	7,	/* useFor5000meters(7) */
	5,	/* useFor500meters(5) */
	3,	/* useFor50meters(3) */
	0	/* useInstantlyOnly(0) */
};
static asn_INTEGER_specifics_t asn_SPC_Extent_specs_1 = {
	asn_MAP_Extent_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Extent_enum2value_1,	/* N => "tag"; sorted by N */
	12,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_Extent_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Extent = {
	"Extent",
	"Extent",
	Extent_free,
	Extent_print,
	Extent_constraint,
	Extent_decode_ber,
	Extent_encode_der,
	Extent_decode_xer,
	Extent_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Extent_tags_1,
	sizeof(asn_DEF_Extent_tags_1)
		/sizeof(asn_DEF_Extent_tags_1[0]), /* 1 */
	asn_DEF_Extent_tags_1,	/* Same as above */
	sizeof(asn_DEF_Extent_tags_1)
		/sizeof(asn_DEF_Extent_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Extent_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ExteriorLights] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ExteriorLights] >>> ***/

typedef long	 ExteriorLights_t;

/*** <<< FUNC-DECLS [ExteriorLights] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ExteriorLights;
asn_struct_free_f ExteriorLights_free;
asn_struct_print_f ExteriorLights_print;
asn_constr_check_f ExteriorLights_constraint;
ber_type_decoder_f ExteriorLights_decode_ber;
der_type_encoder_f ExteriorLights_encode_der;
xer_type_decoder_f ExteriorLights_decode_xer;
xer_type_encoder_f ExteriorLights_encode_xer;

/*** <<< CODE [ExteriorLights] >>> ***/

int
ExteriorLights_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 256)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ExteriorLights_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ExteriorLights_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ExteriorLights_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ExteriorLights_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ExteriorLights_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ExteriorLights_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ExteriorLights_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ExteriorLights_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ExteriorLights_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ExteriorLights_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ExteriorLights_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ExteriorLights_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ExteriorLights_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ExteriorLights] >>> ***/

static ber_tlv_tag_t asn_DEF_ExteriorLights_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ExteriorLights = {
	"ExteriorLights",
	"ExteriorLights",
	ExteriorLights_free,
	ExteriorLights_print,
	ExteriorLights_constraint,
	ExteriorLights_decode_ber,
	ExteriorLights_encode_der,
	ExteriorLights_decode_xer,
	ExteriorLights_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ExteriorLights_tags_1,
	sizeof(asn_DEF_ExteriorLights_tags_1)
		/sizeof(asn_DEF_ExteriorLights_tags_1[0]), /* 1 */
	asn_DEF_ExteriorLights_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExteriorLights_tags_1)
		/sizeof(asn_DEF_ExteriorLights_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [FurtherInfoID] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [FurtherInfoID] >>> ***/

typedef OCTET_STRING_t	 FurtherInfoID_t;

/*** <<< FUNC-DECLS [FurtherInfoID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_FurtherInfoID;
asn_struct_free_f FurtherInfoID_free;
asn_struct_print_f FurtherInfoID_print;
asn_constr_check_f FurtherInfoID_constraint;
ber_type_decoder_f FurtherInfoID_decode_ber;
der_type_encoder_f FurtherInfoID_encode_der;
xer_type_decoder_f FurtherInfoID_decode_xer;
xer_type_encoder_f FurtherInfoID_encode_xer;

/*** <<< CODE [FurtherInfoID] >>> ***/

int
FurtherInfoID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
FurtherInfoID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
FurtherInfoID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	FurtherInfoID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
FurtherInfoID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	FurtherInfoID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
FurtherInfoID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	FurtherInfoID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
FurtherInfoID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	FurtherInfoID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
FurtherInfoID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	FurtherInfoID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
FurtherInfoID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	FurtherInfoID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [FurtherInfoID] >>> ***/

static ber_tlv_tag_t asn_DEF_FurtherInfoID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_FurtherInfoID = {
	"FurtherInfoID",
	"FurtherInfoID",
	FurtherInfoID_free,
	FurtherInfoID_print,
	FurtherInfoID_constraint,
	FurtherInfoID_decode_ber,
	FurtherInfoID_encode_der,
	FurtherInfoID_decode_xer,
	FurtherInfoID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_FurtherInfoID_tags_1,
	sizeof(asn_DEF_FurtherInfoID_tags_1)
		/sizeof(asn_DEF_FurtherInfoID_tags_1[0]), /* 1 */
	asn_DEF_FurtherInfoID_tags_1,	/* Same as above */
	sizeof(asn_DEF_FurtherInfoID_tags_1)
		/sizeof(asn_DEF_FurtherInfoID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [GPSstatus] >>> ***/

#include <BIT_STRING.h>

/*** <<< DEPS [GPSstatus] >>> ***/

typedef enum GPSstatus {
	GPSstatus_unavailable	= 0,
	GPSstatus_isHealthy	= 1,
	GPSstatus_isMonitored	= 2,
	GPSstatus_baseStationType	= 3,
	GPSstatus_aPDOPofUnder5	= 4,
	GPSstatus_inViewOfUnder5	= 5,
	GPSstatus_localCorrectionsPresent	= 6,
	GPSstatus_networkCorrectionsPresent	= 7
} e_GPSstatus;

/*** <<< TYPE-DECLS [GPSstatus] >>> ***/

typedef BIT_STRING_t	 GPSstatus_t;

/*** <<< FUNC-DECLS [GPSstatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_GPSstatus;
asn_struct_free_f GPSstatus_free;
asn_struct_print_f GPSstatus_print;
asn_constr_check_f GPSstatus_constraint;
ber_type_decoder_f GPSstatus_decode_ber;
der_type_encoder_f GPSstatus_encode_der;
xer_type_decoder_f GPSstatus_decode_xer;
xer_type_encoder_f GPSstatus_encode_xer;

/*** <<< CODE [GPSstatus] >>> ***/

int
GPSstatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using BIT_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
GPSstatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_BIT_STRING.free_struct;
	td->print_struct   = asn_DEF_BIT_STRING.print_struct;
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_BIT_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_BIT_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_BIT_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_BIT_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_BIT_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_BIT_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_BIT_STRING.per_constraints;
	td->elements       = asn_DEF_BIT_STRING.elements;
	td->elements_count = asn_DEF_BIT_STRING.elements_count;
	td->specifics      = asn_DEF_BIT_STRING.specifics;
}

void
GPSstatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	GPSstatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
GPSstatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	GPSstatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
GPSstatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	GPSstatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
GPSstatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	GPSstatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
GPSstatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	GPSstatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
GPSstatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	GPSstatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [GPSstatus] >>> ***/

static ber_tlv_tag_t asn_DEF_GPSstatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (3 << 2))
};
asn_TYPE_descriptor_t asn_DEF_GPSstatus = {
	"GPSstatus",
	"GPSstatus",
	GPSstatus_free,
	GPSstatus_print,
	GPSstatus_constraint,
	GPSstatus_decode_ber,
	GPSstatus_encode_der,
	GPSstatus_decode_xer,
	GPSstatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_GPSstatus_tags_1,
	sizeof(asn_DEF_GPSstatus_tags_1)
		/sizeof(asn_DEF_GPSstatus_tags_1[0]), /* 1 */
	asn_DEF_GPSstatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_GPSstatus_tags_1)
		/sizeof(asn_DEF_GPSstatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	0	/* No specifics */
};


/*** <<< INCLUDES [Heading] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Heading] >>> ***/

typedef long	 Heading_t;

/*** <<< FUNC-DECLS [Heading] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Heading;
asn_struct_free_f Heading_free;
asn_struct_print_f Heading_print;
asn_constr_check_f Heading_constraint;
ber_type_decoder_f Heading_decode_ber;
der_type_encoder_f Heading_encode_der;
xer_type_decoder_f Heading_decode_xer;
xer_type_encoder_f Heading_encode_xer;

/*** <<< CODE [Heading] >>> ***/

int
Heading_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 28800)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
Heading_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
Heading_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Heading_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Heading_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Heading_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Heading_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Heading_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Heading_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Heading_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Heading_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Heading_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Heading_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Heading_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Heading] >>> ***/

static ber_tlv_tag_t asn_DEF_Heading_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Heading = {
	"Heading",
	"Heading",
	Heading_free,
	Heading_print,
	Heading_constraint,
	Heading_decode_ber,
	Heading_encode_der,
	Heading_decode_xer,
	Heading_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Heading_tags_1,
	sizeof(asn_DEF_Heading_tags_1)
		/sizeof(asn_DEF_Heading_tags_1[0]), /* 1 */
	asn_DEF_Heading_tags_1,	/* Same as above */
	sizeof(asn_DEF_Heading_tags_1)
		/sizeof(asn_DEF_Heading_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [HeadingConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [HeadingConfidence] >>> ***/

typedef enum HeadingConfidence {
	HeadingConfidence_unavailable	= 0,
	HeadingConfidence_prec45deg	= 1,
	HeadingConfidence_prec10deg	= 2,
	HeadingConfidence_prec05deg	= 3,
	HeadingConfidence_prec01deg	= 4,
	HeadingConfidence_prec0_1deg	= 5,
	HeadingConfidence_prec0_05deg	= 6,
	HeadingConfidence_prec0_01deg	= 7
} e_HeadingConfidence;

/*** <<< TYPE-DECLS [HeadingConfidence] >>> ***/

typedef long	 HeadingConfidence_t;

/*** <<< FUNC-DECLS [HeadingConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_HeadingConfidence;
asn_struct_free_f HeadingConfidence_free;
asn_struct_print_f HeadingConfidence_print;
asn_constr_check_f HeadingConfidence_constraint;
ber_type_decoder_f HeadingConfidence_decode_ber;
der_type_encoder_f HeadingConfidence_encode_der;
xer_type_decoder_f HeadingConfidence_decode_xer;
xer_type_encoder_f HeadingConfidence_encode_xer;

/*** <<< CODE [HeadingConfidence] >>> ***/

int
HeadingConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
HeadingConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
HeadingConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	HeadingConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
HeadingConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	HeadingConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
HeadingConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	HeadingConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
HeadingConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	HeadingConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
HeadingConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	HeadingConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
HeadingConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	HeadingConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [HeadingConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_HeadingConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	9,	"prec45deg" },
	{ 2,	9,	"prec10deg" },
	{ 3,	9,	"prec05deg" },
	{ 4,	9,	"prec01deg" },
	{ 5,	10,	"prec0-1deg" },
	{ 6,	11,	"prec0-05deg" },
	{ 7,	11,	"prec0-01deg" }
};
static unsigned int asn_MAP_HeadingConfidence_enum2value_1[] = {
	7,	/* prec0-01deg(7) */
	6,	/* prec0-05deg(6) */
	5,	/* prec0-1deg(5) */
	4,	/* prec01deg(4) */
	3,	/* prec05deg(3) */
	2,	/* prec10deg(2) */
	1,	/* prec45deg(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_HeadingConfidence_specs_1 = {
	asn_MAP_HeadingConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_HeadingConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_HeadingConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_HeadingConfidence = {
	"HeadingConfidence",
	"HeadingConfidence",
	HeadingConfidence_free,
	HeadingConfidence_print,
	HeadingConfidence_constraint,
	HeadingConfidence_decode_ber,
	HeadingConfidence_encode_der,
	HeadingConfidence_decode_xer,
	HeadingConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_HeadingConfidence_tags_1,
	sizeof(asn_DEF_HeadingConfidence_tags_1)
		/sizeof(asn_DEF_HeadingConfidence_tags_1[0]), /* 1 */
	asn_DEF_HeadingConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_HeadingConfidence_tags_1)
		/sizeof(asn_DEF_HeadingConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_HeadingConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [HeadingSlice] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [HeadingSlice] >>> ***/

typedef OCTET_STRING_t	 HeadingSlice_t;

/*** <<< FUNC-DECLS [HeadingSlice] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_HeadingSlice;
asn_struct_free_f HeadingSlice_free;
asn_struct_print_f HeadingSlice_print;
asn_constr_check_f HeadingSlice_constraint;
ber_type_decoder_f HeadingSlice_decode_ber;
der_type_encoder_f HeadingSlice_encode_der;
xer_type_decoder_f HeadingSlice_decode_xer;
xer_type_encoder_f HeadingSlice_encode_xer;

/*** <<< CODE [HeadingSlice] >>> ***/

int
HeadingSlice_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
HeadingSlice_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
HeadingSlice_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	HeadingSlice_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
HeadingSlice_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	HeadingSlice_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
HeadingSlice_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	HeadingSlice_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
HeadingSlice_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	HeadingSlice_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
HeadingSlice_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	HeadingSlice_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
HeadingSlice_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	HeadingSlice_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [HeadingSlice] >>> ***/

static ber_tlv_tag_t asn_DEF_HeadingSlice_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_HeadingSlice = {
	"HeadingSlice",
	"HeadingSlice",
	HeadingSlice_free,
	HeadingSlice_print,
	HeadingSlice_constraint,
	HeadingSlice_decode_ber,
	HeadingSlice_encode_der,
	HeadingSlice_decode_xer,
	HeadingSlice_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_HeadingSlice_tags_1,
	sizeof(asn_DEF_HeadingSlice_tags_1)
		/sizeof(asn_DEF_HeadingSlice_tags_1[0]), /* 1 */
	asn_DEF_HeadingSlice_tags_1,	/* Same as above */
	sizeof(asn_DEF_HeadingSlice_tags_1)
		/sizeof(asn_DEF_HeadingSlice_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [IntersectionID] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [IntersectionID] >>> ***/

typedef OCTET_STRING_t	 IntersectionID_t;

/*** <<< FUNC-DECLS [IntersectionID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_IntersectionID;
asn_struct_free_f IntersectionID_free;
asn_struct_print_f IntersectionID_print;
asn_constr_check_f IntersectionID_constraint;
ber_type_decoder_f IntersectionID_decode_ber;
der_type_encoder_f IntersectionID_encode_der;
xer_type_decoder_f IntersectionID_decode_xer;
xer_type_encoder_f IntersectionID_encode_xer;

/*** <<< CODE [IntersectionID] >>> ***/

int
IntersectionID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 2 && size <= 4)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
IntersectionID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
IntersectionID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	IntersectionID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
IntersectionID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	IntersectionID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
IntersectionID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	IntersectionID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
IntersectionID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	IntersectionID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
IntersectionID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	IntersectionID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
IntersectionID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	IntersectionID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [IntersectionID] >>> ***/

static ber_tlv_tag_t asn_DEF_IntersectionID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_IntersectionID = {
	"IntersectionID",
	"IntersectionID",
	IntersectionID_free,
	IntersectionID_print,
	IntersectionID_constraint,
	IntersectionID_decode_ber,
	IntersectionID_encode_der,
	IntersectionID_decode_xer,
	IntersectionID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_IntersectionID_tags_1,
	sizeof(asn_DEF_IntersectionID_tags_1)
		/sizeof(asn_DEF_IntersectionID_tags_1[0]), /* 1 */
	asn_DEF_IntersectionID_tags_1,	/* Same as above */
	sizeof(asn_DEF_IntersectionID_tags_1)
		/sizeof(asn_DEF_IntersectionID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [IntersectionStatusObject] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [IntersectionStatusObject] >>> ***/

typedef OCTET_STRING_t	 IntersectionStatusObject_t;

/*** <<< FUNC-DECLS [IntersectionStatusObject] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_IntersectionStatusObject;
asn_struct_free_f IntersectionStatusObject_free;
asn_struct_print_f IntersectionStatusObject_print;
asn_constr_check_f IntersectionStatusObject_constraint;
ber_type_decoder_f IntersectionStatusObject_decode_ber;
der_type_encoder_f IntersectionStatusObject_encode_der;
xer_type_decoder_f IntersectionStatusObject_decode_xer;
xer_type_encoder_f IntersectionStatusObject_encode_xer;

/*** <<< CODE [IntersectionStatusObject] >>> ***/

int
IntersectionStatusObject_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
IntersectionStatusObject_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
IntersectionStatusObject_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	IntersectionStatusObject_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
IntersectionStatusObject_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	IntersectionStatusObject_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
IntersectionStatusObject_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	IntersectionStatusObject_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
IntersectionStatusObject_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	IntersectionStatusObject_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
IntersectionStatusObject_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	IntersectionStatusObject_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
IntersectionStatusObject_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	IntersectionStatusObject_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [IntersectionStatusObject] >>> ***/

static ber_tlv_tag_t asn_DEF_IntersectionStatusObject_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_IntersectionStatusObject = {
	"IntersectionStatusObject",
	"IntersectionStatusObject",
	IntersectionStatusObject_free,
	IntersectionStatusObject_print,
	IntersectionStatusObject_constraint,
	IntersectionStatusObject_decode_ber,
	IntersectionStatusObject_encode_der,
	IntersectionStatusObject_decode_xer,
	IntersectionStatusObject_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_IntersectionStatusObject_tags_1,
	sizeof(asn_DEF_IntersectionStatusObject_tags_1)
		/sizeof(asn_DEF_IntersectionStatusObject_tags_1[0]), /* 1 */
	asn_DEF_IntersectionStatusObject_tags_1,	/* Same as above */
	sizeof(asn_DEF_IntersectionStatusObject_tags_1)
		/sizeof(asn_DEF_IntersectionStatusObject_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [LaneCount] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [LaneCount] >>> ***/

typedef long	 LaneCount_t;

/*** <<< FUNC-DECLS [LaneCount] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LaneCount;
asn_struct_free_f LaneCount_free;
asn_struct_print_f LaneCount_print;
asn_constr_check_f LaneCount_constraint;
ber_type_decoder_f LaneCount_decode_ber;
der_type_encoder_f LaneCount_encode_der;
xer_type_decoder_f LaneCount_decode_xer;
xer_type_encoder_f LaneCount_encode_xer;

/*** <<< CODE [LaneCount] >>> ***/

int
LaneCount_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
LaneCount_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
LaneCount_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LaneCount_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LaneCount_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LaneCount_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LaneCount_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LaneCount_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LaneCount_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneCount_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LaneCount_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LaneCount_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LaneCount_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneCount_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LaneCount] >>> ***/

static ber_tlv_tag_t asn_DEF_LaneCount_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LaneCount = {
	"LaneCount",
	"LaneCount",
	LaneCount_free,
	LaneCount_print,
	LaneCount_constraint,
	LaneCount_decode_ber,
	LaneCount_encode_der,
	LaneCount_decode_xer,
	LaneCount_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LaneCount_tags_1,
	sizeof(asn_DEF_LaneCount_tags_1)
		/sizeof(asn_DEF_LaneCount_tags_1[0]), /* 1 */
	asn_DEF_LaneCount_tags_1,	/* Same as above */
	sizeof(asn_DEF_LaneCount_tags_1)
		/sizeof(asn_DEF_LaneCount_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [LaneManeuverCode] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [LaneManeuverCode] >>> ***/

typedef enum LaneManeuverCode {
	LaneManeuverCode_unknown	= 0,
	LaneManeuverCode_uTurn	= 1,
	LaneManeuverCode_leftTurn	= 2,
	LaneManeuverCode_rightTurn	= 3,
	LaneManeuverCode_straightAhead	= 4,
	LaneManeuverCode_softLeftTurn	= 5,
	LaneManeuverCode_softRightTurn	= 6
	/*
	 * Enumeration is extensible
	 */
} e_LaneManeuverCode;

/*** <<< TYPE-DECLS [LaneManeuverCode] >>> ***/

typedef long	 LaneManeuverCode_t;

/*** <<< FUNC-DECLS [LaneManeuverCode] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LaneManeuverCode;
asn_struct_free_f LaneManeuverCode_free;
asn_struct_print_f LaneManeuverCode_print;
asn_constr_check_f LaneManeuverCode_constraint;
ber_type_decoder_f LaneManeuverCode_decode_ber;
der_type_encoder_f LaneManeuverCode_encode_der;
xer_type_decoder_f LaneManeuverCode_decode_xer;
xer_type_encoder_f LaneManeuverCode_encode_xer;

/*** <<< CODE [LaneManeuverCode] >>> ***/

int
LaneManeuverCode_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
LaneManeuverCode_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
LaneManeuverCode_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LaneManeuverCode_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LaneManeuverCode_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LaneManeuverCode_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LaneManeuverCode_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LaneManeuverCode_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LaneManeuverCode_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneManeuverCode_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LaneManeuverCode_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LaneManeuverCode_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LaneManeuverCode_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneManeuverCode_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LaneManeuverCode] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_LaneManeuverCode_value2enum_1[] = {
	{ 0,	7,	"unknown" },
	{ 1,	5,	"uTurn" },
	{ 2,	8,	"leftTurn" },
	{ 3,	9,	"rightTurn" },
	{ 4,	13,	"straightAhead" },
	{ 5,	12,	"softLeftTurn" },
	{ 6,	13,	"softRightTurn" }
	/* This list is extensible */
};
static unsigned int asn_MAP_LaneManeuverCode_enum2value_1[] = {
	2,	/* leftTurn(2) */
	3,	/* rightTurn(3) */
	5,	/* softLeftTurn(5) */
	6,	/* softRightTurn(6) */
	4,	/* straightAhead(4) */
	1,	/* uTurn(1) */
	0	/* unknown(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_LaneManeuverCode_specs_1 = {
	asn_MAP_LaneManeuverCode_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_LaneManeuverCode_enum2value_1,	/* N => "tag"; sorted by N */
	7,	/* Number of elements in the maps */
	8,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_LaneManeuverCode_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LaneManeuverCode = {
	"LaneManeuverCode",
	"LaneManeuverCode",
	LaneManeuverCode_free,
	LaneManeuverCode_print,
	LaneManeuverCode_constraint,
	LaneManeuverCode_decode_ber,
	LaneManeuverCode_encode_der,
	LaneManeuverCode_decode_xer,
	LaneManeuverCode_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LaneManeuverCode_tags_1,
	sizeof(asn_DEF_LaneManeuverCode_tags_1)
		/sizeof(asn_DEF_LaneManeuverCode_tags_1[0]), /* 1 */
	asn_DEF_LaneManeuverCode_tags_1,	/* Same as above */
	sizeof(asn_DEF_LaneManeuverCode_tags_1)
		/sizeof(asn_DEF_LaneManeuverCode_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_LaneManeuverCode_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [LaneNumber] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [LaneNumber] >>> ***/

typedef OCTET_STRING_t	 LaneNumber_t;

/*** <<< FUNC-DECLS [LaneNumber] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LaneNumber;
asn_struct_free_f LaneNumber_free;
asn_struct_print_f LaneNumber_print;
asn_constr_check_f LaneNumber_constraint;
ber_type_decoder_f LaneNumber_decode_ber;
der_type_encoder_f LaneNumber_encode_der;
xer_type_decoder_f LaneNumber_decode_xer;
xer_type_encoder_f LaneNumber_encode_xer;

/*** <<< CODE [LaneNumber] >>> ***/

int
LaneNumber_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
LaneNumber_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
LaneNumber_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LaneNumber_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LaneNumber_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LaneNumber_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LaneNumber_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LaneNumber_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LaneNumber_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneNumber_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LaneNumber_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LaneNumber_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LaneNumber_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneNumber_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LaneNumber] >>> ***/

static ber_tlv_tag_t asn_DEF_LaneNumber_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LaneNumber = {
	"LaneNumber",
	"LaneNumber",
	LaneNumber_free,
	LaneNumber_print,
	LaneNumber_constraint,
	LaneNumber_decode_ber,
	LaneNumber_encode_der,
	LaneNumber_decode_xer,
	LaneNumber_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LaneNumber_tags_1,
	sizeof(asn_DEF_LaneNumber_tags_1)
		/sizeof(asn_DEF_LaneNumber_tags_1[0]), /* 1 */
	asn_DEF_LaneNumber_tags_1,	/* Same as above */
	sizeof(asn_DEF_LaneNumber_tags_1)
		/sizeof(asn_DEF_LaneNumber_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [LaneSet] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [LaneSet] >>> ***/

typedef OCTET_STRING_t	 LaneSet_t;

/*** <<< FUNC-DECLS [LaneSet] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LaneSet;
asn_struct_free_f LaneSet_free;
asn_struct_print_f LaneSet_print;
asn_constr_check_f LaneSet_constraint;
ber_type_decoder_f LaneSet_decode_ber;
der_type_encoder_f LaneSet_encode_der;
xer_type_decoder_f LaneSet_decode_xer;
xer_type_encoder_f LaneSet_encode_xer;

/*** <<< CODE [LaneSet] >>> ***/

int
LaneSet_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
LaneSet_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
LaneSet_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LaneSet_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LaneSet_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LaneSet_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LaneSet_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LaneSet_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LaneSet_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneSet_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LaneSet_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LaneSet_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LaneSet_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneSet_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LaneSet] >>> ***/

static ber_tlv_tag_t asn_DEF_LaneSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LaneSet = {
	"LaneSet",
	"LaneSet",
	LaneSet_free,
	LaneSet_print,
	LaneSet_constraint,
	LaneSet_decode_ber,
	LaneSet_encode_der,
	LaneSet_decode_xer,
	LaneSet_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LaneSet_tags_1,
	sizeof(asn_DEF_LaneSet_tags_1)
		/sizeof(asn_DEF_LaneSet_tags_1[0]), /* 1 */
	asn_DEF_LaneSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_LaneSet_tags_1)
		/sizeof(asn_DEF_LaneSet_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [LaneWidth] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [LaneWidth] >>> ***/

typedef long	 LaneWidth_t;

/*** <<< FUNC-DECLS [LaneWidth] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LaneWidth;
asn_struct_free_f LaneWidth_free;
asn_struct_print_f LaneWidth_print;
asn_constr_check_f LaneWidth_constraint;
ber_type_decoder_f LaneWidth_decode_ber;
der_type_encoder_f LaneWidth_encode_der;
xer_type_decoder_f LaneWidth_decode_xer;
xer_type_encoder_f LaneWidth_encode_xer;

/*** <<< CODE [LaneWidth] >>> ***/

int
LaneWidth_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
LaneWidth_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
LaneWidth_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LaneWidth_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LaneWidth_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LaneWidth_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LaneWidth_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LaneWidth_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LaneWidth_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneWidth_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LaneWidth_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LaneWidth_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LaneWidth_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LaneWidth_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LaneWidth] >>> ***/

static ber_tlv_tag_t asn_DEF_LaneWidth_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LaneWidth = {
	"LaneWidth",
	"LaneWidth",
	LaneWidth_free,
	LaneWidth_print,
	LaneWidth_constraint,
	LaneWidth_decode_ber,
	LaneWidth_encode_der,
	LaneWidth_decode_xer,
	LaneWidth_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LaneWidth_tags_1,
	sizeof(asn_DEF_LaneWidth_tags_1)
		/sizeof(asn_DEF_LaneWidth_tags_1[0]), /* 1 */
	asn_DEF_LaneWidth_tags_1,	/* Same as above */
	sizeof(asn_DEF_LaneWidth_tags_1)
		/sizeof(asn_DEF_LaneWidth_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Latitude] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Latitude] >>> ***/

typedef long	 Latitude_t;

/*** <<< FUNC-DECLS [Latitude] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Latitude;
asn_struct_free_f Latitude_free;
asn_struct_print_f Latitude_print;
asn_constr_check_f Latitude_constraint;
ber_type_decoder_f Latitude_decode_ber;
der_type_encoder_f Latitude_encode_der;
xer_type_decoder_f Latitude_decode_xer;
xer_type_encoder_f Latitude_encode_xer;

/*** <<< CODE [Latitude] >>> ***/

int
Latitude_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -900000000 && value <= 900000001)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
Latitude_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
Latitude_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Latitude_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Latitude_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Latitude_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Latitude_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Latitude_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Latitude_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Latitude_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Latitude_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Latitude_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Latitude_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Latitude_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Latitude] >>> ***/

static ber_tlv_tag_t asn_DEF_Latitude_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Latitude = {
	"Latitude",
	"Latitude",
	Latitude_free,
	Latitude_print,
	Latitude_constraint,
	Latitude_decode_ber,
	Latitude_encode_der,
	Latitude_decode_xer,
	Latitude_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Latitude_tags_1,
	sizeof(asn_DEF_Latitude_tags_1)
		/sizeof(asn_DEF_Latitude_tags_1[0]), /* 1 */
	asn_DEF_Latitude_tags_1,	/* Same as above */
	sizeof(asn_DEF_Latitude_tags_1)
		/sizeof(asn_DEF_Latitude_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [LayerID] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [LayerID] >>> ***/

typedef long	 LayerID_t;

/*** <<< FUNC-DECLS [LayerID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LayerID;
asn_struct_free_f LayerID_free;
asn_struct_print_f LayerID_print;
asn_constr_check_f LayerID_constraint;
ber_type_decoder_f LayerID_decode_ber;
der_type_encoder_f LayerID_encode_der;
xer_type_decoder_f LayerID_decode_xer;
xer_type_encoder_f LayerID_encode_xer;

/*** <<< CODE [LayerID] >>> ***/

int
LayerID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 100)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
LayerID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
LayerID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LayerID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LayerID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LayerID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LayerID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LayerID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LayerID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LayerID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LayerID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LayerID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LayerID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LayerID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LayerID] >>> ***/

static ber_tlv_tag_t asn_DEF_LayerID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LayerID = {
	"LayerID",
	"LayerID",
	LayerID_free,
	LayerID_print,
	LayerID_constraint,
	LayerID_decode_ber,
	LayerID_encode_der,
	LayerID_decode_xer,
	LayerID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LayerID_tags_1,
	sizeof(asn_DEF_LayerID_tags_1)
		/sizeof(asn_DEF_LayerID_tags_1[0]), /* 1 */
	asn_DEF_LayerID_tags_1,	/* Same as above */
	sizeof(asn_DEF_LayerID_tags_1)
		/sizeof(asn_DEF_LayerID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [LayerType] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [LayerType] >>> ***/

typedef enum LayerType {
	LayerType_none	= 0,
	LayerType_mixedContent	= 1,
	LayerType_generalMapData	= 2,
	LayerType_intersectionData	= 3,
	LayerType_curveData	= 4,
	LayerType_roadwaySectionData	= 5,
	LayerType_parkingAreaData	= 6,
	LayerType_sharedLaneData	= 7
	/*
	 * Enumeration is extensible
	 */
} e_LayerType;

/*** <<< TYPE-DECLS [LayerType] >>> ***/

typedef long	 LayerType_t;

/*** <<< FUNC-DECLS [LayerType] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LayerType;
asn_struct_free_f LayerType_free;
asn_struct_print_f LayerType_print;
asn_constr_check_f LayerType_constraint;
ber_type_decoder_f LayerType_decode_ber;
der_type_encoder_f LayerType_encode_der;
xer_type_decoder_f LayerType_decode_xer;
xer_type_encoder_f LayerType_encode_xer;

/*** <<< CODE [LayerType] >>> ***/

int
LayerType_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
LayerType_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
LayerType_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LayerType_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LayerType_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LayerType_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LayerType_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LayerType_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LayerType_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LayerType_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LayerType_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LayerType_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LayerType_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LayerType_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LayerType] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_LayerType_value2enum_1[] = {
	{ 0,	4,	"none" },
	{ 1,	12,	"mixedContent" },
	{ 2,	14,	"generalMapData" },
	{ 3,	16,	"intersectionData" },
	{ 4,	9,	"curveData" },
	{ 5,	18,	"roadwaySectionData" },
	{ 6,	15,	"parkingAreaData" },
	{ 7,	14,	"sharedLaneData" }
	/* This list is extensible */
};
static unsigned int asn_MAP_LayerType_enum2value_1[] = {
	4,	/* curveData(4) */
	2,	/* generalMapData(2) */
	3,	/* intersectionData(3) */
	1,	/* mixedContent(1) */
	0,	/* none(0) */
	6,	/* parkingAreaData(6) */
	5,	/* roadwaySectionData(5) */
	7	/* sharedLaneData(7) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_LayerType_specs_1 = {
	asn_MAP_LayerType_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_LayerType_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	9,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_LayerType_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LayerType = {
	"LayerType",
	"LayerType",
	LayerType_free,
	LayerType_print,
	LayerType_constraint,
	LayerType_decode_ber,
	LayerType_encode_der,
	LayerType_decode_xer,
	LayerType_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LayerType_tags_1,
	sizeof(asn_DEF_LayerType_tags_1)
		/sizeof(asn_DEF_LayerType_tags_1[0]), /* 1 */
	asn_DEF_LayerType_tags_1,	/* Same as above */
	sizeof(asn_DEF_LayerType_tags_1)
		/sizeof(asn_DEF_LayerType_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_LayerType_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [LightbarInUse] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [LightbarInUse] >>> ***/

typedef enum LightbarInUse {
	LightbarInUse_unavailable	= 0,
	LightbarInUse_notInUse	= 1,
	LightbarInUse_inUse	= 2,
	LightbarInUse_sirenInUse	= 3,
	LightbarInUse_yellowCautionLights	= 4,
	LightbarInUse_schooldBusLights	= 5,
	LightbarInUse_arrowSignsActive	= 6,
	LightbarInUse_slowMovingVehicle	= 7,
	LightbarInUse_freqStops	= 8,
	LightbarInUse_reserved	= 9
} e_LightbarInUse;

/*** <<< TYPE-DECLS [LightbarInUse] >>> ***/

typedef long	 LightbarInUse_t;

/*** <<< FUNC-DECLS [LightbarInUse] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_LightbarInUse;
asn_struct_free_f LightbarInUse_free;
asn_struct_print_f LightbarInUse_print;
asn_constr_check_f LightbarInUse_constraint;
ber_type_decoder_f LightbarInUse_decode_ber;
der_type_encoder_f LightbarInUse_encode_der;
xer_type_decoder_f LightbarInUse_decode_xer;
xer_type_encoder_f LightbarInUse_encode_xer;

/*** <<< CODE [LightbarInUse] >>> ***/

int
LightbarInUse_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
LightbarInUse_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
LightbarInUse_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	LightbarInUse_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
LightbarInUse_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	LightbarInUse_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
LightbarInUse_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	LightbarInUse_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
LightbarInUse_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LightbarInUse_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
LightbarInUse_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	LightbarInUse_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
LightbarInUse_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	LightbarInUse_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [LightbarInUse] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_LightbarInUse_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	8,	"notInUse" },
	{ 2,	5,	"inUse" },
	{ 3,	10,	"sirenInUse" },
	{ 4,	19,	"yellowCautionLights" },
	{ 5,	16,	"schooldBusLights" },
	{ 6,	16,	"arrowSignsActive" },
	{ 7,	17,	"slowMovingVehicle" },
	{ 8,	9,	"freqStops" },
	{ 9,	8,	"reserved" }
};
static unsigned int asn_MAP_LightbarInUse_enum2value_1[] = {
	6,	/* arrowSignsActive(6) */
	8,	/* freqStops(8) */
	2,	/* inUse(2) */
	1,	/* notInUse(1) */
	9,	/* reserved(9) */
	5,	/* schooldBusLights(5) */
	3,	/* sirenInUse(3) */
	7,	/* slowMovingVehicle(7) */
	0,	/* unavailable(0) */
	4	/* yellowCautionLights(4) */
};
static asn_INTEGER_specifics_t asn_SPC_LightbarInUse_specs_1 = {
	asn_MAP_LightbarInUse_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_LightbarInUse_enum2value_1,	/* N => "tag"; sorted by N */
	10,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_LightbarInUse_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_LightbarInUse = {
	"LightbarInUse",
	"LightbarInUse",
	LightbarInUse_free,
	LightbarInUse_print,
	LightbarInUse_constraint,
	LightbarInUse_decode_ber,
	LightbarInUse_encode_der,
	LightbarInUse_decode_xer,
	LightbarInUse_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_LightbarInUse_tags_1,
	sizeof(asn_DEF_LightbarInUse_tags_1)
		/sizeof(asn_DEF_LightbarInUse_tags_1[0]), /* 1 */
	asn_DEF_LightbarInUse_tags_1,	/* Same as above */
	sizeof(asn_DEF_LightbarInUse_tags_1)
		/sizeof(asn_DEF_LightbarInUse_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_LightbarInUse_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Location-quality] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [Location-quality] >>> ***/

typedef enum Location_quality {
	Location_quality_loc_qual_bt1m	= 0,
	Location_quality_loc_qual_bt5m	= 1,
	Location_quality_loc_qual_bt12m	= 2,
	Location_quality_loc_qual_bt50m	= 3,
	Location_quality_loc_qual_bt125m	= 4,
	Location_quality_loc_qual_bt500m	= 5,
	Location_quality_loc_qual_bt1250m	= 6,
	Location_quality_loc_qual_unknown	= 7
} e_Location_quality;

/*** <<< TYPE-DECLS [Location-quality] >>> ***/

typedef long	 Location_quality_t;

/*** <<< FUNC-DECLS [Location-quality] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Location_quality;
asn_struct_free_f Location_quality_free;
asn_struct_print_f Location_quality_print;
asn_constr_check_f Location_quality_constraint;
ber_type_decoder_f Location_quality_decode_ber;
der_type_encoder_f Location_quality_encode_der;
xer_type_decoder_f Location_quality_decode_xer;
xer_type_encoder_f Location_quality_encode_xer;

/*** <<< CODE [Location-quality] >>> ***/

int
Location_quality_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
Location_quality_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
Location_quality_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Location_quality_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Location_quality_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Location_quality_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Location_quality_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Location_quality_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Location_quality_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Location_quality_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Location_quality_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Location_quality_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Location_quality_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Location_quality_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Location-quality] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_Location_quality_value2enum_1[] = {
	{ 0,	13,	"loc-qual-bt1m" },
	{ 1,	13,	"loc-qual-bt5m" },
	{ 2,	14,	"loc-qual-bt12m" },
	{ 3,	14,	"loc-qual-bt50m" },
	{ 4,	15,	"loc-qual-bt125m" },
	{ 5,	15,	"loc-qual-bt500m" },
	{ 6,	16,	"loc-qual-bt1250m" },
	{ 7,	16,	"loc-qual-unknown" }
};
static unsigned int asn_MAP_Location_quality_enum2value_1[] = {
	6,	/* loc-qual-bt1250m(6) */
	4,	/* loc-qual-bt125m(4) */
	2,	/* loc-qual-bt12m(2) */
	0,	/* loc-qual-bt1m(0) */
	5,	/* loc-qual-bt500m(5) */
	3,	/* loc-qual-bt50m(3) */
	1,	/* loc-qual-bt5m(1) */
	7	/* loc-qual-unknown(7) */
};
static asn_INTEGER_specifics_t asn_SPC_Location_quality_specs_1 = {
	asn_MAP_Location_quality_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Location_quality_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_Location_quality_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Location_quality = {
	"Location-quality",
	"Location-quality",
	Location_quality_free,
	Location_quality_print,
	Location_quality_constraint,
	Location_quality_decode_ber,
	Location_quality_encode_der,
	Location_quality_decode_xer,
	Location_quality_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Location_quality_tags_1,
	sizeof(asn_DEF_Location_quality_tags_1)
		/sizeof(asn_DEF_Location_quality_tags_1[0]), /* 1 */
	asn_DEF_Location_quality_tags_1,	/* Same as above */
	sizeof(asn_DEF_Location_quality_tags_1)
		/sizeof(asn_DEF_Location_quality_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Location_quality_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Location-tech] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [Location-tech] >>> ***/

typedef enum Location_tech {
	Location_tech_loc_tech_unknown	= 0,
	Location_tech_loc_tech_GPS	= 1,
	Location_tech_loc_tech_DGPS	= 2,
	Location_tech_loc_tech_drGPS	= 3,
	Location_tech_loc_tech_drDGPS	= 4,
	Location_tech_loc_tech_dr	= 5,
	Location_tech_loc_tech_nav	= 6,
	/*
	 * Enumeration is extensible
	 */
	Location_tech_loc_tech_fault	= 31
} e_Location_tech;

/*** <<< TYPE-DECLS [Location-tech] >>> ***/

typedef long	 Location_tech_t;

/*** <<< FUNC-DECLS [Location-tech] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Location_tech;
asn_struct_free_f Location_tech_free;
asn_struct_print_f Location_tech_print;
asn_constr_check_f Location_tech_constraint;
ber_type_decoder_f Location_tech_decode_ber;
der_type_encoder_f Location_tech_encode_der;
xer_type_decoder_f Location_tech_decode_xer;
xer_type_encoder_f Location_tech_encode_xer;

/*** <<< CODE [Location-tech] >>> ***/

int
Location_tech_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
Location_tech_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
Location_tech_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Location_tech_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Location_tech_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Location_tech_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Location_tech_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Location_tech_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Location_tech_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Location_tech_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Location_tech_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Location_tech_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Location_tech_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Location_tech_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Location-tech] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_Location_tech_value2enum_1[] = {
	{ 0,	16,	"loc-tech-unknown" },
	{ 1,	12,	"loc-tech-GPS" },
	{ 2,	13,	"loc-tech-DGPS" },
	{ 3,	14,	"loc-tech-drGPS" },
	{ 4,	15,	"loc-tech-drDGPS" },
	{ 5,	11,	"loc-tech-dr" },
	{ 6,	12,	"loc-tech-nav" },
	{ 31,	14,	"loc-tech-fault" }
	/* This list is extensible */
};
static unsigned int asn_MAP_Location_tech_enum2value_1[] = {
	2,	/* loc-tech-DGPS(2) */
	1,	/* loc-tech-GPS(1) */
	5,	/* loc-tech-dr(5) */
	4,	/* loc-tech-drDGPS(4) */
	3,	/* loc-tech-drGPS(3) */
	7,	/* loc-tech-fault(31) */
	6,	/* loc-tech-nav(6) */
	0	/* loc-tech-unknown(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_Location_tech_specs_1 = {
	asn_MAP_Location_tech_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Location_tech_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	8,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_Location_tech_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Location_tech = {
	"Location-tech",
	"Location-tech",
	Location_tech_free,
	Location_tech_print,
	Location_tech_constraint,
	Location_tech_decode_ber,
	Location_tech_encode_der,
	Location_tech_decode_xer,
	Location_tech_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Location_tech_tags_1,
	sizeof(asn_DEF_Location_tech_tags_1)
		/sizeof(asn_DEF_Location_tech_tags_1[0]), /* 1 */
	asn_DEF_Location_tech_tags_1,	/* Same as above */
	sizeof(asn_DEF_Location_tech_tags_1)
		/sizeof(asn_DEF_Location_tech_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Location_tech_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Longitude] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Longitude] >>> ***/

typedef long	 Longitude_t;

/*** <<< FUNC-DECLS [Longitude] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Longitude;
asn_struct_free_f Longitude_free;
asn_struct_print_f Longitude_print;
asn_constr_check_f Longitude_constraint;
ber_type_decoder_f Longitude_decode_ber;
der_type_encoder_f Longitude_encode_der;
xer_type_decoder_f Longitude_decode_xer;
xer_type_encoder_f Longitude_encode_xer;

/*** <<< CODE [Longitude] >>> ***/

int
Longitude_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -1800000000 && value <= 1800000001)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
Longitude_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
Longitude_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Longitude_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Longitude_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Longitude_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Longitude_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Longitude_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Longitude_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Longitude_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Longitude_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Longitude_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Longitude_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Longitude_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Longitude] >>> ***/

static ber_tlv_tag_t asn_DEF_Longitude_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Longitude = {
	"Longitude",
	"Longitude",
	Longitude_free,
	Longitude_print,
	Longitude_constraint,
	Longitude_decode_ber,
	Longitude_encode_der,
	Longitude_decode_xer,
	Longitude_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Longitude_tags_1,
	sizeof(asn_DEF_Longitude_tags_1)
		/sizeof(asn_DEF_Longitude_tags_1[0]), /* 1 */
	asn_DEF_Longitude_tags_1,	/* Same as above */
	sizeof(asn_DEF_Longitude_tags_1)
		/sizeof(asn_DEF_Longitude_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [MinuteOfTheYear] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [MinuteOfTheYear] >>> ***/

typedef long	 MinuteOfTheYear_t;

/*** <<< FUNC-DECLS [MinuteOfTheYear] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MinuteOfTheYear;
asn_struct_free_f MinuteOfTheYear_free;
asn_struct_print_f MinuteOfTheYear_print;
asn_constr_check_f MinuteOfTheYear_constraint;
ber_type_decoder_f MinuteOfTheYear_decode_ber;
der_type_encoder_f MinuteOfTheYear_encode_der;
xer_type_decoder_f MinuteOfTheYear_decode_xer;
xer_type_encoder_f MinuteOfTheYear_encode_xer;

/*** <<< CODE [MinuteOfTheYear] >>> ***/

int
MinuteOfTheYear_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 525960)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
MinuteOfTheYear_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
MinuteOfTheYear_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	MinuteOfTheYear_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
MinuteOfTheYear_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	MinuteOfTheYear_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
MinuteOfTheYear_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	MinuteOfTheYear_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
MinuteOfTheYear_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MinuteOfTheYear_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
MinuteOfTheYear_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	MinuteOfTheYear_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
MinuteOfTheYear_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MinuteOfTheYear_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [MinuteOfTheYear] >>> ***/

static ber_tlv_tag_t asn_DEF_MinuteOfTheYear_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_MinuteOfTheYear = {
	"MinuteOfTheYear",
	"MinuteOfTheYear",
	MinuteOfTheYear_free,
	MinuteOfTheYear_print,
	MinuteOfTheYear_constraint,
	MinuteOfTheYear_decode_ber,
	MinuteOfTheYear_encode_der,
	MinuteOfTheYear_decode_xer,
	MinuteOfTheYear_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MinuteOfTheYear_tags_1,
	sizeof(asn_DEF_MinuteOfTheYear_tags_1)
		/sizeof(asn_DEF_MinuteOfTheYear_tags_1[0]), /* 1 */
	asn_DEF_MinuteOfTheYear_tags_1,	/* Same as above */
	sizeof(asn_DEF_MinuteOfTheYear_tags_1)
		/sizeof(asn_DEF_MinuteOfTheYear_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [MinutesDuration] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [MinutesDuration] >>> ***/

typedef long	 MinutesDuration_t;

/*** <<< FUNC-DECLS [MinutesDuration] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MinutesDuration;
asn_struct_free_f MinutesDuration_free;
asn_struct_print_f MinutesDuration_print;
asn_constr_check_f MinutesDuration_constraint;
ber_type_decoder_f MinutesDuration_decode_ber;
der_type_encoder_f MinutesDuration_encode_der;
xer_type_decoder_f MinutesDuration_decode_xer;
xer_type_encoder_f MinutesDuration_encode_xer;

/*** <<< CODE [MinutesDuration] >>> ***/

int
MinutesDuration_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
MinutesDuration_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
MinutesDuration_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	MinutesDuration_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
MinutesDuration_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	MinutesDuration_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
MinutesDuration_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	MinutesDuration_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
MinutesDuration_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MinutesDuration_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
MinutesDuration_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	MinutesDuration_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
MinutesDuration_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MinutesDuration_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [MinutesDuration] >>> ***/

static ber_tlv_tag_t asn_DEF_MinutesDuration_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_MinutesDuration = {
	"MinutesDuration",
	"MinutesDuration",
	MinutesDuration_free,
	MinutesDuration_print,
	MinutesDuration_constraint,
	MinutesDuration_decode_ber,
	MinutesDuration_encode_der,
	MinutesDuration_decode_xer,
	MinutesDuration_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MinutesDuration_tags_1,
	sizeof(asn_DEF_MinutesDuration_tags_1)
		/sizeof(asn_DEF_MinutesDuration_tags_1[0]), /* 1 */
	asn_DEF_MinutesDuration_tags_1,	/* Same as above */
	sizeof(asn_DEF_MinutesDuration_tags_1)
		/sizeof(asn_DEF_MinutesDuration_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [MsgCount] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [MsgCount] >>> ***/

typedef long	 MsgCount_t;

/*** <<< FUNC-DECLS [MsgCount] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MsgCount;
asn_struct_free_f MsgCount_free;
asn_struct_print_f MsgCount_print;
asn_constr_check_f MsgCount_constraint;
ber_type_decoder_f MsgCount_decode_ber;
der_type_encoder_f MsgCount_encode_der;
xer_type_decoder_f MsgCount_decode_xer;
xer_type_encoder_f MsgCount_encode_xer;

/*** <<< CODE [MsgCount] >>> ***/

int
MsgCount_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
MsgCount_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
MsgCount_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	MsgCount_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
MsgCount_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	MsgCount_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
MsgCount_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	MsgCount_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
MsgCount_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MsgCount_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
MsgCount_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	MsgCount_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
MsgCount_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MsgCount_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [MsgCount] >>> ***/

static ber_tlv_tag_t asn_DEF_MsgCount_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_MsgCount = {
	"MsgCount",
	"MsgCount",
	MsgCount_free,
	MsgCount_print,
	MsgCount_constraint,
	MsgCount_decode_ber,
	MsgCount_encode_der,
	MsgCount_decode_xer,
	MsgCount_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MsgCount_tags_1,
	sizeof(asn_DEF_MsgCount_tags_1)
		/sizeof(asn_DEF_MsgCount_tags_1[0]), /* 1 */
	asn_DEF_MsgCount_tags_1,	/* Same as above */
	sizeof(asn_DEF_MsgCount_tags_1)
		/sizeof(asn_DEF_MsgCount_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [MsgCRC] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [MsgCRC] >>> ***/

typedef OCTET_STRING_t	 MsgCRC_t;

/*** <<< FUNC-DECLS [MsgCRC] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MsgCRC;
asn_struct_free_f MsgCRC_free;
asn_struct_print_f MsgCRC_print;
asn_constr_check_f MsgCRC_constraint;
ber_type_decoder_f MsgCRC_decode_ber;
der_type_encoder_f MsgCRC_encode_der;
xer_type_decoder_f MsgCRC_decode_xer;
xer_type_encoder_f MsgCRC_encode_xer;

/*** <<< CODE [MsgCRC] >>> ***/

int
MsgCRC_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
MsgCRC_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
MsgCRC_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	MsgCRC_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
MsgCRC_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	MsgCRC_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
MsgCRC_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	MsgCRC_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
MsgCRC_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MsgCRC_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
MsgCRC_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	MsgCRC_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
MsgCRC_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MsgCRC_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [MsgCRC] >>> ***/

static ber_tlv_tag_t asn_DEF_MsgCRC_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_MsgCRC = {
	"MsgCRC",
	"MsgCRC",
	MsgCRC_free,
	MsgCRC_print,
	MsgCRC_constraint,
	MsgCRC_decode_ber,
	MsgCRC_encode_der,
	MsgCRC_decode_xer,
	MsgCRC_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MsgCRC_tags_1,
	sizeof(asn_DEF_MsgCRC_tags_1)
		/sizeof(asn_DEF_MsgCRC_tags_1[0]), /* 1 */
	asn_DEF_MsgCRC_tags_1,	/* Same as above */
	sizeof(asn_DEF_MsgCRC_tags_1)
		/sizeof(asn_DEF_MsgCRC_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [MultiVehicleResponse] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [MultiVehicleResponse] >>> ***/

typedef enum MultiVehicleResponse {
	MultiVehicleResponse_unavailable	= 0,
	MultiVehicleResponse_singleVehicle	= 1,
	MultiVehicleResponse_multiVehicle	= 2,
	MultiVehicleResponse_reserved	= 3
} e_MultiVehicleResponse;

/*** <<< TYPE-DECLS [MultiVehicleResponse] >>> ***/

typedef long	 MultiVehicleResponse_t;

/*** <<< FUNC-DECLS [MultiVehicleResponse] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MultiVehicleResponse;
asn_struct_free_f MultiVehicleResponse_free;
asn_struct_print_f MultiVehicleResponse_print;
asn_constr_check_f MultiVehicleResponse_constraint;
ber_type_decoder_f MultiVehicleResponse_decode_ber;
der_type_encoder_f MultiVehicleResponse_encode_der;
xer_type_decoder_f MultiVehicleResponse_decode_xer;
xer_type_encoder_f MultiVehicleResponse_encode_xer;

/*** <<< CODE [MultiVehicleResponse] >>> ***/

int
MultiVehicleResponse_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
MultiVehicleResponse_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
MultiVehicleResponse_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	MultiVehicleResponse_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
MultiVehicleResponse_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	MultiVehicleResponse_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
MultiVehicleResponse_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	MultiVehicleResponse_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
MultiVehicleResponse_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MultiVehicleResponse_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
MultiVehicleResponse_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	MultiVehicleResponse_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
MultiVehicleResponse_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MultiVehicleResponse_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [MultiVehicleResponse] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_MultiVehicleResponse_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	13,	"singleVehicle" },
	{ 2,	12,	"multiVehicle" },
	{ 3,	8,	"reserved" }
};
static unsigned int asn_MAP_MultiVehicleResponse_enum2value_1[] = {
	2,	/* multiVehicle(2) */
	3,	/* reserved(3) */
	1,	/* singleVehicle(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_MultiVehicleResponse_specs_1 = {
	asn_MAP_MultiVehicleResponse_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_MultiVehicleResponse_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_MultiVehicleResponse_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_MultiVehicleResponse = {
	"MultiVehicleResponse",
	"MultiVehicleResponse",
	MultiVehicleResponse_free,
	MultiVehicleResponse_print,
	MultiVehicleResponse_constraint,
	MultiVehicleResponse_decode_ber,
	MultiVehicleResponse_encode_der,
	MultiVehicleResponse_decode_xer,
	MultiVehicleResponse_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MultiVehicleResponse_tags_1,
	sizeof(asn_DEF_MultiVehicleResponse_tags_1)
		/sizeof(asn_DEF_MultiVehicleResponse_tags_1[0]), /* 1 */
	asn_DEF_MultiVehicleResponse_tags_1,	/* Same as above */
	sizeof(asn_DEF_MultiVehicleResponse_tags_1)
		/sizeof(asn_DEF_MultiVehicleResponse_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_MultiVehicleResponse_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [MUTCDCode] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [MUTCDCode] >>> ***/

typedef enum MUTCDCode {
	MUTCDCode_none	= 0,
	MUTCDCode_regulatory	= 1,
	MUTCDCode_warning	= 2,
	MUTCDCode_maintenance	= 3,
	MUTCDCode_motoristService	= 4,
	MUTCDCode_guide	= 5,
	MUTCDCode_rec	= 6
	/*
	 * Enumeration is extensible
	 */
} e_MUTCDCode;

/*** <<< TYPE-DECLS [MUTCDCode] >>> ***/

typedef long	 MUTCDCode_t;

/*** <<< FUNC-DECLS [MUTCDCode] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_MUTCDCode;
asn_struct_free_f MUTCDCode_free;
asn_struct_print_f MUTCDCode_print;
asn_constr_check_f MUTCDCode_constraint;
ber_type_decoder_f MUTCDCode_decode_ber;
der_type_encoder_f MUTCDCode_encode_der;
xer_type_decoder_f MUTCDCode_decode_xer;
xer_type_encoder_f MUTCDCode_encode_xer;

/*** <<< CODE [MUTCDCode] >>> ***/

int
MUTCDCode_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
MUTCDCode_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
MUTCDCode_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	MUTCDCode_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
MUTCDCode_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	MUTCDCode_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
MUTCDCode_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	MUTCDCode_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
MUTCDCode_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MUTCDCode_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
MUTCDCode_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	MUTCDCode_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
MUTCDCode_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	MUTCDCode_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [MUTCDCode] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_MUTCDCode_value2enum_1[] = {
	{ 0,	4,	"none" },
	{ 1,	10,	"regulatory" },
	{ 2,	7,	"warning" },
	{ 3,	11,	"maintenance" },
	{ 4,	15,	"motoristService" },
	{ 5,	5,	"guide" },
	{ 6,	3,	"rec" }
	/* This list is extensible */
};
static unsigned int asn_MAP_MUTCDCode_enum2value_1[] = {
	5,	/* guide(5) */
	3,	/* maintenance(3) */
	4,	/* motoristService(4) */
	0,	/* none(0) */
	6,	/* rec(6) */
	1,	/* regulatory(1) */
	2	/* warning(2) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_MUTCDCode_specs_1 = {
	asn_MAP_MUTCDCode_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_MUTCDCode_enum2value_1,	/* N => "tag"; sorted by N */
	7,	/* Number of elements in the maps */
	8,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_MUTCDCode_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_MUTCDCode = {
	"MUTCDCode",
	"MUTCDCode",
	MUTCDCode_free,
	MUTCDCode_print,
	MUTCDCode_constraint,
	MUTCDCode_decode_ber,
	MUTCDCode_encode_der,
	MUTCDCode_decode_xer,
	MUTCDCode_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_MUTCDCode_tags_1,
	sizeof(asn_DEF_MUTCDCode_tags_1)
		/sizeof(asn_DEF_MUTCDCode_tags_1[0]), /* 1 */
	asn_DEF_MUTCDCode_tags_1,	/* Same as above */
	sizeof(asn_DEF_MUTCDCode_tags_1)
		/sizeof(asn_DEF_MUTCDCode_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_MUTCDCode_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NMEA-MsgType] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [NMEA-MsgType] >>> ***/

typedef long	 NMEA_MsgType_t;

/*** <<< FUNC-DECLS [NMEA-MsgType] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NMEA_MsgType;
asn_struct_free_f NMEA_MsgType_free;
asn_struct_print_f NMEA_MsgType_print;
asn_constr_check_f NMEA_MsgType_constraint;
ber_type_decoder_f NMEA_MsgType_decode_ber;
der_type_encoder_f NMEA_MsgType_encode_der;
xer_type_decoder_f NMEA_MsgType_decode_xer;
xer_type_encoder_f NMEA_MsgType_encode_xer;

/*** <<< CODE [NMEA-MsgType] >>> ***/

int
NMEA_MsgType_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
NMEA_MsgType_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
NMEA_MsgType_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	NMEA_MsgType_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
NMEA_MsgType_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_MsgType_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
NMEA_MsgType_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	NMEA_MsgType_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
NMEA_MsgType_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_MsgType_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
NMEA_MsgType_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	NMEA_MsgType_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
NMEA_MsgType_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_MsgType_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [NMEA-MsgType] >>> ***/

static ber_tlv_tag_t asn_DEF_NMEA_MsgType_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_NMEA_MsgType = {
	"NMEA-MsgType",
	"NMEA-MsgType",
	NMEA_MsgType_free,
	NMEA_MsgType_print,
	NMEA_MsgType_constraint,
	NMEA_MsgType_decode_ber,
	NMEA_MsgType_encode_der,
	NMEA_MsgType_decode_xer,
	NMEA_MsgType_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_NMEA_MsgType_tags_1,
	sizeof(asn_DEF_NMEA_MsgType_tags_1)
		/sizeof(asn_DEF_NMEA_MsgType_tags_1[0]), /* 1 */
	asn_DEF_NMEA_MsgType_tags_1,	/* Same as above */
	sizeof(asn_DEF_NMEA_MsgType_tags_1)
		/sizeof(asn_DEF_NMEA_MsgType_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [NMEA-Payload] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [NMEA-Payload] >>> ***/

typedef OCTET_STRING_t	 NMEA_Payload_t;

/*** <<< FUNC-DECLS [NMEA-Payload] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NMEA_Payload;
asn_struct_free_f NMEA_Payload_free;
asn_struct_print_f NMEA_Payload_print;
asn_constr_check_f NMEA_Payload_constraint;
ber_type_decoder_f NMEA_Payload_decode_ber;
der_type_encoder_f NMEA_Payload_encode_der;
xer_type_decoder_f NMEA_Payload_decode_xer;
xer_type_encoder_f NMEA_Payload_encode_xer;

/*** <<< CODE [NMEA-Payload] >>> ***/

int
NMEA_Payload_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 1023)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
NMEA_Payload_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
NMEA_Payload_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	NMEA_Payload_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
NMEA_Payload_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_Payload_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
NMEA_Payload_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	NMEA_Payload_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
NMEA_Payload_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_Payload_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
NMEA_Payload_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	NMEA_Payload_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
NMEA_Payload_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_Payload_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [NMEA-Payload] >>> ***/

static ber_tlv_tag_t asn_DEF_NMEA_Payload_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_NMEA_Payload = {
	"NMEA-Payload",
	"NMEA-Payload",
	NMEA_Payload_free,
	NMEA_Payload_print,
	NMEA_Payload_constraint,
	NMEA_Payload_decode_ber,
	NMEA_Payload_encode_der,
	NMEA_Payload_decode_xer,
	NMEA_Payload_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_NMEA_Payload_tags_1,
	sizeof(asn_DEF_NMEA_Payload_tags_1)
		/sizeof(asn_DEF_NMEA_Payload_tags_1[0]), /* 1 */
	asn_DEF_NMEA_Payload_tags_1,	/* Same as above */
	sizeof(asn_DEF_NMEA_Payload_tags_1)
		/sizeof(asn_DEF_NMEA_Payload_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [NMEA-Revision] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [NMEA-Revision] >>> ***/

typedef enum NMEA_Revision {
	NMEA_Revision_unknown	= 0,
	NMEA_Revision_reserved	= 1,
	NMEA_Revision_rev1	= 10,
	NMEA_Revision_rev2	= 20,
	NMEA_Revision_rev3	= 30,
	NMEA_Revision_rev4	= 40,
	NMEA_Revision_rev5	= 50
	/*
	 * Enumeration is extensible
	 */
} e_NMEA_Revision;

/*** <<< TYPE-DECLS [NMEA-Revision] >>> ***/

typedef long	 NMEA_Revision_t;

/*** <<< FUNC-DECLS [NMEA-Revision] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NMEA_Revision;
asn_struct_free_f NMEA_Revision_free;
asn_struct_print_f NMEA_Revision_print;
asn_constr_check_f NMEA_Revision_constraint;
ber_type_decoder_f NMEA_Revision_decode_ber;
der_type_encoder_f NMEA_Revision_encode_der;
xer_type_decoder_f NMEA_Revision_decode_xer;
xer_type_encoder_f NMEA_Revision_encode_xer;

/*** <<< CODE [NMEA-Revision] >>> ***/

int
NMEA_Revision_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
NMEA_Revision_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
NMEA_Revision_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	NMEA_Revision_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
NMEA_Revision_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_Revision_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
NMEA_Revision_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	NMEA_Revision_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
NMEA_Revision_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_Revision_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
NMEA_Revision_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	NMEA_Revision_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
NMEA_Revision_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NMEA_Revision_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [NMEA-Revision] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_NMEA_Revision_value2enum_1[] = {
	{ 0,	7,	"unknown" },
	{ 1,	8,	"reserved" },
	{ 10,	4,	"rev1" },
	{ 20,	4,	"rev2" },
	{ 30,	4,	"rev3" },
	{ 40,	4,	"rev4" },
	{ 50,	4,	"rev5" }
	/* This list is extensible */
};
static unsigned int asn_MAP_NMEA_Revision_enum2value_1[] = {
	1,	/* reserved(1) */
	2,	/* rev1(10) */
	3,	/* rev2(20) */
	4,	/* rev3(30) */
	5,	/* rev4(40) */
	6,	/* rev5(50) */
	0	/* unknown(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_NMEA_Revision_specs_1 = {
	asn_MAP_NMEA_Revision_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_NMEA_Revision_enum2value_1,	/* N => "tag"; sorted by N */
	7,	/* Number of elements in the maps */
	8,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_NMEA_Revision_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_NMEA_Revision = {
	"NMEA-Revision",
	"NMEA-Revision",
	NMEA_Revision_free,
	NMEA_Revision_print,
	NMEA_Revision_constraint,
	NMEA_Revision_decode_ber,
	NMEA_Revision_encode_der,
	NMEA_Revision_decode_xer,
	NMEA_Revision_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_NMEA_Revision_tags_1,
	sizeof(asn_DEF_NMEA_Revision_tags_1)
		/sizeof(asn_DEF_NMEA_Revision_tags_1[0]), /* 1 */
	asn_DEF_NMEA_Revision_tags_1,	/* Same as above */
	sizeof(asn_DEF_NMEA_Revision_tags_1)
		/sizeof(asn_DEF_NMEA_Revision_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_NMEA_Revision_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NTCIPVehicleclass] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [NTCIPVehicleclass] >>> ***/

typedef OCTET_STRING_t	 NTCIPVehicleclass_t;

/*** <<< FUNC-DECLS [NTCIPVehicleclass] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NTCIPVehicleclass;
asn_struct_free_f NTCIPVehicleclass_free;
asn_struct_print_f NTCIPVehicleclass_print;
asn_constr_check_f NTCIPVehicleclass_constraint;
ber_type_decoder_f NTCIPVehicleclass_decode_ber;
der_type_encoder_f NTCIPVehicleclass_encode_der;
xer_type_decoder_f NTCIPVehicleclass_decode_xer;
xer_type_encoder_f NTCIPVehicleclass_encode_xer;

/*** <<< CODE [NTCIPVehicleclass] >>> ***/

int
NTCIPVehicleclass_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
NTCIPVehicleclass_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
NTCIPVehicleclass_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	NTCIPVehicleclass_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
NTCIPVehicleclass_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	NTCIPVehicleclass_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
NTCIPVehicleclass_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	NTCIPVehicleclass_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
NTCIPVehicleclass_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NTCIPVehicleclass_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
NTCIPVehicleclass_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	NTCIPVehicleclass_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
NTCIPVehicleclass_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	NTCIPVehicleclass_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [NTCIPVehicleclass] >>> ***/

static ber_tlv_tag_t asn_DEF_NTCIPVehicleclass_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_NTCIPVehicleclass = {
	"NTCIPVehicleclass",
	"NTCIPVehicleclass",
	NTCIPVehicleclass_free,
	NTCIPVehicleclass_print,
	NTCIPVehicleclass_constraint,
	NTCIPVehicleclass_decode_ber,
	NTCIPVehicleclass_encode_der,
	NTCIPVehicleclass_decode_xer,
	NTCIPVehicleclass_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_NTCIPVehicleclass_tags_1,
	sizeof(asn_DEF_NTCIPVehicleclass_tags_1)
		/sizeof(asn_DEF_NTCIPVehicleclass_tags_1[0]), /* 1 */
	asn_DEF_NTCIPVehicleclass_tags_1,	/* Same as above */
	sizeof(asn_DEF_NTCIPVehicleclass_tags_1)
		/sizeof(asn_DEF_NTCIPVehicleclass_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ObjectCount] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ObjectCount] >>> ***/

typedef long	 ObjectCount_t;

/*** <<< FUNC-DECLS [ObjectCount] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ObjectCount;
asn_struct_free_f ObjectCount_free;
asn_struct_print_f ObjectCount_print;
asn_constr_check_f ObjectCount_constraint;
ber_type_decoder_f ObjectCount_decode_ber;
der_type_encoder_f ObjectCount_encode_der;
xer_type_decoder_f ObjectCount_decode_xer;
xer_type_encoder_f ObjectCount_encode_xer;

/*** <<< CODE [ObjectCount] >>> ***/

int
ObjectCount_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 6000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ObjectCount_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ObjectCount_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ObjectCount_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ObjectCount_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ObjectCount_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ObjectCount_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ObjectCount_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ObjectCount_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ObjectCount_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ObjectCount_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ObjectCount_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ObjectCount_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ObjectCount_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ObjectCount] >>> ***/

static ber_tlv_tag_t asn_DEF_ObjectCount_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ObjectCount = {
	"ObjectCount",
	"ObjectCount",
	ObjectCount_free,
	ObjectCount_print,
	ObjectCount_constraint,
	ObjectCount_decode_ber,
	ObjectCount_encode_der,
	ObjectCount_decode_xer,
	ObjectCount_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ObjectCount_tags_1,
	sizeof(asn_DEF_ObjectCount_tags_1)
		/sizeof(asn_DEF_ObjectCount_tags_1[0]), /* 1 */
	asn_DEF_ObjectCount_tags_1,	/* Same as above */
	sizeof(asn_DEF_ObjectCount_tags_1)
		/sizeof(asn_DEF_ObjectCount_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ObstacleDirection] >>> ***/

#include "Heading.h"

/*** <<< TYPE-DECLS [ObstacleDirection] >>> ***/

typedef Heading_t	 ObstacleDirection_t;

/*** <<< FUNC-DECLS [ObstacleDirection] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ObstacleDirection;
asn_struct_free_f ObstacleDirection_free;
asn_struct_print_f ObstacleDirection_print;
asn_constr_check_f ObstacleDirection_constraint;
ber_type_decoder_f ObstacleDirection_decode_ber;
der_type_encoder_f ObstacleDirection_encode_der;
xer_type_decoder_f ObstacleDirection_decode_xer;
xer_type_encoder_f ObstacleDirection_encode_xer;

/*** <<< CODE [ObstacleDirection] >>> ***/

int
ObstacleDirection_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 28800)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Heading,
 * so here we adjust the DEF accordingly.
 */
static void
ObstacleDirection_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_Heading.free_struct;
	td->print_struct   = asn_DEF_Heading.print_struct;
	td->check_constraints = asn_DEF_Heading.check_constraints;
	td->ber_decoder    = asn_DEF_Heading.ber_decoder;
	td->der_encoder    = asn_DEF_Heading.der_encoder;
	td->xer_decoder    = asn_DEF_Heading.xer_decoder;
	td->xer_encoder    = asn_DEF_Heading.xer_encoder;
	td->uper_decoder   = asn_DEF_Heading.uper_decoder;
	td->uper_encoder   = asn_DEF_Heading.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_Heading.per_constraints;
	td->elements       = asn_DEF_Heading.elements;
	td->elements_count = asn_DEF_Heading.elements_count;
	td->specifics      = asn_DEF_Heading.specifics;
}

void
ObstacleDirection_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ObstacleDirection_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ObstacleDirection_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ObstacleDirection_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ObstacleDirection_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ObstacleDirection_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ObstacleDirection_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ObstacleDirection_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ObstacleDirection_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ObstacleDirection_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ObstacleDirection_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ObstacleDirection_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ObstacleDirection] >>> ***/

static ber_tlv_tag_t asn_DEF_ObstacleDirection_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ObstacleDirection = {
	"ObstacleDirection",
	"ObstacleDirection",
	ObstacleDirection_free,
	ObstacleDirection_print,
	ObstacleDirection_constraint,
	ObstacleDirection_decode_ber,
	ObstacleDirection_encode_der,
	ObstacleDirection_decode_xer,
	ObstacleDirection_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ObstacleDirection_tags_1,
	sizeof(asn_DEF_ObstacleDirection_tags_1)
		/sizeof(asn_DEF_ObstacleDirection_tags_1[0]), /* 1 */
	asn_DEF_ObstacleDirection_tags_1,	/* Same as above */
	sizeof(asn_DEF_ObstacleDirection_tags_1)
		/sizeof(asn_DEF_ObstacleDirection_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ObstacleDistance] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ObstacleDistance] >>> ***/

typedef long	 ObstacleDistance_t;

/*** <<< FUNC-DECLS [ObstacleDistance] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ObstacleDistance;
asn_struct_free_f ObstacleDistance_free;
asn_struct_print_f ObstacleDistance_print;
asn_constr_check_f ObstacleDistance_constraint;
ber_type_decoder_f ObstacleDistance_decode_ber;
der_type_encoder_f ObstacleDistance_encode_der;
xer_type_decoder_f ObstacleDistance_decode_xer;
xer_type_encoder_f ObstacleDistance_encode_xer;

/*** <<< CODE [ObstacleDistance] >>> ***/

int
ObstacleDistance_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ObstacleDistance_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ObstacleDistance_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ObstacleDistance_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ObstacleDistance_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ObstacleDistance_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ObstacleDistance_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ObstacleDistance_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ObstacleDistance_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ObstacleDistance_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ObstacleDistance_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ObstacleDistance_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ObstacleDistance_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ObstacleDistance_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ObstacleDistance] >>> ***/

static ber_tlv_tag_t asn_DEF_ObstacleDistance_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ObstacleDistance = {
	"ObstacleDistance",
	"ObstacleDistance",
	ObstacleDistance_free,
	ObstacleDistance_print,
	ObstacleDistance_constraint,
	ObstacleDistance_decode_ber,
	ObstacleDistance_encode_der,
	ObstacleDistance_decode_xer,
	ObstacleDistance_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ObstacleDistance_tags_1,
	sizeof(asn_DEF_ObstacleDistance_tags_1)
		/sizeof(asn_DEF_ObstacleDistance_tags_1[0]), /* 1 */
	asn_DEF_ObstacleDistance_tags_1,	/* Same as above */
	sizeof(asn_DEF_ObstacleDistance_tags_1)
		/sizeof(asn_DEF_ObstacleDistance_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Payload] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [Payload] >>> ***/

typedef OCTET_STRING_t	 Payload_t;

/*** <<< FUNC-DECLS [Payload] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Payload;
asn_struct_free_f Payload_free;
asn_struct_print_f Payload_print;
asn_constr_check_f Payload_constraint;
ber_type_decoder_f Payload_decode_ber;
der_type_encoder_f Payload_encode_der;
xer_type_decoder_f Payload_decode_xer;
xer_type_encoder_f Payload_encode_xer;

/*** <<< CODE [Payload] >>> ***/

int
Payload_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 64)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
Payload_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
Payload_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Payload_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Payload_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Payload_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Payload_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Payload_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Payload_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Payload_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Payload_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Payload_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Payload_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Payload_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Payload] >>> ***/

static ber_tlv_tag_t asn_DEF_Payload_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Payload = {
	"Payload",
	"Payload",
	Payload_free,
	Payload_print,
	Payload_constraint,
	Payload_decode_ber,
	Payload_encode_der,
	Payload_decode_xer,
	Payload_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Payload_tags_1,
	sizeof(asn_DEF_Payload_tags_1)
		/sizeof(asn_DEF_Payload_tags_1[0]), /* 1 */
	asn_DEF_Payload_tags_1,	/* Same as above */
	sizeof(asn_DEF_Payload_tags_1)
		/sizeof(asn_DEF_Payload_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PayloadData] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [PayloadData] >>> ***/

typedef OCTET_STRING_t	 PayloadData_t;

/*** <<< FUNC-DECLS [PayloadData] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PayloadData;
asn_struct_free_f PayloadData_free;
asn_struct_print_f PayloadData_print;
asn_constr_check_f PayloadData_constraint;
ber_type_decoder_f PayloadData_decode_ber;
der_type_encoder_f PayloadData_encode_der;
xer_type_decoder_f PayloadData_decode_xer;
xer_type_encoder_f PayloadData_encode_xer;

/*** <<< CODE [PayloadData] >>> ***/

int
PayloadData_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 2048)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
PayloadData_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
PayloadData_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PayloadData_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PayloadData_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PayloadData_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PayloadData_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PayloadData_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PayloadData_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PayloadData_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PayloadData_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PayloadData_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PayloadData_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PayloadData_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PayloadData] >>> ***/

static ber_tlv_tag_t asn_DEF_PayloadData_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PayloadData = {
	"PayloadData",
	"PayloadData",
	PayloadData_free,
	PayloadData_print,
	PayloadData_constraint,
	PayloadData_decode_ber,
	PayloadData_encode_der,
	PayloadData_decode_xer,
	PayloadData_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PayloadData_tags_1,
	sizeof(asn_DEF_PayloadData_tags_1)
		/sizeof(asn_DEF_PayloadData_tags_1[0]), /* 1 */
	asn_DEF_PayloadData_tags_1,	/* Same as above */
	sizeof(asn_DEF_PayloadData_tags_1)
		/sizeof(asn_DEF_PayloadData_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PedestrianDetect] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [PedestrianDetect] >>> ***/

typedef enum PedestrianDetect {
	PedestrianDetect_none	= 0,
	PedestrianDetect_maybe	= 1,
	PedestrianDetect_one	= 2,
	PedestrianDetect_some	= 3
	/*
	 * Enumeration is extensible
	 */
} e_PedestrianDetect;

/*** <<< TYPE-DECLS [PedestrianDetect] >>> ***/

typedef long	 PedestrianDetect_t;

/*** <<< FUNC-DECLS [PedestrianDetect] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PedestrianDetect;
asn_struct_free_f PedestrianDetect_free;
asn_struct_print_f PedestrianDetect_print;
asn_constr_check_f PedestrianDetect_constraint;
ber_type_decoder_f PedestrianDetect_decode_ber;
der_type_encoder_f PedestrianDetect_encode_der;
xer_type_decoder_f PedestrianDetect_decode_xer;
xer_type_encoder_f PedestrianDetect_encode_xer;

/*** <<< CODE [PedestrianDetect] >>> ***/

int
PedestrianDetect_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
PedestrianDetect_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
PedestrianDetect_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PedestrianDetect_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PedestrianDetect_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PedestrianDetect_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PedestrianDetect_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PedestrianDetect_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PedestrianDetect_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PedestrianDetect_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PedestrianDetect_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PedestrianDetect_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PedestrianDetect_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PedestrianDetect_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PedestrianDetect] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_PedestrianDetect_value2enum_1[] = {
	{ 0,	4,	"none" },
	{ 1,	5,	"maybe" },
	{ 2,	3,	"one" },
	{ 3,	4,	"some" }
	/* This list is extensible */
};
static unsigned int asn_MAP_PedestrianDetect_enum2value_1[] = {
	1,	/* maybe(1) */
	0,	/* none(0) */
	2,	/* one(2) */
	3	/* some(3) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_PedestrianDetect_specs_1 = {
	asn_MAP_PedestrianDetect_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_PedestrianDetect_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	5,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_PedestrianDetect_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PedestrianDetect = {
	"PedestrianDetect",
	"PedestrianDetect",
	PedestrianDetect_free,
	PedestrianDetect_print,
	PedestrianDetect_constraint,
	PedestrianDetect_decode_ber,
	PedestrianDetect_encode_der,
	PedestrianDetect_decode_xer,
	PedestrianDetect_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PedestrianDetect_tags_1,
	sizeof(asn_DEF_PedestrianDetect_tags_1)
		/sizeof(asn_DEF_PedestrianDetect_tags_1[0]), /* 1 */
	asn_DEF_PedestrianDetect_tags_1,	/* Same as above */
	sizeof(asn_DEF_PedestrianDetect_tags_1)
		/sizeof(asn_DEF_PedestrianDetect_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_PedestrianDetect_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [PedestrianSignalState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [PedestrianSignalState] >>> ***/

typedef enum PedestrianSignalState {
	PedestrianSignalState_unavailable	= 0,
	PedestrianSignalState_stop	= 1,
	PedestrianSignalState_caution	= 2,
	PedestrianSignalState_walk	= 3
	/*
	 * Enumeration is extensible
	 */
} e_PedestrianSignalState;

/*** <<< TYPE-DECLS [PedestrianSignalState] >>> ***/

typedef long	 PedestrianSignalState_t;

/*** <<< FUNC-DECLS [PedestrianSignalState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PedestrianSignalState;
asn_struct_free_f PedestrianSignalState_free;
asn_struct_print_f PedestrianSignalState_print;
asn_constr_check_f PedestrianSignalState_constraint;
ber_type_decoder_f PedestrianSignalState_decode_ber;
der_type_encoder_f PedestrianSignalState_encode_der;
xer_type_decoder_f PedestrianSignalState_decode_xer;
xer_type_encoder_f PedestrianSignalState_encode_xer;

/*** <<< CODE [PedestrianSignalState] >>> ***/

int
PedestrianSignalState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
PedestrianSignalState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
PedestrianSignalState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PedestrianSignalState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PedestrianSignalState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PedestrianSignalState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PedestrianSignalState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PedestrianSignalState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PedestrianSignalState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PedestrianSignalState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PedestrianSignalState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PedestrianSignalState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PedestrianSignalState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PedestrianSignalState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PedestrianSignalState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_PedestrianSignalState_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	4,	"stop" },
	{ 2,	7,	"caution" },
	{ 3,	4,	"walk" }
	/* This list is extensible */
};
static unsigned int asn_MAP_PedestrianSignalState_enum2value_1[] = {
	2,	/* caution(2) */
	1,	/* stop(1) */
	0,	/* unavailable(0) */
	3	/* walk(3) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_PedestrianSignalState_specs_1 = {
	asn_MAP_PedestrianSignalState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_PedestrianSignalState_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	5,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_PedestrianSignalState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PedestrianSignalState = {
	"PedestrianSignalState",
	"PedestrianSignalState",
	PedestrianSignalState_free,
	PedestrianSignalState_print,
	PedestrianSignalState_constraint,
	PedestrianSignalState_decode_ber,
	PedestrianSignalState_encode_der,
	PedestrianSignalState_decode_xer,
	PedestrianSignalState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PedestrianSignalState_tags_1,
	sizeof(asn_DEF_PedestrianSignalState_tags_1)
		/sizeof(asn_DEF_PedestrianSignalState_tags_1[0]), /* 1 */
	asn_DEF_PedestrianSignalState_tags_1,	/* Same as above */
	sizeof(asn_DEF_PedestrianSignalState_tags_1)
		/sizeof(asn_DEF_PedestrianSignalState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_PedestrianSignalState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [PositionConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [PositionConfidence] >>> ***/

typedef enum PositionConfidence {
	PositionConfidence_unavailable	= 0,
	PositionConfidence_a500m	= 1,
	PositionConfidence_a200m	= 2,
	PositionConfidence_a100m	= 3,
	PositionConfidence_a50m	= 4,
	PositionConfidence_a20m	= 5,
	PositionConfidence_a10m	= 6,
	PositionConfidence_a5m	= 7,
	PositionConfidence_a2m	= 8,
	PositionConfidence_a1m	= 9,
	PositionConfidence_a50cm	= 10,
	PositionConfidence_a20cm	= 11,
	PositionConfidence_a10cm	= 12,
	PositionConfidence_a5cm	= 13,
	PositionConfidence_a2cm	= 14,
	PositionConfidence_a1cm	= 15
} e_PositionConfidence;

/*** <<< TYPE-DECLS [PositionConfidence] >>> ***/

typedef long	 PositionConfidence_t;

/*** <<< FUNC-DECLS [PositionConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PositionConfidence;
asn_struct_free_f PositionConfidence_free;
asn_struct_print_f PositionConfidence_print;
asn_constr_check_f PositionConfidence_constraint;
ber_type_decoder_f PositionConfidence_decode_ber;
der_type_encoder_f PositionConfidence_encode_der;
xer_type_decoder_f PositionConfidence_decode_xer;
xer_type_encoder_f PositionConfidence_encode_xer;

/*** <<< CODE [PositionConfidence] >>> ***/

int
PositionConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
PositionConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
PositionConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PositionConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PositionConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PositionConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PositionConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PositionConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PositionConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PositionConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PositionConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PositionConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PositionConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PositionConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PositionConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_PositionConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	5,	"a500m" },
	{ 2,	5,	"a200m" },
	{ 3,	5,	"a100m" },
	{ 4,	4,	"a50m" },
	{ 5,	4,	"a20m" },
	{ 6,	4,	"a10m" },
	{ 7,	3,	"a5m" },
	{ 8,	3,	"a2m" },
	{ 9,	3,	"a1m" },
	{ 10,	5,	"a50cm" },
	{ 11,	5,	"a20cm" },
	{ 12,	5,	"a10cm" },
	{ 13,	4,	"a5cm" },
	{ 14,	4,	"a2cm" },
	{ 15,	4,	"a1cm" }
};
static unsigned int asn_MAP_PositionConfidence_enum2value_1[] = {
	3,	/* a100m(3) */
	12,	/* a10cm(12) */
	6,	/* a10m(6) */
	15,	/* a1cm(15) */
	9,	/* a1m(9) */
	2,	/* a200m(2) */
	11,	/* a20cm(11) */
	5,	/* a20m(5) */
	14,	/* a2cm(14) */
	8,	/* a2m(8) */
	1,	/* a500m(1) */
	10,	/* a50cm(10) */
	4,	/* a50m(4) */
	13,	/* a5cm(13) */
	7,	/* a5m(7) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_PositionConfidence_specs_1 = {
	asn_MAP_PositionConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_PositionConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	16,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_PositionConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PositionConfidence = {
	"PositionConfidence",
	"PositionConfidence",
	PositionConfidence_free,
	PositionConfidence_print,
	PositionConfidence_constraint,
	PositionConfidence_decode_ber,
	PositionConfidence_encode_der,
	PositionConfidence_decode_xer,
	PositionConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PositionConfidence_tags_1,
	sizeof(asn_DEF_PositionConfidence_tags_1)
		/sizeof(asn_DEF_PositionConfidence_tags_1[0]), /* 1 */
	asn_DEF_PositionConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_PositionConfidence_tags_1)
		/sizeof(asn_DEF_PositionConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_PositionConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [PreemptState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [PreemptState] >>> ***/

typedef enum PreemptState {
	PreemptState_none	= 0,
	PreemptState_other	= 1,
	PreemptState_notActive	= 2,
	PreemptState_notActiveWithCall	= 3,
	PreemptState_entryStarted	= 4,
	PreemptState_trackService	= 5,
	PreemptState_dwell	= 6,
	PreemptState_linkActive	= 7,
	PreemptState_existStarted	= 8,
	PreemptState_maximumPresence	= 9,
	PreemptState_ackowledgedButOverridden	= 10
	/*
	 * Enumeration is extensible
	 */
} e_PreemptState;

/*** <<< TYPE-DECLS [PreemptState] >>> ***/

typedef long	 PreemptState_t;

/*** <<< FUNC-DECLS [PreemptState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PreemptState;
asn_struct_free_f PreemptState_free;
asn_struct_print_f PreemptState_print;
asn_constr_check_f PreemptState_constraint;
ber_type_decoder_f PreemptState_decode_ber;
der_type_encoder_f PreemptState_encode_der;
xer_type_decoder_f PreemptState_decode_xer;
xer_type_encoder_f PreemptState_encode_xer;

/*** <<< CODE [PreemptState] >>> ***/

int
PreemptState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
PreemptState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
PreemptState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PreemptState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PreemptState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PreemptState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PreemptState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PreemptState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PreemptState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PreemptState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PreemptState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PreemptState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PreemptState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PreemptState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PreemptState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_PreemptState_value2enum_1[] = {
	{ 0,	4,	"none" },
	{ 1,	5,	"other" },
	{ 2,	9,	"notActive" },
	{ 3,	17,	"notActiveWithCall" },
	{ 4,	12,	"entryStarted" },
	{ 5,	12,	"trackService" },
	{ 6,	5,	"dwell" },
	{ 7,	10,	"linkActive" },
	{ 8,	12,	"existStarted" },
	{ 9,	15,	"maximumPresence" },
	{ 10,	24,	"ackowledgedButOverridden" }
	/* This list is extensible */
};
static unsigned int asn_MAP_PreemptState_enum2value_1[] = {
	10,	/* ackowledgedButOverridden(10) */
	6,	/* dwell(6) */
	4,	/* entryStarted(4) */
	8,	/* existStarted(8) */
	7,	/* linkActive(7) */
	9,	/* maximumPresence(9) */
	0,	/* none(0) */
	2,	/* notActive(2) */
	3,	/* notActiveWithCall(3) */
	1,	/* other(1) */
	5	/* trackService(5) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_PreemptState_specs_1 = {
	asn_MAP_PreemptState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_PreemptState_enum2value_1,	/* N => "tag"; sorted by N */
	11,	/* Number of elements in the maps */
	12,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_PreemptState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PreemptState = {
	"PreemptState",
	"PreemptState",
	PreemptState_free,
	PreemptState_print,
	PreemptState_constraint,
	PreemptState_decode_ber,
	PreemptState_encode_der,
	PreemptState_decode_xer,
	PreemptState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PreemptState_tags_1,
	sizeof(asn_DEF_PreemptState_tags_1)
		/sizeof(asn_DEF_PreemptState_tags_1[0]), /* 1 */
	asn_DEF_PreemptState_tags_1,	/* Same as above */
	sizeof(asn_DEF_PreemptState_tags_1)
		/sizeof(asn_DEF_PreemptState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_PreemptState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Priority] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [Priority] >>> ***/

typedef OCTET_STRING_t	 Priority_t;

/*** <<< FUNC-DECLS [Priority] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Priority;
asn_struct_free_f Priority_free;
asn_struct_print_f Priority_print;
asn_constr_check_f Priority_constraint;
ber_type_decoder_f Priority_decode_ber;
der_type_encoder_f Priority_encode_der;
xer_type_decoder_f Priority_decode_xer;
xer_type_encoder_f Priority_encode_xer;

/*** <<< CODE [Priority] >>> ***/

int
Priority_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
Priority_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
Priority_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Priority_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Priority_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Priority_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Priority_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Priority_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Priority_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Priority_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Priority_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Priority_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Priority_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Priority_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Priority] >>> ***/

static ber_tlv_tag_t asn_DEF_Priority_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Priority = {
	"Priority",
	"Priority",
	Priority_free,
	Priority_print,
	Priority_constraint,
	Priority_decode_ber,
	Priority_encode_der,
	Priority_decode_xer,
	Priority_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Priority_tags_1,
	sizeof(asn_DEF_Priority_tags_1)
		/sizeof(asn_DEF_Priority_tags_1[0]), /* 1 */
	asn_DEF_Priority_tags_1,	/* Same as above */
	sizeof(asn_DEF_Priority_tags_1)
		/sizeof(asn_DEF_Priority_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PriorityState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [PriorityState] >>> ***/

typedef enum PriorityState {
	PriorityState_noneActive	= 0,
	PriorityState_none	= 1,
	PriorityState_requested	= 2,
	PriorityState_active	= 3,
	PriorityState_activeButIhibitd	= 4,
	PriorityState_seccess	= 5,
	PriorityState_removed	= 6,
	PriorityState_clearFail	= 7,
	PriorityState_detectFail	= 8,
	PriorityState_detectClear	= 9,
	PriorityState_abort	= 10,
	PriorityState_delayTiming	= 11,
	PriorityState_extendTiming	= 12,
	PriorityState_preemptOverride	= 13,
	PriorityState_adaptiveOverride	= 14,
	PriorityState_reserved	= 15
	/*
	 * Enumeration is extensible
	 */
} e_PriorityState;

/*** <<< TYPE-DECLS [PriorityState] >>> ***/

typedef long	 PriorityState_t;

/*** <<< FUNC-DECLS [PriorityState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PriorityState;
asn_struct_free_f PriorityState_free;
asn_struct_print_f PriorityState_print;
asn_constr_check_f PriorityState_constraint;
ber_type_decoder_f PriorityState_decode_ber;
der_type_encoder_f PriorityState_encode_der;
xer_type_decoder_f PriorityState_decode_xer;
xer_type_encoder_f PriorityState_encode_xer;

/*** <<< CODE [PriorityState] >>> ***/

int
PriorityState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
PriorityState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
PriorityState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	PriorityState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
PriorityState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	PriorityState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
PriorityState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	PriorityState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
PriorityState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PriorityState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
PriorityState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	PriorityState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
PriorityState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	PriorityState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [PriorityState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_PriorityState_value2enum_1[] = {
	{ 0,	10,	"noneActive" },
	{ 1,	4,	"none" },
	{ 2,	9,	"requested" },
	{ 3,	6,	"active" },
	{ 4,	16,	"activeButIhibitd" },
	{ 5,	7,	"seccess" },
	{ 6,	7,	"removed" },
	{ 7,	9,	"clearFail" },
	{ 8,	10,	"detectFail" },
	{ 9,	11,	"detectClear" },
	{ 10,	5,	"abort" },
	{ 11,	11,	"delayTiming" },
	{ 12,	12,	"extendTiming" },
	{ 13,	15,	"preemptOverride" },
	{ 14,	16,	"adaptiveOverride" },
	{ 15,	8,	"reserved" }
	/* This list is extensible */
};
static unsigned int asn_MAP_PriorityState_enum2value_1[] = {
	10,	/* abort(10) */
	3,	/* active(3) */
	4,	/* activeButIhibitd(4) */
	14,	/* adaptiveOverride(14) */
	7,	/* clearFail(7) */
	11,	/* delayTiming(11) */
	9,	/* detectClear(9) */
	8,	/* detectFail(8) */
	12,	/* extendTiming(12) */
	1,	/* none(1) */
	0,	/* noneActive(0) */
	13,	/* preemptOverride(13) */
	6,	/* removed(6) */
	2,	/* requested(2) */
	15,	/* reserved(15) */
	5	/* seccess(5) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_PriorityState_specs_1 = {
	asn_MAP_PriorityState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_PriorityState_enum2value_1,	/* N => "tag"; sorted by N */
	16,	/* Number of elements in the maps */
	17,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_PriorityState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PriorityState = {
	"PriorityState",
	"PriorityState",
	PriorityState_free,
	PriorityState_print,
	PriorityState_constraint,
	PriorityState_decode_ber,
	PriorityState_encode_der,
	PriorityState_decode_xer,
	PriorityState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_PriorityState_tags_1,
	sizeof(asn_DEF_PriorityState_tags_1)
		/sizeof(asn_DEF_PriorityState_tags_1[0]), /* 1 */
	asn_DEF_PriorityState_tags_1,	/* Same as above */
	sizeof(asn_DEF_PriorityState_tags_1)
		/sizeof(asn_DEF_PriorityState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_PriorityState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ProbeSegmentNumber] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ProbeSegmentNumber] >>> ***/

typedef long	 ProbeSegmentNumber_t;

/*** <<< FUNC-DECLS [ProbeSegmentNumber] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ProbeSegmentNumber;
asn_struct_free_f ProbeSegmentNumber_free;
asn_struct_print_f ProbeSegmentNumber_print;
asn_constr_check_f ProbeSegmentNumber_constraint;
ber_type_decoder_f ProbeSegmentNumber_decode_ber;
der_type_encoder_f ProbeSegmentNumber_encode_der;
xer_type_decoder_f ProbeSegmentNumber_decode_xer;
xer_type_encoder_f ProbeSegmentNumber_encode_xer;

/*** <<< CODE [ProbeSegmentNumber] >>> ***/

int
ProbeSegmentNumber_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ProbeSegmentNumber_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ProbeSegmentNumber_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ProbeSegmentNumber_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ProbeSegmentNumber_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ProbeSegmentNumber_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ProbeSegmentNumber_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ProbeSegmentNumber_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ProbeSegmentNumber_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ProbeSegmentNumber_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ProbeSegmentNumber_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ProbeSegmentNumber_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ProbeSegmentNumber_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ProbeSegmentNumber_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ProbeSegmentNumber] >>> ***/

static ber_tlv_tag_t asn_DEF_ProbeSegmentNumber_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ProbeSegmentNumber = {
	"ProbeSegmentNumber",
	"ProbeSegmentNumber",
	ProbeSegmentNumber_free,
	ProbeSegmentNumber_print,
	ProbeSegmentNumber_constraint,
	ProbeSegmentNumber_decode_ber,
	ProbeSegmentNumber_encode_der,
	ProbeSegmentNumber_decode_xer,
	ProbeSegmentNumber_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ProbeSegmentNumber_tags_1,
	sizeof(asn_DEF_ProbeSegmentNumber_tags_1)
		/sizeof(asn_DEF_ProbeSegmentNumber_tags_1[0]), /* 1 */
	asn_DEF_ProbeSegmentNumber_tags_1,	/* Same as above */
	sizeof(asn_DEF_ProbeSegmentNumber_tags_1)
		/sizeof(asn_DEF_ProbeSegmentNumber_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [RainSensor] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [RainSensor] >>> ***/

typedef enum RainSensor {
	RainSensor_none	= 0,
	RainSensor_lightMist	= 1,
	RainSensor_heavyMist	= 2,
	RainSensor_lightRainOrDrizzle	= 3,
	RainSensor_rain	= 4,
	RainSensor_moderateRain	= 5,
	RainSensor_heavyRain	= 6,
	RainSensor_heavyDownpour	= 7
} e_RainSensor;

/*** <<< TYPE-DECLS [RainSensor] >>> ***/

typedef long	 RainSensor_t;

/*** <<< FUNC-DECLS [RainSensor] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RainSensor;
asn_struct_free_f RainSensor_free;
asn_struct_print_f RainSensor_print;
asn_constr_check_f RainSensor_constraint;
ber_type_decoder_f RainSensor_decode_ber;
der_type_encoder_f RainSensor_encode_der;
xer_type_decoder_f RainSensor_decode_xer;
xer_type_encoder_f RainSensor_encode_xer;

/*** <<< CODE [RainSensor] >>> ***/

int
RainSensor_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
RainSensor_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
RainSensor_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	RainSensor_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
RainSensor_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	RainSensor_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
RainSensor_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	RainSensor_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
RainSensor_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RainSensor_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
RainSensor_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	RainSensor_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
RainSensor_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RainSensor_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [RainSensor] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_RainSensor_value2enum_1[] = {
	{ 0,	4,	"none" },
	{ 1,	9,	"lightMist" },
	{ 2,	9,	"heavyMist" },
	{ 3,	18,	"lightRainOrDrizzle" },
	{ 4,	4,	"rain" },
	{ 5,	12,	"moderateRain" },
	{ 6,	9,	"heavyRain" },
	{ 7,	13,	"heavyDownpour" }
};
static unsigned int asn_MAP_RainSensor_enum2value_1[] = {
	7,	/* heavyDownpour(7) */
	2,	/* heavyMist(2) */
	6,	/* heavyRain(6) */
	1,	/* lightMist(1) */
	3,	/* lightRainOrDrizzle(3) */
	5,	/* moderateRain(5) */
	0,	/* none(0) */
	4	/* rain(4) */
};
static asn_INTEGER_specifics_t asn_SPC_RainSensor_specs_1 = {
	asn_MAP_RainSensor_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_RainSensor_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_RainSensor_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_RainSensor = {
	"RainSensor",
	"RainSensor",
	RainSensor_free,
	RainSensor_print,
	RainSensor_constraint,
	RainSensor_decode_ber,
	RainSensor_encode_der,
	RainSensor_decode_xer,
	RainSensor_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RainSensor_tags_1,
	sizeof(asn_DEF_RainSensor_tags_1)
		/sizeof(asn_DEF_RainSensor_tags_1[0]), /* 1 */
	asn_DEF_RainSensor_tags_1,	/* Same as above */
	sizeof(asn_DEF_RainSensor_tags_1)
		/sizeof(asn_DEF_RainSensor_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_RainSensor_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RequestedItem] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [RequestedItem] >>> ***/

typedef enum RequestedItem {
	RequestedItem_reserved	= 0,
	RequestedItem_itemA	= 1,
	RequestedItem_itemB	= 2,
	RequestedItem_itemC	= 3,
	RequestedItem_itemD	= 4,
	RequestedItem_itemE	= 5,
	RequestedItem_itemF	= 6,
	RequestedItem_itemG	= 7,
	RequestedItem_itemH	= 8,
	RequestedItem_itemI	= 9,
	RequestedItem_itemJ	= 10,
	RequestedItem_itemK	= 11,
	RequestedItem_itemL	= 12,
	RequestedItem_itemM	= 13,
	RequestedItem_itemN	= 14,
	RequestedItem_itemO	= 15,
	RequestedItem_itemP	= 16,
	RequestedItem_itemQ	= 17
	/*
	 * Enumeration is extensible
	 */
} e_RequestedItem;

/*** <<< TYPE-DECLS [RequestedItem] >>> ***/

typedef long	 RequestedItem_t;

/*** <<< FUNC-DECLS [RequestedItem] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RequestedItem;
asn_struct_free_f RequestedItem_free;
asn_struct_print_f RequestedItem_print;
asn_constr_check_f RequestedItem_constraint;
ber_type_decoder_f RequestedItem_decode_ber;
der_type_encoder_f RequestedItem_encode_der;
xer_type_decoder_f RequestedItem_decode_xer;
xer_type_encoder_f RequestedItem_encode_xer;

/*** <<< CODE [RequestedItem] >>> ***/

int
RequestedItem_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
RequestedItem_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
RequestedItem_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	RequestedItem_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
RequestedItem_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	RequestedItem_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
RequestedItem_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	RequestedItem_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
RequestedItem_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RequestedItem_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
RequestedItem_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	RequestedItem_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
RequestedItem_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RequestedItem_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [RequestedItem] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_RequestedItem_value2enum_1[] = {
	{ 0,	8,	"reserved" },
	{ 1,	5,	"itemA" },
	{ 2,	5,	"itemB" },
	{ 3,	5,	"itemC" },
	{ 4,	5,	"itemD" },
	{ 5,	5,	"itemE" },
	{ 6,	5,	"itemF" },
	{ 7,	5,	"itemG" },
	{ 8,	5,	"itemH" },
	{ 9,	5,	"itemI" },
	{ 10,	5,	"itemJ" },
	{ 11,	5,	"itemK" },
	{ 12,	5,	"itemL" },
	{ 13,	5,	"itemM" },
	{ 14,	5,	"itemN" },
	{ 15,	5,	"itemO" },
	{ 16,	5,	"itemP" },
	{ 17,	5,	"itemQ" }
	/* This list is extensible */
};
static unsigned int asn_MAP_RequestedItem_enum2value_1[] = {
	1,	/* itemA(1) */
	2,	/* itemB(2) */
	3,	/* itemC(3) */
	4,	/* itemD(4) */
	5,	/* itemE(5) */
	6,	/* itemF(6) */
	7,	/* itemG(7) */
	8,	/* itemH(8) */
	9,	/* itemI(9) */
	10,	/* itemJ(10) */
	11,	/* itemK(11) */
	12,	/* itemL(12) */
	13,	/* itemM(13) */
	14,	/* itemN(14) */
	15,	/* itemO(15) */
	16,	/* itemP(16) */
	17,	/* itemQ(17) */
	0	/* reserved(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_RequestedItem_specs_1 = {
	asn_MAP_RequestedItem_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_RequestedItem_enum2value_1,	/* N => "tag"; sorted by N */
	18,	/* Number of elements in the maps */
	19,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_RequestedItem_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_RequestedItem = {
	"RequestedItem",
	"RequestedItem",
	RequestedItem_free,
	RequestedItem_print,
	RequestedItem_constraint,
	RequestedItem_decode_ber,
	RequestedItem_encode_der,
	RequestedItem_decode_xer,
	RequestedItem_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RequestedItem_tags_1,
	sizeof(asn_DEF_RequestedItem_tags_1)
		/sizeof(asn_DEF_RequestedItem_tags_1[0]), /* 1 */
	asn_DEF_RequestedItem_tags_1,	/* Same as above */
	sizeof(asn_DEF_RequestedItem_tags_1)
		/sizeof(asn_DEF_RequestedItem_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_RequestedItem_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ResponseType] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [ResponseType] >>> ***/

typedef enum ResponseType {
	ResponseType_notInUseOrNotEquipped	= 0,
	ResponseType_emergency	= 1,
	ResponseType_nonEmergency	= 2,
	ResponseType_pursuit	= 3
} e_ResponseType;

/*** <<< TYPE-DECLS [ResponseType] >>> ***/

typedef long	 ResponseType_t;

/*** <<< FUNC-DECLS [ResponseType] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ResponseType;
asn_struct_free_f ResponseType_free;
asn_struct_print_f ResponseType_print;
asn_constr_check_f ResponseType_constraint;
ber_type_decoder_f ResponseType_decode_ber;
der_type_encoder_f ResponseType_encode_der;
xer_type_decoder_f ResponseType_decode_xer;
xer_type_encoder_f ResponseType_encode_xer;

/*** <<< CODE [ResponseType] >>> ***/

int
ResponseType_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
ResponseType_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
ResponseType_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ResponseType_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ResponseType_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ResponseType_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ResponseType_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ResponseType_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ResponseType_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ResponseType_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ResponseType_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ResponseType_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ResponseType_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ResponseType_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ResponseType] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_ResponseType_value2enum_1[] = {
	{ 0,	21,	"notInUseOrNotEquipped" },
	{ 1,	9,	"emergency" },
	{ 2,	12,	"nonEmergency" },
	{ 3,	7,	"pursuit" }
};
static unsigned int asn_MAP_ResponseType_enum2value_1[] = {
	1,	/* emergency(1) */
	2,	/* nonEmergency(2) */
	0,	/* notInUseOrNotEquipped(0) */
	3	/* pursuit(3) */
};
static asn_INTEGER_specifics_t asn_SPC_ResponseType_specs_1 = {
	asn_MAP_ResponseType_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_ResponseType_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_ResponseType_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ResponseType = {
	"ResponseType",
	"ResponseType",
	ResponseType_free,
	ResponseType_print,
	ResponseType_constraint,
	ResponseType_decode_ber,
	ResponseType_encode_der,
	ResponseType_decode_xer,
	ResponseType_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ResponseType_tags_1,
	sizeof(asn_DEF_ResponseType_tags_1)
		/sizeof(asn_DEF_ResponseType_tags_1[0]), /* 1 */
	asn_DEF_ResponseType_tags_1,	/* Same as above */
	sizeof(asn_DEF_ResponseType_tags_1)
		/sizeof(asn_DEF_ResponseType_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ResponseType_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [RTCM-ID] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [RTCM-ID] >>> ***/

typedef long	 RTCM_ID_t;

/*** <<< FUNC-DECLS [RTCM-ID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCM_ID;
asn_struct_free_f RTCM_ID_free;
asn_struct_print_f RTCM_ID_print;
asn_constr_check_f RTCM_ID_constraint;
ber_type_decoder_f RTCM_ID_decode_ber;
der_type_encoder_f RTCM_ID_encode_der;
xer_type_decoder_f RTCM_ID_decode_xer;
xer_type_encoder_f RTCM_ID_encode_xer;

/*** <<< CODE [RTCM-ID] >>> ***/

int
RTCM_ID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
RTCM_ID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
RTCM_ID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	RTCM_ID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
RTCM_ID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_ID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
RTCM_ID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	RTCM_ID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
RTCM_ID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_ID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
RTCM_ID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	RTCM_ID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
RTCM_ID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_ID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [RTCM-ID] >>> ***/

static ber_tlv_tag_t asn_DEF_RTCM_ID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_RTCM_ID = {
	"RTCM-ID",
	"RTCM-ID",
	RTCM_ID_free,
	RTCM_ID_print,
	RTCM_ID_constraint,
	RTCM_ID_decode_ber,
	RTCM_ID_encode_der,
	RTCM_ID_decode_xer,
	RTCM_ID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCM_ID_tags_1,
	sizeof(asn_DEF_RTCM_ID_tags_1)
		/sizeof(asn_DEF_RTCM_ID_tags_1[0]), /* 1 */
	asn_DEF_RTCM_ID_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCM_ID_tags_1)
		/sizeof(asn_DEF_RTCM_ID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [RTCM-Payload] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [RTCM-Payload] >>> ***/

typedef OCTET_STRING_t	 RTCM_Payload_t;

/*** <<< FUNC-DECLS [RTCM-Payload] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCM_Payload;
asn_struct_free_f RTCM_Payload_free;
asn_struct_print_f RTCM_Payload_print;
asn_constr_check_f RTCM_Payload_constraint;
ber_type_decoder_f RTCM_Payload_decode_ber;
der_type_encoder_f RTCM_Payload_encode_der;
xer_type_decoder_f RTCM_Payload_decode_xer;
xer_type_encoder_f RTCM_Payload_encode_xer;

/*** <<< CODE [RTCM-Payload] >>> ***/

int
RTCM_Payload_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 1023)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
RTCM_Payload_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
RTCM_Payload_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	RTCM_Payload_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
RTCM_Payload_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_Payload_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
RTCM_Payload_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	RTCM_Payload_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
RTCM_Payload_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_Payload_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
RTCM_Payload_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	RTCM_Payload_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
RTCM_Payload_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_Payload_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [RTCM-Payload] >>> ***/

static ber_tlv_tag_t asn_DEF_RTCM_Payload_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_RTCM_Payload = {
	"RTCM-Payload",
	"RTCM-Payload",
	RTCM_Payload_free,
	RTCM_Payload_print,
	RTCM_Payload_constraint,
	RTCM_Payload_decode_ber,
	RTCM_Payload_encode_der,
	RTCM_Payload_decode_xer,
	RTCM_Payload_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCM_Payload_tags_1,
	sizeof(asn_DEF_RTCM_Payload_tags_1)
		/sizeof(asn_DEF_RTCM_Payload_tags_1[0]), /* 1 */
	asn_DEF_RTCM_Payload_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCM_Payload_tags_1)
		/sizeof(asn_DEF_RTCM_Payload_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [RTCM-Revision] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [RTCM-Revision] >>> ***/

typedef enum RTCM_Revision {
	RTCM_Revision_unknown	= 0,
	RTCM_Revision_reserved	= 1,
	RTCM_Revision_rtcmCMR	= 2,
	RTCM_Revision_rtcmCMR_Plus	= 3,
	RTCM_Revision_rtcmSAPOS	= 4,
	RTCM_Revision_rtcmSAPOS_Adv	= 5,
	RTCM_Revision_rtcmRTCA	= 6,
	RTCM_Revision_rtcmRAW	= 7,
	RTCM_Revision_rtcmRINEX	= 8,
	RTCM_Revision_rtcmSP3	= 9,
	RTCM_Revision_rtcmBINEX	= 10,
	RTCM_Revision_rtcmRev2_x	= 19,
	RTCM_Revision_rtcmRev2_0	= 20,
	RTCM_Revision_rtcmRev2_1	= 21,
	RTCM_Revision_rtcmRev2_3	= 23,
	RTCM_Revision_rtcmRev3_0	= 30,
	RTCM_Revision_rtcmRev3_1	= 31
	/*
	 * Enumeration is extensible
	 */
} e_RTCM_Revision;

/*** <<< TYPE-DECLS [RTCM-Revision] >>> ***/

typedef long	 RTCM_Revision_t;

/*** <<< FUNC-DECLS [RTCM-Revision] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_RTCM_Revision;
asn_struct_free_f RTCM_Revision_free;
asn_struct_print_f RTCM_Revision_print;
asn_constr_check_f RTCM_Revision_constraint;
ber_type_decoder_f RTCM_Revision_decode_ber;
der_type_encoder_f RTCM_Revision_encode_der;
xer_type_decoder_f RTCM_Revision_decode_xer;
xer_type_encoder_f RTCM_Revision_encode_xer;

/*** <<< CODE [RTCM-Revision] >>> ***/

int
RTCM_Revision_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
RTCM_Revision_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
RTCM_Revision_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	RTCM_Revision_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
RTCM_Revision_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_Revision_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
RTCM_Revision_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	RTCM_Revision_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
RTCM_Revision_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_Revision_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
RTCM_Revision_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	RTCM_Revision_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
RTCM_Revision_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	RTCM_Revision_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [RTCM-Revision] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_RTCM_Revision_value2enum_1[] = {
	{ 0,	7,	"unknown" },
	{ 1,	8,	"reserved" },
	{ 2,	7,	"rtcmCMR" },
	{ 3,	12,	"rtcmCMR-Plus" },
	{ 4,	9,	"rtcmSAPOS" },
	{ 5,	13,	"rtcmSAPOS-Adv" },
	{ 6,	8,	"rtcmRTCA" },
	{ 7,	7,	"rtcmRAW" },
	{ 8,	9,	"rtcmRINEX" },
	{ 9,	7,	"rtcmSP3" },
	{ 10,	9,	"rtcmBINEX" },
	{ 19,	10,	"rtcmRev2-x" },
	{ 20,	10,	"rtcmRev2-0" },
	{ 21,	10,	"rtcmRev2-1" },
	{ 23,	10,	"rtcmRev2-3" },
	{ 30,	10,	"rtcmRev3-0" },
	{ 31,	10,	"rtcmRev3-1" }
	/* This list is extensible */
};
static unsigned int asn_MAP_RTCM_Revision_enum2value_1[] = {
	1,	/* reserved(1) */
	10,	/* rtcmBINEX(10) */
	2,	/* rtcmCMR(2) */
	3,	/* rtcmCMR-Plus(3) */
	7,	/* rtcmRAW(7) */
	8,	/* rtcmRINEX(8) */
	6,	/* rtcmRTCA(6) */
	12,	/* rtcmRev2-0(20) */
	13,	/* rtcmRev2-1(21) */
	14,	/* rtcmRev2-3(23) */
	11,	/* rtcmRev2-x(19) */
	15,	/* rtcmRev3-0(30) */
	16,	/* rtcmRev3-1(31) */
	4,	/* rtcmSAPOS(4) */
	5,	/* rtcmSAPOS-Adv(5) */
	9,	/* rtcmSP3(9) */
	0	/* unknown(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_RTCM_Revision_specs_1 = {
	asn_MAP_RTCM_Revision_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_RTCM_Revision_enum2value_1,	/* N => "tag"; sorted by N */
	17,	/* Number of elements in the maps */
	18,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_RTCM_Revision_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_RTCM_Revision = {
	"RTCM-Revision",
	"RTCM-Revision",
	RTCM_Revision_free,
	RTCM_Revision_print,
	RTCM_Revision_constraint,
	RTCM_Revision_decode_ber,
	RTCM_Revision_encode_der,
	RTCM_Revision_decode_xer,
	RTCM_Revision_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RTCM_Revision_tags_1,
	sizeof(asn_DEF_RTCM_Revision_tags_1)
		/sizeof(asn_DEF_RTCM_Revision_tags_1[0]), /* 1 */
	asn_DEF_RTCM_Revision_tags_1,	/* Same as above */
	sizeof(asn_DEF_RTCM_Revision_tags_1)
		/sizeof(asn_DEF_RTCM_Revision_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_RTCM_Revision_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SignalLightState] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [SignalLightState] >>> ***/

typedef long	 SignalLightState_t;

/*** <<< FUNC-DECLS [SignalLightState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalLightState;
asn_struct_free_f SignalLightState_free;
asn_struct_print_f SignalLightState_print;
asn_constr_check_f SignalLightState_constraint;
ber_type_decoder_f SignalLightState_decode_ber;
der_type_encoder_f SignalLightState_encode_der;
xer_type_decoder_f SignalLightState_decode_xer;
xer_type_encoder_f SignalLightState_encode_xer;

/*** <<< CODE [SignalLightState] >>> ***/

int
SignalLightState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 536870912)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
SignalLightState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
SignalLightState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SignalLightState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SignalLightState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SignalLightState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SignalLightState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SignalLightState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SignalLightState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignalLightState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SignalLightState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SignalLightState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SignalLightState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignalLightState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SignalLightState] >>> ***/

static ber_tlv_tag_t asn_DEF_SignalLightState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SignalLightState = {
	"SignalLightState",
	"SignalLightState",
	SignalLightState_free,
	SignalLightState_print,
	SignalLightState_constraint,
	SignalLightState_decode_ber,
	SignalLightState_encode_der,
	SignalLightState_decode_xer,
	SignalLightState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalLightState_tags_1,
	sizeof(asn_DEF_SignalLightState_tags_1)
		/sizeof(asn_DEF_SignalLightState_tags_1[0]), /* 1 */
	asn_DEF_SignalLightState_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalLightState_tags_1)
		/sizeof(asn_DEF_SignalLightState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SignalReqScheme] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [SignalReqScheme] >>> ***/

typedef OCTET_STRING_t	 SignalReqScheme_t;

/*** <<< FUNC-DECLS [SignalReqScheme] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalReqScheme;
asn_struct_free_f SignalReqScheme_free;
asn_struct_print_f SignalReqScheme_print;
asn_constr_check_f SignalReqScheme_constraint;
ber_type_decoder_f SignalReqScheme_decode_ber;
der_type_encoder_f SignalReqScheme_encode_der;
xer_type_decoder_f SignalReqScheme_decode_xer;
xer_type_encoder_f SignalReqScheme_encode_xer;

/*** <<< CODE [SignalReqScheme] >>> ***/

int
SignalReqScheme_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
SignalReqScheme_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
SignalReqScheme_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SignalReqScheme_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SignalReqScheme_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SignalReqScheme_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SignalReqScheme_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SignalReqScheme_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SignalReqScheme_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignalReqScheme_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SignalReqScheme_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SignalReqScheme_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SignalReqScheme_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignalReqScheme_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SignalReqScheme] >>> ***/

static ber_tlv_tag_t asn_DEF_SignalReqScheme_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SignalReqScheme = {
	"SignalReqScheme",
	"SignalReqScheme",
	SignalReqScheme_free,
	SignalReqScheme_print,
	SignalReqScheme_constraint,
	SignalReqScheme_decode_ber,
	SignalReqScheme_encode_der,
	SignalReqScheme_decode_xer,
	SignalReqScheme_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalReqScheme_tags_1,
	sizeof(asn_DEF_SignalReqScheme_tags_1)
		/sizeof(asn_DEF_SignalReqScheme_tags_1[0]), /* 1 */
	asn_DEF_SignalReqScheme_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalReqScheme_tags_1)
		/sizeof(asn_DEF_SignalReqScheme_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SignalState] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [SignalState] >>> ***/

typedef OCTET_STRING_t	 SignalState_t;

/*** <<< FUNC-DECLS [SignalState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignalState;
asn_struct_free_f SignalState_free;
asn_struct_print_f SignalState_print;
asn_constr_check_f SignalState_constraint;
ber_type_decoder_f SignalState_decode_ber;
der_type_encoder_f SignalState_encode_der;
xer_type_decoder_f SignalState_decode_xer;
xer_type_encoder_f SignalState_encode_xer;

/*** <<< CODE [SignalState] >>> ***/

int
SignalState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
SignalState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
SignalState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SignalState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SignalState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SignalState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SignalState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SignalState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SignalState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignalState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SignalState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SignalState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SignalState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignalState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SignalState] >>> ***/

static ber_tlv_tag_t asn_DEF_SignalState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SignalState = {
	"SignalState",
	"SignalState",
	SignalState_free,
	SignalState_print,
	SignalState_constraint,
	SignalState_decode_ber,
	SignalState_encode_der,
	SignalState_decode_xer,
	SignalState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignalState_tags_1,
	sizeof(asn_DEF_SignalState_tags_1)
		/sizeof(asn_DEF_SignalState_tags_1[0]), /* 1 */
	asn_DEF_SignalState_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignalState_tags_1)
		/sizeof(asn_DEF_SignalState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SignPrority] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [SignPrority] >>> ***/

typedef long	 SignPrority_t;

/*** <<< FUNC-DECLS [SignPrority] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SignPrority;
asn_struct_free_f SignPrority_free;
asn_struct_print_f SignPrority_print;
asn_constr_check_f SignPrority_constraint;
ber_type_decoder_f SignPrority_decode_ber;
der_type_encoder_f SignPrority_encode_der;
xer_type_decoder_f SignPrority_decode_xer;
xer_type_encoder_f SignPrority_encode_xer;

/*** <<< CODE [SignPrority] >>> ***/

int
SignPrority_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 7)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
SignPrority_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
SignPrority_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SignPrority_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SignPrority_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SignPrority_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SignPrority_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SignPrority_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SignPrority_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignPrority_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SignPrority_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SignPrority_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SignPrority_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SignPrority_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SignPrority] >>> ***/

static ber_tlv_tag_t asn_DEF_SignPrority_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SignPrority = {
	"SignPrority",
	"SignPrority",
	SignPrority_free,
	SignPrority_print,
	SignPrority_constraint,
	SignPrority_decode_ber,
	SignPrority_encode_der,
	SignPrority_decode_xer,
	SignPrority_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SignPrority_tags_1,
	sizeof(asn_DEF_SignPrority_tags_1)
		/sizeof(asn_DEF_SignPrority_tags_1[0]), /* 1 */
	asn_DEF_SignPrority_tags_1,	/* Same as above */
	sizeof(asn_DEF_SignPrority_tags_1)
		/sizeof(asn_DEF_SignPrority_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SirenInUse] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [SirenInUse] >>> ***/

typedef enum SirenInUse {
	SirenInUse_unavailable	= 0,
	SirenInUse_notInUse	= 1,
	SirenInUse_inUse	= 2,
	SirenInUse_reserved	= 3
} e_SirenInUse;

/*** <<< TYPE-DECLS [SirenInUse] >>> ***/

typedef long	 SirenInUse_t;

/*** <<< FUNC-DECLS [SirenInUse] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SirenInUse;
asn_struct_free_f SirenInUse_free;
asn_struct_print_f SirenInUse_print;
asn_constr_check_f SirenInUse_constraint;
ber_type_decoder_f SirenInUse_decode_ber;
der_type_encoder_f SirenInUse_encode_der;
xer_type_decoder_f SirenInUse_decode_xer;
xer_type_encoder_f SirenInUse_encode_xer;

/*** <<< CODE [SirenInUse] >>> ***/

int
SirenInUse_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
SirenInUse_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
SirenInUse_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SirenInUse_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SirenInUse_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SirenInUse_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SirenInUse_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SirenInUse_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SirenInUse_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SirenInUse_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SirenInUse_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SirenInUse_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SirenInUse_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SirenInUse_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SirenInUse] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_SirenInUse_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	8,	"notInUse" },
	{ 2,	5,	"inUse" },
	{ 3,	8,	"reserved" }
};
static unsigned int asn_MAP_SirenInUse_enum2value_1[] = {
	2,	/* inUse(2) */
	1,	/* notInUse(1) */
	3,	/* reserved(3) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_SirenInUse_specs_1 = {
	asn_MAP_SirenInUse_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_SirenInUse_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_SirenInUse_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SirenInUse = {
	"SirenInUse",
	"SirenInUse",
	SirenInUse_free,
	SirenInUse_print,
	SirenInUse_constraint,
	SirenInUse_decode_ber,
	SirenInUse_encode_der,
	SirenInUse_decode_xer,
	SirenInUse_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SirenInUse_tags_1,
	sizeof(asn_DEF_SirenInUse_tags_1)
		/sizeof(asn_DEF_SirenInUse_tags_1[0]), /* 1 */
	asn_DEF_SirenInUse_tags_1,	/* Same as above */
	sizeof(asn_DEF_SirenInUse_tags_1)
		/sizeof(asn_DEF_SirenInUse_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_SirenInUse_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SpecialLaneAttributes] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [SpecialLaneAttributes] >>> ***/

typedef enum SpecialLaneAttributes {
	SpecialLaneAttributes_noData	= 0,
	SpecialLaneAttributes_egressPath	= 1,
	SpecialLaneAttributes_railRoadTrack	= 2,
	SpecialLaneAttributes_transitOnlyLane	= 4,
	SpecialLaneAttributes_hovLane	= 8,
	SpecialLaneAttributes_busOnly	= 16,
	SpecialLaneAttributes_vehiclesEntering	= 32,
	SpecialLaneAttributes_vehiclesLeaving	= 64,
	SpecialLaneAttributes_reserved	= 128
} e_SpecialLaneAttributes;

/*** <<< TYPE-DECLS [SpecialLaneAttributes] >>> ***/

typedef long	 SpecialLaneAttributes_t;

/*** <<< FUNC-DECLS [SpecialLaneAttributes] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SpecialLaneAttributes;
asn_struct_free_f SpecialLaneAttributes_free;
asn_struct_print_f SpecialLaneAttributes_print;
asn_constr_check_f SpecialLaneAttributes_constraint;
ber_type_decoder_f SpecialLaneAttributes_decode_ber;
der_type_encoder_f SpecialLaneAttributes_encode_der;
xer_type_decoder_f SpecialLaneAttributes_decode_xer;
xer_type_encoder_f SpecialLaneAttributes_encode_xer;

/*** <<< CODE [SpecialLaneAttributes] >>> ***/

int
SpecialLaneAttributes_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
SpecialLaneAttributes_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
SpecialLaneAttributes_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SpecialLaneAttributes_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SpecialLaneAttributes_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SpecialLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SpecialLaneAttributes_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SpecialLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SpecialLaneAttributes_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpecialLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SpecialLaneAttributes_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SpecialLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SpecialLaneAttributes_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpecialLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SpecialLaneAttributes] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_SpecialLaneAttributes_value2enum_1[] = {
	{ 0,	6,	"noData" },
	{ 1,	10,	"egressPath" },
	{ 2,	13,	"railRoadTrack" },
	{ 4,	15,	"transitOnlyLane" },
	{ 8,	7,	"hovLane" },
	{ 16,	7,	"busOnly" },
	{ 32,	16,	"vehiclesEntering" },
	{ 64,	15,	"vehiclesLeaving" },
	{ 128,	8,	"reserved" }
};
static unsigned int asn_MAP_SpecialLaneAttributes_enum2value_1[] = {
	5,	/* busOnly(16) */
	1,	/* egressPath(1) */
	4,	/* hovLane(8) */
	0,	/* noData(0) */
	2,	/* railRoadTrack(2) */
	8,	/* reserved(128) */
	3,	/* transitOnlyLane(4) */
	6,	/* vehiclesEntering(32) */
	7	/* vehiclesLeaving(64) */
};
static asn_INTEGER_specifics_t asn_SPC_SpecialLaneAttributes_specs_1 = {
	asn_MAP_SpecialLaneAttributes_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_SpecialLaneAttributes_enum2value_1,	/* N => "tag"; sorted by N */
	9,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_SpecialLaneAttributes_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SpecialLaneAttributes = {
	"SpecialLaneAttributes",
	"SpecialLaneAttributes",
	SpecialLaneAttributes_free,
	SpecialLaneAttributes_print,
	SpecialLaneAttributes_constraint,
	SpecialLaneAttributes_decode_ber,
	SpecialLaneAttributes_encode_der,
	SpecialLaneAttributes_decode_xer,
	SpecialLaneAttributes_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SpecialLaneAttributes_tags_1,
	sizeof(asn_DEF_SpecialLaneAttributes_tags_1)
		/sizeof(asn_DEF_SpecialLaneAttributes_tags_1[0]), /* 1 */
	asn_DEF_SpecialLaneAttributes_tags_1,	/* Same as above */
	sizeof(asn_DEF_SpecialLaneAttributes_tags_1)
		/sizeof(asn_DEF_SpecialLaneAttributes_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_SpecialLaneAttributes_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SpecialSignalState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [SpecialSignalState] >>> ***/

typedef enum SpecialSignalState {
	SpecialSignalState_unknown	= 0,
	SpecialSignalState_notInUse	= 1,
	SpecialSignalState_arriving	= 2,
	SpecialSignalState_present	= 3,
	SpecialSignalState_departing	= 4
	/*
	 * Enumeration is extensible
	 */
} e_SpecialSignalState;

/*** <<< TYPE-DECLS [SpecialSignalState] >>> ***/

typedef long	 SpecialSignalState_t;

/*** <<< FUNC-DECLS [SpecialSignalState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SpecialSignalState;
asn_struct_free_f SpecialSignalState_free;
asn_struct_print_f SpecialSignalState_print;
asn_constr_check_f SpecialSignalState_constraint;
ber_type_decoder_f SpecialSignalState_decode_ber;
der_type_encoder_f SpecialSignalState_encode_der;
xer_type_decoder_f SpecialSignalState_decode_xer;
xer_type_encoder_f SpecialSignalState_encode_xer;

/*** <<< CODE [SpecialSignalState] >>> ***/

int
SpecialSignalState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
SpecialSignalState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
SpecialSignalState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SpecialSignalState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SpecialSignalState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SpecialSignalState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SpecialSignalState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SpecialSignalState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SpecialSignalState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpecialSignalState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SpecialSignalState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SpecialSignalState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SpecialSignalState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpecialSignalState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SpecialSignalState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_SpecialSignalState_value2enum_1[] = {
	{ 0,	7,	"unknown" },
	{ 1,	8,	"notInUse" },
	{ 2,	8,	"arriving" },
	{ 3,	7,	"present" },
	{ 4,	9,	"departing" }
	/* This list is extensible */
};
static unsigned int asn_MAP_SpecialSignalState_enum2value_1[] = {
	2,	/* arriving(2) */
	4,	/* departing(4) */
	1,	/* notInUse(1) */
	3,	/* present(3) */
	0	/* unknown(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_SpecialSignalState_specs_1 = {
	asn_MAP_SpecialSignalState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_SpecialSignalState_enum2value_1,	/* N => "tag"; sorted by N */
	5,	/* Number of elements in the maps */
	6,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_SpecialSignalState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SpecialSignalState = {
	"SpecialSignalState",
	"SpecialSignalState",
	SpecialSignalState_free,
	SpecialSignalState_print,
	SpecialSignalState_constraint,
	SpecialSignalState_decode_ber,
	SpecialSignalState_encode_der,
	SpecialSignalState_decode_xer,
	SpecialSignalState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SpecialSignalState_tags_1,
	sizeof(asn_DEF_SpecialSignalState_tags_1)
		/sizeof(asn_DEF_SpecialSignalState_tags_1[0]), /* 1 */
	asn_DEF_SpecialSignalState_tags_1,	/* Same as above */
	sizeof(asn_DEF_SpecialSignalState_tags_1)
		/sizeof(asn_DEF_SpecialSignalState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_SpecialSignalState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Speed] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Speed] >>> ***/

typedef long	 Speed_t;

/*** <<< FUNC-DECLS [Speed] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Speed;
asn_struct_free_f Speed_free;
asn_struct_print_f Speed_print;
asn_constr_check_f Speed_constraint;
ber_type_decoder_f Speed_decode_ber;
der_type_encoder_f Speed_encode_der;
xer_type_decoder_f Speed_decode_xer;
xer_type_encoder_f Speed_encode_xer;

/*** <<< CODE [Speed] >>> ***/

int
Speed_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 8191)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
Speed_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
Speed_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	Speed_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
Speed_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	Speed_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
Speed_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	Speed_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
Speed_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Speed_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
Speed_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	Speed_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
Speed_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	Speed_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [Speed] >>> ***/

static ber_tlv_tag_t asn_DEF_Speed_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Speed = {
	"Speed",
	"Speed",
	Speed_free,
	Speed_print,
	Speed_constraint,
	Speed_decode_ber,
	Speed_encode_der,
	Speed_decode_xer,
	Speed_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Speed_tags_1,
	sizeof(asn_DEF_Speed_tags_1)
		/sizeof(asn_DEF_Speed_tags_1[0]), /* 1 */
	asn_DEF_Speed_tags_1,	/* Same as above */
	sizeof(asn_DEF_Speed_tags_1)
		/sizeof(asn_DEF_Speed_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SpeedConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [SpeedConfidence] >>> ***/

typedef enum SpeedConfidence {
	SpeedConfidence_unavailable	= 0,
	SpeedConfidence_prec100ms	= 1,
	SpeedConfidence_prec10ms	= 2,
	SpeedConfidence_prec5ms	= 3,
	SpeedConfidence_prec1ms	= 4,
	SpeedConfidence_prec0_1ms	= 5,
	SpeedConfidence_prec0_05ms	= 6,
	SpeedConfidence_prec0_01ms	= 7
} e_SpeedConfidence;

/*** <<< TYPE-DECLS [SpeedConfidence] >>> ***/

typedef long	 SpeedConfidence_t;

/*** <<< FUNC-DECLS [SpeedConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SpeedConfidence;
asn_struct_free_f SpeedConfidence_free;
asn_struct_print_f SpeedConfidence_print;
asn_constr_check_f SpeedConfidence_constraint;
ber_type_decoder_f SpeedConfidence_decode_ber;
der_type_encoder_f SpeedConfidence_encode_der;
xer_type_decoder_f SpeedConfidence_decode_xer;
xer_type_encoder_f SpeedConfidence_encode_xer;

/*** <<< CODE [SpeedConfidence] >>> ***/

int
SpeedConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
SpeedConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
SpeedConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SpeedConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SpeedConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SpeedConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SpeedConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SpeedConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SpeedConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpeedConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SpeedConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SpeedConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SpeedConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SpeedConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SpeedConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_SpeedConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	9,	"prec100ms" },
	{ 2,	8,	"prec10ms" },
	{ 3,	7,	"prec5ms" },
	{ 4,	7,	"prec1ms" },
	{ 5,	9,	"prec0-1ms" },
	{ 6,	10,	"prec0-05ms" },
	{ 7,	10,	"prec0-01ms" }
};
static unsigned int asn_MAP_SpeedConfidence_enum2value_1[] = {
	7,	/* prec0-01ms(7) */
	6,	/* prec0-05ms(6) */
	5,	/* prec0-1ms(5) */
	1,	/* prec100ms(1) */
	2,	/* prec10ms(2) */
	4,	/* prec1ms(4) */
	3,	/* prec5ms(3) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_SpeedConfidence_specs_1 = {
	asn_MAP_SpeedConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_SpeedConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_SpeedConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SpeedConfidence = {
	"SpeedConfidence",
	"SpeedConfidence",
	SpeedConfidence_free,
	SpeedConfidence_print,
	SpeedConfidence_constraint,
	SpeedConfidence_decode_ber,
	SpeedConfidence_encode_der,
	SpeedConfidence_decode_xer,
	SpeedConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SpeedConfidence_tags_1,
	sizeof(asn_DEF_SpeedConfidence_tags_1)
		/sizeof(asn_DEF_SpeedConfidence_tags_1[0]), /* 1 */
	asn_DEF_SpeedConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_SpeedConfidence_tags_1)
		/sizeof(asn_DEF_SpeedConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_SpeedConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [StabilityControlStatus] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [StabilityControlStatus] >>> ***/

typedef enum StabilityControlStatus {
	StabilityControlStatus_unavailable	= 0,
	StabilityControlStatus_off	= 1,
	StabilityControlStatus_on	= 2
} e_StabilityControlStatus;

/*** <<< TYPE-DECLS [StabilityControlStatus] >>> ***/

typedef long	 StabilityControlStatus_t;

/*** <<< FUNC-DECLS [StabilityControlStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_StabilityControlStatus;
asn_struct_free_f StabilityControlStatus_free;
asn_struct_print_f StabilityControlStatus_print;
asn_constr_check_f StabilityControlStatus_constraint;
ber_type_decoder_f StabilityControlStatus_decode_ber;
der_type_encoder_f StabilityControlStatus_encode_der;
xer_type_decoder_f StabilityControlStatus_decode_xer;
xer_type_encoder_f StabilityControlStatus_encode_xer;

/*** <<< CODE [StabilityControlStatus] >>> ***/

int
StabilityControlStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
StabilityControlStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
StabilityControlStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	StabilityControlStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
StabilityControlStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	StabilityControlStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
StabilityControlStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	StabilityControlStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
StabilityControlStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	StabilityControlStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
StabilityControlStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	StabilityControlStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
StabilityControlStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	StabilityControlStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [StabilityControlStatus] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_StabilityControlStatus_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	2,	"on" }
};
static unsigned int asn_MAP_StabilityControlStatus_enum2value_1[] = {
	1,	/* off(1) */
	2,	/* on(2) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_StabilityControlStatus_specs_1 = {
	asn_MAP_StabilityControlStatus_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_StabilityControlStatus_enum2value_1,	/* N => "tag"; sorted by N */
	3,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_StabilityControlStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_StabilityControlStatus = {
	"StabilityControlStatus",
	"StabilityControlStatus",
	StabilityControlStatus_free,
	StabilityControlStatus_print,
	StabilityControlStatus_constraint,
	StabilityControlStatus_decode_ber,
	StabilityControlStatus_encode_der,
	StabilityControlStatus_decode_xer,
	StabilityControlStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_StabilityControlStatus_tags_1,
	sizeof(asn_DEF_StabilityControlStatus_tags_1)
		/sizeof(asn_DEF_StabilityControlStatus_tags_1[0]), /* 1 */
	asn_DEF_StabilityControlStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_StabilityControlStatus_tags_1)
		/sizeof(asn_DEF_StabilityControlStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_StabilityControlStatus_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [StateConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [StateConfidence] >>> ***/

typedef enum StateConfidence {
	StateConfidence_unKnownEstimate	= 0,
	StateConfidence_minTime	= 1,
	StateConfidence_maxTime	= 2,
	StateConfidence_timeLikeklyToChange	= 3
	/*
	 * Enumeration is extensible
	 */
} e_StateConfidence;

/*** <<< TYPE-DECLS [StateConfidence] >>> ***/

typedef long	 StateConfidence_t;

/*** <<< FUNC-DECLS [StateConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_StateConfidence;
asn_struct_free_f StateConfidence_free;
asn_struct_print_f StateConfidence_print;
asn_constr_check_f StateConfidence_constraint;
ber_type_decoder_f StateConfidence_decode_ber;
der_type_encoder_f StateConfidence_encode_der;
xer_type_decoder_f StateConfidence_decode_xer;
xer_type_encoder_f StateConfidence_encode_xer;

/*** <<< CODE [StateConfidence] >>> ***/

int
StateConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
StateConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
StateConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	StateConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
StateConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	StateConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
StateConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	StateConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
StateConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	StateConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
StateConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	StateConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
StateConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	StateConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [StateConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_StateConfidence_value2enum_1[] = {
	{ 0,	15,	"unKnownEstimate" },
	{ 1,	7,	"minTime" },
	{ 2,	7,	"maxTime" },
	{ 3,	19,	"timeLikeklyToChange" }
	/* This list is extensible */
};
static unsigned int asn_MAP_StateConfidence_enum2value_1[] = {
	2,	/* maxTime(2) */
	1,	/* minTime(1) */
	3,	/* timeLikeklyToChange(3) */
	0	/* unKnownEstimate(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_StateConfidence_specs_1 = {
	asn_MAP_StateConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_StateConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	5,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_StateConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_StateConfidence = {
	"StateConfidence",
	"StateConfidence",
	StateConfidence_free,
	StateConfidence_print,
	StateConfidence_constraint,
	StateConfidence_decode_ber,
	StateConfidence_encode_der,
	StateConfidence_decode_xer,
	StateConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_StateConfidence_tags_1,
	sizeof(asn_DEF_StateConfidence_tags_1)
		/sizeof(asn_DEF_StateConfidence_tags_1[0]), /* 1 */
	asn_DEF_StateConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_StateConfidence_tags_1)
		/sizeof(asn_DEF_StateConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_StateConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SteeringAxleLubePressure] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [SteeringAxleLubePressure] >>> ***/

typedef long	 SteeringAxleLubePressure_t;

/*** <<< FUNC-DECLS [SteeringAxleLubePressure] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleLubePressure;
asn_struct_free_f SteeringAxleLubePressure_free;
asn_struct_print_f SteeringAxleLubePressure_print;
asn_constr_check_f SteeringAxleLubePressure_constraint;
ber_type_decoder_f SteeringAxleLubePressure_decode_ber;
der_type_encoder_f SteeringAxleLubePressure_encode_der;
xer_type_decoder_f SteeringAxleLubePressure_decode_xer;
xer_type_encoder_f SteeringAxleLubePressure_encode_xer;

/*** <<< CODE [SteeringAxleLubePressure] >>> ***/

int
SteeringAxleLubePressure_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
SteeringAxleLubePressure_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
SteeringAxleLubePressure_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SteeringAxleLubePressure_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SteeringAxleLubePressure_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SteeringAxleLubePressure_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SteeringAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SteeringAxleLubePressure_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SteeringAxleLubePressure_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SteeringAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SteeringAxleLubePressure_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringAxleLubePressure_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SteeringAxleLubePressure] >>> ***/

static ber_tlv_tag_t asn_DEF_SteeringAxleLubePressure_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SteeringAxleLubePressure = {
	"SteeringAxleLubePressure",
	"SteeringAxleLubePressure",
	SteeringAxleLubePressure_free,
	SteeringAxleLubePressure_print,
	SteeringAxleLubePressure_constraint,
	SteeringAxleLubePressure_decode_ber,
	SteeringAxleLubePressure_encode_der,
	SteeringAxleLubePressure_decode_xer,
	SteeringAxleLubePressure_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SteeringAxleLubePressure_tags_1,
	sizeof(asn_DEF_SteeringAxleLubePressure_tags_1)
		/sizeof(asn_DEF_SteeringAxleLubePressure_tags_1[0]), /* 1 */
	asn_DEF_SteeringAxleLubePressure_tags_1,	/* Same as above */
	sizeof(asn_DEF_SteeringAxleLubePressure_tags_1)
		/sizeof(asn_DEF_SteeringAxleLubePressure_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SteeringAxleTemperature] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [SteeringAxleTemperature] >>> ***/

typedef long	 SteeringAxleTemperature_t;

/*** <<< FUNC-DECLS [SteeringAxleTemperature] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleTemperature;
asn_struct_free_f SteeringAxleTemperature_free;
asn_struct_print_f SteeringAxleTemperature_print;
asn_constr_check_f SteeringAxleTemperature_constraint;
ber_type_decoder_f SteeringAxleTemperature_decode_ber;
der_type_encoder_f SteeringAxleTemperature_encode_der;
xer_type_decoder_f SteeringAxleTemperature_decode_xer;
xer_type_encoder_f SteeringAxleTemperature_encode_xer;

/*** <<< CODE [SteeringAxleTemperature] >>> ***/

int
SteeringAxleTemperature_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
SteeringAxleTemperature_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
SteeringAxleTemperature_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SteeringAxleTemperature_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SteeringAxleTemperature_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SteeringAxleTemperature_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SteeringAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SteeringAxleTemperature_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SteeringAxleTemperature_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SteeringAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SteeringAxleTemperature_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringAxleTemperature_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SteeringAxleTemperature] >>> ***/

static ber_tlv_tag_t asn_DEF_SteeringAxleTemperature_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SteeringAxleTemperature = {
	"SteeringAxleTemperature",
	"SteeringAxleTemperature",
	SteeringAxleTemperature_free,
	SteeringAxleTemperature_print,
	SteeringAxleTemperature_constraint,
	SteeringAxleTemperature_decode_ber,
	SteeringAxleTemperature_encode_der,
	SteeringAxleTemperature_decode_xer,
	SteeringAxleTemperature_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SteeringAxleTemperature_tags_1,
	sizeof(asn_DEF_SteeringAxleTemperature_tags_1)
		/sizeof(asn_DEF_SteeringAxleTemperature_tags_1[0]), /* 1 */
	asn_DEF_SteeringAxleTemperature_tags_1,	/* Same as above */
	sizeof(asn_DEF_SteeringAxleTemperature_tags_1)
		/sizeof(asn_DEF_SteeringAxleTemperature_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SteeringWheelAngle] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [SteeringWheelAngle] >>> ***/

typedef OCTET_STRING_t	 SteeringWheelAngle_t;

/*** <<< FUNC-DECLS [SteeringWheelAngle] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngle;
asn_struct_free_f SteeringWheelAngle_free;
asn_struct_print_f SteeringWheelAngle_print;
asn_constr_check_f SteeringWheelAngle_constraint;
ber_type_decoder_f SteeringWheelAngle_decode_ber;
der_type_encoder_f SteeringWheelAngle_encode_der;
xer_type_decoder_f SteeringWheelAngle_decode_xer;
xer_type_encoder_f SteeringWheelAngle_encode_xer;

/*** <<< CODE [SteeringWheelAngle] >>> ***/

int
SteeringWheelAngle_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
SteeringWheelAngle_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
SteeringWheelAngle_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SteeringWheelAngle_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SteeringWheelAngle_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SteeringWheelAngle_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SteeringWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SteeringWheelAngle_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SteeringWheelAngle_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SteeringWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SteeringWheelAngle_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngle_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SteeringWheelAngle] >>> ***/

static ber_tlv_tag_t asn_DEF_SteeringWheelAngle_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngle = {
	"SteeringWheelAngle",
	"SteeringWheelAngle",
	SteeringWheelAngle_free,
	SteeringWheelAngle_print,
	SteeringWheelAngle_constraint,
	SteeringWheelAngle_decode_ber,
	SteeringWheelAngle_encode_der,
	SteeringWheelAngle_decode_xer,
	SteeringWheelAngle_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SteeringWheelAngle_tags_1,
	sizeof(asn_DEF_SteeringWheelAngle_tags_1)
		/sizeof(asn_DEF_SteeringWheelAngle_tags_1[0]), /* 1 */
	asn_DEF_SteeringWheelAngle_tags_1,	/* Same as above */
	sizeof(asn_DEF_SteeringWheelAngle_tags_1)
		/sizeof(asn_DEF_SteeringWheelAngle_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SteeringWheelAngleConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [SteeringWheelAngleConfidence] >>> ***/

typedef enum SteeringWheelAngleConfidence {
	SteeringWheelAngleConfidence_unavailable	= 0,
	SteeringWheelAngleConfidence_prec2deg	= 1,
	SteeringWheelAngleConfidence_prec1deg	= 2,
	SteeringWheelAngleConfidence_prec0_02deg	= 3
} e_SteeringWheelAngleConfidence;

/*** <<< TYPE-DECLS [SteeringWheelAngleConfidence] >>> ***/

typedef long	 SteeringWheelAngleConfidence_t;

/*** <<< FUNC-DECLS [SteeringWheelAngleConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleConfidence;
asn_struct_free_f SteeringWheelAngleConfidence_free;
asn_struct_print_f SteeringWheelAngleConfidence_print;
asn_constr_check_f SteeringWheelAngleConfidence_constraint;
ber_type_decoder_f SteeringWheelAngleConfidence_decode_ber;
der_type_encoder_f SteeringWheelAngleConfidence_encode_der;
xer_type_decoder_f SteeringWheelAngleConfidence_decode_xer;
xer_type_encoder_f SteeringWheelAngleConfidence_encode_xer;

/*** <<< CODE [SteeringWheelAngleConfidence] >>> ***/

int
SteeringWheelAngleConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
SteeringWheelAngleConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SteeringWheelAngleConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SteeringWheelAngleConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SteeringWheelAngleConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SteeringWheelAngleConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SteeringWheelAngleConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngleConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SteeringWheelAngleConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_SteeringWheelAngleConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	8,	"prec2deg" },
	{ 2,	8,	"prec1deg" },
	{ 3,	11,	"prec0-02deg" }
};
static unsigned int asn_MAP_SteeringWheelAngleConfidence_enum2value_1[] = {
	3,	/* prec0-02deg(3) */
	2,	/* prec1deg(2) */
	1,	/* prec2deg(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_SteeringWheelAngleConfidence_specs_1 = {
	asn_MAP_SteeringWheelAngleConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_SteeringWheelAngleConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_SteeringWheelAngleConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleConfidence = {
	"SteeringWheelAngleConfidence",
	"SteeringWheelAngleConfidence",
	SteeringWheelAngleConfidence_free,
	SteeringWheelAngleConfidence_print,
	SteeringWheelAngleConfidence_constraint,
	SteeringWheelAngleConfidence_decode_ber,
	SteeringWheelAngleConfidence_encode_der,
	SteeringWheelAngleConfidence_decode_xer,
	SteeringWheelAngleConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SteeringWheelAngleConfidence_tags_1,
	sizeof(asn_DEF_SteeringWheelAngleConfidence_tags_1)
		/sizeof(asn_DEF_SteeringWheelAngleConfidence_tags_1[0]), /* 1 */
	asn_DEF_SteeringWheelAngleConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_SteeringWheelAngleConfidence_tags_1)
		/sizeof(asn_DEF_SteeringWheelAngleConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_SteeringWheelAngleConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SteeringWheelAngleRateOfChange] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [SteeringWheelAngleRateOfChange] >>> ***/

typedef long	 SteeringWheelAngleRateOfChange_t;

/*** <<< FUNC-DECLS [SteeringWheelAngleRateOfChange] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleRateOfChange;
asn_struct_free_f SteeringWheelAngleRateOfChange_free;
asn_struct_print_f SteeringWheelAngleRateOfChange_print;
asn_constr_check_f SteeringWheelAngleRateOfChange_constraint;
ber_type_decoder_f SteeringWheelAngleRateOfChange_decode_ber;
der_type_encoder_f SteeringWheelAngleRateOfChange_encode_der;
xer_type_decoder_f SteeringWheelAngleRateOfChange_decode_xer;
xer_type_encoder_f SteeringWheelAngleRateOfChange_encode_xer;

/*** <<< CODE [SteeringWheelAngleRateOfChange] >>> ***/

int
SteeringWheelAngleRateOfChange_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -127 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
SteeringWheelAngleRateOfChange_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SteeringWheelAngleRateOfChange_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SteeringWheelAngleRateOfChange_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SteeringWheelAngleRateOfChange_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SteeringWheelAngleRateOfChange_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SteeringWheelAngleRateOfChange_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SteeringWheelAngleRateOfChange_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SteeringWheelAngleRateOfChange] >>> ***/

static ber_tlv_tag_t asn_DEF_SteeringWheelAngleRateOfChange_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleRateOfChange = {
	"SteeringWheelAngleRateOfChange",
	"SteeringWheelAngleRateOfChange",
	SteeringWheelAngleRateOfChange_free,
	SteeringWheelAngleRateOfChange_print,
	SteeringWheelAngleRateOfChange_constraint,
	SteeringWheelAngleRateOfChange_decode_ber,
	SteeringWheelAngleRateOfChange_encode_der,
	SteeringWheelAngleRateOfChange_decode_xer,
	SteeringWheelAngleRateOfChange_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SteeringWheelAngleRateOfChange_tags_1,
	sizeof(asn_DEF_SteeringWheelAngleRateOfChange_tags_1)
		/sizeof(asn_DEF_SteeringWheelAngleRateOfChange_tags_1[0]), /* 1 */
	asn_DEF_SteeringWheelAngleRateOfChange_tags_1,	/* Same as above */
	sizeof(asn_DEF_SteeringWheelAngleRateOfChange_tags_1)
		/sizeof(asn_DEF_SteeringWheelAngleRateOfChange_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SunSensor] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [SunSensor] >>> ***/

typedef long	 SunSensor_t;

/*** <<< FUNC-DECLS [SunSensor] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SunSensor;
asn_struct_free_f SunSensor_free;
asn_struct_print_f SunSensor_print;
asn_constr_check_f SunSensor_constraint;
ber_type_decoder_f SunSensor_decode_ber;
der_type_encoder_f SunSensor_encode_der;
xer_type_decoder_f SunSensor_decode_xer;
xer_type_encoder_f SunSensor_encode_xer;

/*** <<< CODE [SunSensor] >>> ***/

int
SunSensor_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 1000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
SunSensor_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
SunSensor_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	SunSensor_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
SunSensor_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	SunSensor_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
SunSensor_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	SunSensor_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
SunSensor_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SunSensor_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
SunSensor_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	SunSensor_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
SunSensor_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	SunSensor_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [SunSensor] >>> ***/

static ber_tlv_tag_t asn_DEF_SunSensor_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SunSensor = {
	"SunSensor",
	"SunSensor",
	SunSensor_free,
	SunSensor_print,
	SunSensor_constraint,
	SunSensor_decode_ber,
	SunSensor_encode_der,
	SunSensor_decode_xer,
	SunSensor_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_SunSensor_tags_1,
	sizeof(asn_DEF_SunSensor_tags_1)
		/sizeof(asn_DEF_SunSensor_tags_1[0]), /* 1 */
	asn_DEF_SunSensor_tags_1,	/* Same as above */
	sizeof(asn_DEF_SunSensor_tags_1)
		/sizeof(asn_DEF_SunSensor_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TemporaryID] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [TemporaryID] >>> ***/

typedef OCTET_STRING_t	 TemporaryID_t;

/*** <<< FUNC-DECLS [TemporaryID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TemporaryID;
asn_struct_free_f TemporaryID_free;
asn_struct_print_f TemporaryID_print;
asn_constr_check_f TemporaryID_constraint;
ber_type_decoder_f TemporaryID_decode_ber;
der_type_encoder_f TemporaryID_encode_der;
xer_type_decoder_f TemporaryID_decode_xer;
xer_type_encoder_f TemporaryID_encode_xer;

/*** <<< CODE [TemporaryID] >>> ***/

int
TemporaryID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 4)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
TemporaryID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
TemporaryID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TemporaryID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TemporaryID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TemporaryID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TemporaryID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TemporaryID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TemporaryID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TemporaryID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TemporaryID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TemporaryID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TemporaryID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TemporaryID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TemporaryID] >>> ***/

static ber_tlv_tag_t asn_DEF_TemporaryID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TemporaryID = {
	"TemporaryID",
	"TemporaryID",
	TemporaryID_free,
	TemporaryID_print,
	TemporaryID_constraint,
	TemporaryID_decode_ber,
	TemporaryID_encode_der,
	TemporaryID_decode_xer,
	TemporaryID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TemporaryID_tags_1,
	sizeof(asn_DEF_TemporaryID_tags_1)
		/sizeof(asn_DEF_TemporaryID_tags_1[0]), /* 1 */
	asn_DEF_TemporaryID_tags_1,	/* Same as above */
	sizeof(asn_DEF_TemporaryID_tags_1)
		/sizeof(asn_DEF_TemporaryID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TermDistance] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TermDistance] >>> ***/

typedef long	 TermDistance_t;

/*** <<< FUNC-DECLS [TermDistance] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TermDistance;
asn_struct_free_f TermDistance_free;
asn_struct_print_f TermDistance_print;
asn_constr_check_f TermDistance_constraint;
ber_type_decoder_f TermDistance_decode_ber;
der_type_encoder_f TermDistance_encode_der;
xer_type_decoder_f TermDistance_decode_xer;
xer_type_encoder_f TermDistance_encode_xer;

/*** <<< CODE [TermDistance] >>> ***/

int
TermDistance_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 30000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TermDistance_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TermDistance_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TermDistance_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TermDistance_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TermDistance_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TermDistance_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TermDistance_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TermDistance_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TermDistance_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TermDistance_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TermDistance_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TermDistance_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TermDistance_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TermDistance] >>> ***/

static ber_tlv_tag_t asn_DEF_TermDistance_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TermDistance = {
	"TermDistance",
	"TermDistance",
	TermDistance_free,
	TermDistance_print,
	TermDistance_constraint,
	TermDistance_decode_ber,
	TermDistance_encode_der,
	TermDistance_decode_xer,
	TermDistance_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TermDistance_tags_1,
	sizeof(asn_DEF_TermDistance_tags_1)
		/sizeof(asn_DEF_TermDistance_tags_1[0]), /* 1 */
	asn_DEF_TermDistance_tags_1,	/* Same as above */
	sizeof(asn_DEF_TermDistance_tags_1)
		/sizeof(asn_DEF_TermDistance_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TermTime] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TermTime] >>> ***/

typedef long	 TermTime_t;

/*** <<< FUNC-DECLS [TermTime] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TermTime;
asn_struct_free_f TermTime_free;
asn_struct_print_f TermTime_print;
asn_constr_check_f TermTime_constraint;
ber_type_decoder_f TermTime_decode_ber;
der_type_encoder_f TermTime_encode_der;
xer_type_decoder_f TermTime_decode_xer;
xer_type_encoder_f TermTime_encode_xer;

/*** <<< CODE [TermTime] >>> ***/

int
TermTime_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 1800)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TermTime_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TermTime_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TermTime_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TermTime_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TermTime_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TermTime_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TermTime_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TermTime_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TermTime_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TermTime_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TermTime_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TermTime_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TermTime_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TermTime] >>> ***/

static ber_tlv_tag_t asn_DEF_TermTime_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TermTime = {
	"TermTime",
	"TermTime",
	TermTime_free,
	TermTime_print,
	TermTime_constraint,
	TermTime_decode_ber,
	TermTime_encode_der,
	TermTime_decode_xer,
	TermTime_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TermTime_tags_1,
	sizeof(asn_DEF_TermTime_tags_1)
		/sizeof(asn_DEF_TermTime_tags_1[0]), /* 1 */
	asn_DEF_TermTime_tags_1,	/* Same as above */
	sizeof(asn_DEF_TermTime_tags_1)
		/sizeof(asn_DEF_TermTime_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ThrottleConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [ThrottleConfidence] >>> ***/

typedef enum ThrottleConfidence {
	ThrottleConfidence_unavailable	= 0,
	ThrottleConfidence_prec10percent	= 1,
	ThrottleConfidence_prec1percent	= 2,
	ThrottleConfidence_prec0_5percent	= 3
} e_ThrottleConfidence;

/*** <<< TYPE-DECLS [ThrottleConfidence] >>> ***/

typedef long	 ThrottleConfidence_t;

/*** <<< FUNC-DECLS [ThrottleConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ThrottleConfidence;
asn_struct_free_f ThrottleConfidence_free;
asn_struct_print_f ThrottleConfidence_print;
asn_constr_check_f ThrottleConfidence_constraint;
ber_type_decoder_f ThrottleConfidence_decode_ber;
der_type_encoder_f ThrottleConfidence_encode_der;
xer_type_decoder_f ThrottleConfidence_decode_xer;
xer_type_encoder_f ThrottleConfidence_encode_xer;

/*** <<< CODE [ThrottleConfidence] >>> ***/

int
ThrottleConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
ThrottleConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
ThrottleConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ThrottleConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ThrottleConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ThrottleConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ThrottleConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ThrottleConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ThrottleConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ThrottleConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ThrottleConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_ThrottleConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	13,	"prec10percent" },
	{ 2,	12,	"prec1percent" },
	{ 3,	14,	"prec0-5percent" }
};
static unsigned int asn_MAP_ThrottleConfidence_enum2value_1[] = {
	3,	/* prec0-5percent(3) */
	1,	/* prec10percent(1) */
	2,	/* prec1percent(2) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_ThrottleConfidence_specs_1 = {
	asn_MAP_ThrottleConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_ThrottleConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_ThrottleConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ThrottleConfidence = {
	"ThrottleConfidence",
	"ThrottleConfidence",
	ThrottleConfidence_free,
	ThrottleConfidence_print,
	ThrottleConfidence_constraint,
	ThrottleConfidence_decode_ber,
	ThrottleConfidence_encode_der,
	ThrottleConfidence_decode_xer,
	ThrottleConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ThrottleConfidence_tags_1,
	sizeof(asn_DEF_ThrottleConfidence_tags_1)
		/sizeof(asn_DEF_ThrottleConfidence_tags_1[0]), /* 1 */
	asn_DEF_ThrottleConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_ThrottleConfidence_tags_1)
		/sizeof(asn_DEF_ThrottleConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ThrottleConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ThrottlePosition] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ThrottlePosition] >>> ***/

typedef long	 ThrottlePosition_t;

/*** <<< FUNC-DECLS [ThrottlePosition] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ThrottlePosition;
asn_struct_free_f ThrottlePosition_free;
asn_struct_print_f ThrottlePosition_print;
asn_constr_check_f ThrottlePosition_constraint;
ber_type_decoder_f ThrottlePosition_decode_ber;
der_type_encoder_f ThrottlePosition_encode_der;
xer_type_decoder_f ThrottlePosition_decode_xer;
xer_type_encoder_f ThrottlePosition_encode_xer;

/*** <<< CODE [ThrottlePosition] >>> ***/

int
ThrottlePosition_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 200)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ThrottlePosition_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ThrottlePosition_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ThrottlePosition_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ThrottlePosition_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ThrottlePosition_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ThrottlePosition_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ThrottlePosition_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ThrottlePosition_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ThrottlePosition_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ThrottlePosition_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ThrottlePosition_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ThrottlePosition_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ThrottlePosition_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ThrottlePosition] >>> ***/

static ber_tlv_tag_t asn_DEF_ThrottlePosition_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ThrottlePosition = {
	"ThrottlePosition",
	"ThrottlePosition",
	ThrottlePosition_free,
	ThrottlePosition_print,
	ThrottlePosition_constraint,
	ThrottlePosition_decode_ber,
	ThrottlePosition_encode_der,
	ThrottlePosition_decode_xer,
	ThrottlePosition_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ThrottlePosition_tags_1,
	sizeof(asn_DEF_ThrottlePosition_tags_1)
		/sizeof(asn_DEF_ThrottlePosition_tags_1[0]), /* 1 */
	asn_DEF_ThrottlePosition_tags_1,	/* Same as above */
	sizeof(asn_DEF_ThrottlePosition_tags_1)
		/sizeof(asn_DEF_ThrottlePosition_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TimeConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [TimeConfidence] >>> ***/

typedef enum TimeConfidence {
	TimeConfidence_unavailable	= 0,
	TimeConfidence_time_100_000	= 1,
	TimeConfidence_time_050_000	= 2,
	TimeConfidence_time_020_000	= 3,
	TimeConfidence_time_010_000	= 4,
	TimeConfidence_time_002_000	= 5,
	TimeConfidence_time_001_000	= 6,
	TimeConfidence_time_000_500	= 7,
	TimeConfidence_time_000_200	= 8,
	TimeConfidence_time_000_100	= 9,
	TimeConfidence_time_000_050	= 10,
	TimeConfidence_time_000_020	= 11,
	TimeConfidence_time_000_010	= 12,
	TimeConfidence_time_000_005	= 13,
	TimeConfidence_time_000_002	= 14,
	TimeConfidence_time_000_001	= 15,
	TimeConfidence_time_000_000_5	= 16,
	TimeConfidence_time_000_000_2	= 17,
	TimeConfidence_time_000_000_1	= 18,
	TimeConfidence_time_000_000_05	= 19,
	TimeConfidence_time_000_000_02	= 20,
	TimeConfidence_time_000_000_01	= 21,
	TimeConfidence_time_000_000_005	= 22,
	TimeConfidence_time_000_000_002	= 23,
	TimeConfidence_time_000_000_001	= 24,
	TimeConfidence_time_000_000_000_5	= 25,
	TimeConfidence_time_000_000_000_2	= 26,
	TimeConfidence_time_000_000_000_1	= 27,
	TimeConfidence_time_000_000_000_05	= 28,
	TimeConfidence_time_000_000_000_02	= 29,
	TimeConfidence_time_000_000_000_01	= 30,
	TimeConfidence_time_000_000_000_005	= 31,
	TimeConfidence_time_000_000_000_002	= 32,
	TimeConfidence_time_000_000_000_001	= 33,
	TimeConfidence_time_000_000_000_000_5	= 34,
	TimeConfidence_time_000_000_000_000_2	= 35,
	TimeConfidence_time_000_000_000_000_1	= 36,
	TimeConfidence_time_000_000_000_000_05	= 37,
	TimeConfidence_time_000_000_000_000_02	= 38,
	TimeConfidence_time_000_000_000_000_01	= 39
} e_TimeConfidence;

/*** <<< TYPE-DECLS [TimeConfidence] >>> ***/

typedef long	 TimeConfidence_t;

/*** <<< FUNC-DECLS [TimeConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TimeConfidence;
asn_struct_free_f TimeConfidence_free;
asn_struct_print_f TimeConfidence_print;
asn_constr_check_f TimeConfidence_constraint;
ber_type_decoder_f TimeConfidence_decode_ber;
der_type_encoder_f TimeConfidence_encode_der;
xer_type_decoder_f TimeConfidence_decode_xer;
xer_type_encoder_f TimeConfidence_encode_xer;

/*** <<< CODE [TimeConfidence] >>> ***/

int
TimeConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
TimeConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
TimeConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TimeConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TimeConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TimeConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TimeConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TimeConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TimeConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TimeConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TimeConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TimeConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TimeConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TimeConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TimeConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_TimeConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	12,	"time-100-000" },
	{ 2,	12,	"time-050-000" },
	{ 3,	12,	"time-020-000" },
	{ 4,	12,	"time-010-000" },
	{ 5,	12,	"time-002-000" },
	{ 6,	12,	"time-001-000" },
	{ 7,	12,	"time-000-500" },
	{ 8,	12,	"time-000-200" },
	{ 9,	12,	"time-000-100" },
	{ 10,	12,	"time-000-050" },
	{ 11,	12,	"time-000-020" },
	{ 12,	12,	"time-000-010" },
	{ 13,	12,	"time-000-005" },
	{ 14,	12,	"time-000-002" },
	{ 15,	12,	"time-000-001" },
	{ 16,	14,	"time-000-000-5" },
	{ 17,	14,	"time-000-000-2" },
	{ 18,	14,	"time-000-000-1" },
	{ 19,	15,	"time-000-000-05" },
	{ 20,	15,	"time-000-000-02" },
	{ 21,	15,	"time-000-000-01" },
	{ 22,	16,	"time-000-000-005" },
	{ 23,	16,	"time-000-000-002" },
	{ 24,	16,	"time-000-000-001" },
	{ 25,	18,	"time-000-000-000-5" },
	{ 26,	18,	"time-000-000-000-2" },
	{ 27,	18,	"time-000-000-000-1" },
	{ 28,	19,	"time-000-000-000-05" },
	{ 29,	19,	"time-000-000-000-02" },
	{ 30,	19,	"time-000-000-000-01" },
	{ 31,	20,	"time-000-000-000-005" },
	{ 32,	20,	"time-000-000-000-002" },
	{ 33,	20,	"time-000-000-000-001" },
	{ 34,	22,	"time-000-000-000-000-5" },
	{ 35,	22,	"time-000-000-000-000-2" },
	{ 36,	22,	"time-000-000-000-000-1" },
	{ 37,	23,	"time-000-000-000-000-05" },
	{ 38,	23,	"time-000-000-000-000-02" },
	{ 39,	23,	"time-000-000-000-000-01" }
};
static unsigned int asn_MAP_TimeConfidence_enum2value_1[] = {
	39,	/* time-000-000-000-000-01(39) */
	38,	/* time-000-000-000-000-02(38) */
	37,	/* time-000-000-000-000-05(37) */
	36,	/* time-000-000-000-000-1(36) */
	35,	/* time-000-000-000-000-2(35) */
	34,	/* time-000-000-000-000-5(34) */
	33,	/* time-000-000-000-001(33) */
	32,	/* time-000-000-000-002(32) */
	31,	/* time-000-000-000-005(31) */
	30,	/* time-000-000-000-01(30) */
	29,	/* time-000-000-000-02(29) */
	28,	/* time-000-000-000-05(28) */
	27,	/* time-000-000-000-1(27) */
	26,	/* time-000-000-000-2(26) */
	25,	/* time-000-000-000-5(25) */
	24,	/* time-000-000-001(24) */
	23,	/* time-000-000-002(23) */
	22,	/* time-000-000-005(22) */
	21,	/* time-000-000-01(21) */
	20,	/* time-000-000-02(20) */
	19,	/* time-000-000-05(19) */
	18,	/* time-000-000-1(18) */
	17,	/* time-000-000-2(17) */
	16,	/* time-000-000-5(16) */
	15,	/* time-000-001(15) */
	14,	/* time-000-002(14) */
	13,	/* time-000-005(13) */
	12,	/* time-000-010(12) */
	11,	/* time-000-020(11) */
	10,	/* time-000-050(10) */
	9,	/* time-000-100(9) */
	8,	/* time-000-200(8) */
	7,	/* time-000-500(7) */
	6,	/* time-001-000(6) */
	5,	/* time-002-000(5) */
	4,	/* time-010-000(4) */
	3,	/* time-020-000(3) */
	2,	/* time-050-000(2) */
	1,	/* time-100-000(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_TimeConfidence_specs_1 = {
	asn_MAP_TimeConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_TimeConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	40,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_TimeConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TimeConfidence = {
	"TimeConfidence",
	"TimeConfidence",
	TimeConfidence_free,
	TimeConfidence_print,
	TimeConfidence_constraint,
	TimeConfidence_decode_ber,
	TimeConfidence_encode_der,
	TimeConfidence_decode_xer,
	TimeConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TimeConfidence_tags_1,
	sizeof(asn_DEF_TimeConfidence_tags_1)
		/sizeof(asn_DEF_TimeConfidence_tags_1[0]), /* 1 */
	asn_DEF_TimeConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_TimeConfidence_tags_1)
		/sizeof(asn_DEF_TimeConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_TimeConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TimeMark] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TimeMark] >>> ***/

typedef long	 TimeMark_t;

/*** <<< FUNC-DECLS [TimeMark] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TimeMark;
asn_struct_free_f TimeMark_free;
asn_struct_print_f TimeMark_print;
asn_constr_check_f TimeMark_constraint;
ber_type_decoder_f TimeMark_decode_ber;
der_type_encoder_f TimeMark_encode_der;
xer_type_decoder_f TimeMark_decode_xer;
xer_type_encoder_f TimeMark_encode_xer;

/*** <<< CODE [TimeMark] >>> ***/

int
TimeMark_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 12002)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TimeMark_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TimeMark_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TimeMark_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TimeMark_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TimeMark_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TimeMark_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TimeMark_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TimeMark_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TimeMark_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TimeMark_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TimeMark_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TimeMark_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TimeMark_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TimeMark] >>> ***/

static ber_tlv_tag_t asn_DEF_TimeMark_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TimeMark = {
	"TimeMark",
	"TimeMark",
	TimeMark_free,
	TimeMark_print,
	TimeMark_constraint,
	TimeMark_decode_ber,
	TimeMark_encode_der,
	TimeMark_decode_xer,
	TimeMark_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TimeMark_tags_1,
	sizeof(asn_DEF_TimeMark_tags_1)
		/sizeof(asn_DEF_TimeMark_tags_1[0]), /* 1 */
	asn_DEF_TimeMark_tags_1,	/* Same as above */
	sizeof(asn_DEF_TimeMark_tags_1)
		/sizeof(asn_DEF_TimeMark_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TireLeakageRate] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TireLeakageRate] >>> ***/

typedef long	 TireLeakageRate_t;

/*** <<< FUNC-DECLS [TireLeakageRate] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TireLeakageRate;
asn_struct_free_f TireLeakageRate_free;
asn_struct_print_f TireLeakageRate_print;
asn_constr_check_f TireLeakageRate_constraint;
ber_type_decoder_f TireLeakageRate_decode_ber;
der_type_encoder_f TireLeakageRate_encode_der;
xer_type_decoder_f TireLeakageRate_decode_xer;
xer_type_encoder_f TireLeakageRate_encode_xer;

/*** <<< CODE [TireLeakageRate] >>> ***/

int
TireLeakageRate_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TireLeakageRate_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TireLeakageRate_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TireLeakageRate_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TireLeakageRate_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TireLeakageRate_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TireLeakageRate_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TireLeakageRate_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TireLeakageRate_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TireLeakageRate_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TireLeakageRate_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TireLeakageRate_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TireLeakageRate_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TireLeakageRate_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TireLeakageRate] >>> ***/

static ber_tlv_tag_t asn_DEF_TireLeakageRate_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TireLeakageRate = {
	"TireLeakageRate",
	"TireLeakageRate",
	TireLeakageRate_free,
	TireLeakageRate_print,
	TireLeakageRate_constraint,
	TireLeakageRate_decode_ber,
	TireLeakageRate_encode_der,
	TireLeakageRate_decode_xer,
	TireLeakageRate_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TireLeakageRate_tags_1,
	sizeof(asn_DEF_TireLeakageRate_tags_1)
		/sizeof(asn_DEF_TireLeakageRate_tags_1[0]), /* 1 */
	asn_DEF_TireLeakageRate_tags_1,	/* Same as above */
	sizeof(asn_DEF_TireLeakageRate_tags_1)
		/sizeof(asn_DEF_TireLeakageRate_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TireLocation] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TireLocation] >>> ***/

typedef long	 TireLocation_t;

/*** <<< FUNC-DECLS [TireLocation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TireLocation;
asn_struct_free_f TireLocation_free;
asn_struct_print_f TireLocation_print;
asn_constr_check_f TireLocation_constraint;
ber_type_decoder_f TireLocation_decode_ber;
der_type_encoder_f TireLocation_encode_der;
xer_type_decoder_f TireLocation_decode_xer;
xer_type_encoder_f TireLocation_encode_xer;

/*** <<< CODE [TireLocation] >>> ***/

int
TireLocation_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TireLocation_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TireLocation_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TireLocation_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TireLocation_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TireLocation_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TireLocation_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TireLocation_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TireLocation_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TireLocation_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TireLocation_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TireLocation_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TireLocation_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TireLocation_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TireLocation] >>> ***/

static ber_tlv_tag_t asn_DEF_TireLocation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TireLocation = {
	"TireLocation",
	"TireLocation",
	TireLocation_free,
	TireLocation_print,
	TireLocation_constraint,
	TireLocation_decode_ber,
	TireLocation_encode_der,
	TireLocation_decode_xer,
	TireLocation_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TireLocation_tags_1,
	sizeof(asn_DEF_TireLocation_tags_1)
		/sizeof(asn_DEF_TireLocation_tags_1[0]), /* 1 */
	asn_DEF_TireLocation_tags_1,	/* Same as above */
	sizeof(asn_DEF_TireLocation_tags_1)
		/sizeof(asn_DEF_TireLocation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TirePressure] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TirePressure] >>> ***/

typedef long	 TirePressure_t;

/*** <<< FUNC-DECLS [TirePressure] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TirePressure;
asn_struct_free_f TirePressure_free;
asn_struct_print_f TirePressure_print;
asn_constr_check_f TirePressure_constraint;
ber_type_decoder_f TirePressure_decode_ber;
der_type_encoder_f TirePressure_encode_der;
xer_type_decoder_f TirePressure_decode_xer;
xer_type_encoder_f TirePressure_encode_xer;

/*** <<< CODE [TirePressure] >>> ***/

int
TirePressure_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 1000)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TirePressure_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TirePressure_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TirePressure_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TirePressure_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TirePressure_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TirePressure_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TirePressure_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TirePressure_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TirePressure_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TirePressure_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TirePressure_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TirePressure_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TirePressure_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TirePressure] >>> ***/

static ber_tlv_tag_t asn_DEF_TirePressure_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TirePressure = {
	"TirePressure",
	"TirePressure",
	TirePressure_free,
	TirePressure_print,
	TirePressure_constraint,
	TirePressure_decode_ber,
	TirePressure_encode_der,
	TirePressure_decode_xer,
	TirePressure_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TirePressure_tags_1,
	sizeof(asn_DEF_TirePressure_tags_1)
		/sizeof(asn_DEF_TirePressure_tags_1[0]), /* 1 */
	asn_DEF_TirePressure_tags_1,	/* Same as above */
	sizeof(asn_DEF_TirePressure_tags_1)
		/sizeof(asn_DEF_TirePressure_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TirePressureThresholdDetection] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [TirePressureThresholdDetection] >>> ***/

typedef enum TirePressureThresholdDetection {
	TirePressureThresholdDetection_noData	= 0,
	TirePressureThresholdDetection_overPressure	= 1,
	TirePressureThresholdDetection_noWarningPressure	= 2,
	TirePressureThresholdDetection_underPressure	= 3,
	TirePressureThresholdDetection_extremeUnderPressure	= 4,
	TirePressureThresholdDetection_undefined	= 5,
	TirePressureThresholdDetection_errorIndicator	= 6,
	TirePressureThresholdDetection_notAvailable	= 7
	/*
	 * Enumeration is extensible
	 */
} e_TirePressureThresholdDetection;

/*** <<< TYPE-DECLS [TirePressureThresholdDetection] >>> ***/

typedef long	 TirePressureThresholdDetection_t;

/*** <<< FUNC-DECLS [TirePressureThresholdDetection] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TirePressureThresholdDetection;
asn_struct_free_f TirePressureThresholdDetection_free;
asn_struct_print_f TirePressureThresholdDetection_print;
asn_constr_check_f TirePressureThresholdDetection_constraint;
ber_type_decoder_f TirePressureThresholdDetection_decode_ber;
der_type_encoder_f TirePressureThresholdDetection_encode_der;
xer_type_decoder_f TirePressureThresholdDetection_decode_xer;
xer_type_encoder_f TirePressureThresholdDetection_encode_xer;

/*** <<< CODE [TirePressureThresholdDetection] >>> ***/

int
TirePressureThresholdDetection_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
TirePressureThresholdDetection_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
TirePressureThresholdDetection_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TirePressureThresholdDetection_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TirePressureThresholdDetection_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TirePressureThresholdDetection_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TirePressureThresholdDetection_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TirePressureThresholdDetection_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TirePressureThresholdDetection_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TirePressureThresholdDetection_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TirePressureThresholdDetection_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TirePressureThresholdDetection_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TirePressureThresholdDetection_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TirePressureThresholdDetection_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TirePressureThresholdDetection] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_TirePressureThresholdDetection_value2enum_1[] = {
	{ 0,	6,	"noData" },
	{ 1,	12,	"overPressure" },
	{ 2,	17,	"noWarningPressure" },
	{ 3,	13,	"underPressure" },
	{ 4,	20,	"extremeUnderPressure" },
	{ 5,	9,	"undefined" },
	{ 6,	14,	"errorIndicator" },
	{ 7,	12,	"notAvailable" }
	/* This list is extensible */
};
static unsigned int asn_MAP_TirePressureThresholdDetection_enum2value_1[] = {
	6,	/* errorIndicator(6) */
	4,	/* extremeUnderPressure(4) */
	0,	/* noData(0) */
	2,	/* noWarningPressure(2) */
	7,	/* notAvailable(7) */
	1,	/* overPressure(1) */
	5,	/* undefined(5) */
	3	/* underPressure(3) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_TirePressureThresholdDetection_specs_1 = {
	asn_MAP_TirePressureThresholdDetection_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_TirePressureThresholdDetection_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	9,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_TirePressureThresholdDetection_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TirePressureThresholdDetection = {
	"TirePressureThresholdDetection",
	"TirePressureThresholdDetection",
	TirePressureThresholdDetection_free,
	TirePressureThresholdDetection_print,
	TirePressureThresholdDetection_constraint,
	TirePressureThresholdDetection_decode_ber,
	TirePressureThresholdDetection_encode_der,
	TirePressureThresholdDetection_decode_xer,
	TirePressureThresholdDetection_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TirePressureThresholdDetection_tags_1,
	sizeof(asn_DEF_TirePressureThresholdDetection_tags_1)
		/sizeof(asn_DEF_TirePressureThresholdDetection_tags_1[0]), /* 1 */
	asn_DEF_TirePressureThresholdDetection_tags_1,	/* Same as above */
	sizeof(asn_DEF_TirePressureThresholdDetection_tags_1)
		/sizeof(asn_DEF_TirePressureThresholdDetection_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_TirePressureThresholdDetection_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TireTemp] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TireTemp] >>> ***/

typedef long	 TireTemp_t;

/*** <<< FUNC-DECLS [TireTemp] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TireTemp;
asn_struct_free_f TireTemp_free;
asn_struct_print_f TireTemp_print;
asn_constr_check_f TireTemp_constraint;
ber_type_decoder_f TireTemp_decode_ber;
der_type_encoder_f TireTemp_encode_der;
xer_type_decoder_f TireTemp_decode_xer;
xer_type_encoder_f TireTemp_encode_xer;

/*** <<< CODE [TireTemp] >>> ***/

int
TireTemp_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TireTemp_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TireTemp_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TireTemp_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TireTemp_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TireTemp_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TireTemp_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TireTemp_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TireTemp_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TireTemp_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TireTemp_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TireTemp_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TireTemp_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TireTemp_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TireTemp] >>> ***/

static ber_tlv_tag_t asn_DEF_TireTemp_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TireTemp = {
	"TireTemp",
	"TireTemp",
	TireTemp_free,
	TireTemp_print,
	TireTemp_constraint,
	TireTemp_decode_ber,
	TireTemp_encode_der,
	TireTemp_decode_xer,
	TireTemp_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TireTemp_tags_1,
	sizeof(asn_DEF_TireTemp_tags_1)
		/sizeof(asn_DEF_TireTemp_tags_1[0]), /* 1 */
	asn_DEF_TireTemp_tags_1,	/* Same as above */
	sizeof(asn_DEF_TireTemp_tags_1)
		/sizeof(asn_DEF_TireTemp_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TractionControlState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [TractionControlState] >>> ***/

typedef enum TractionControlState {
	TractionControlState_unavailable	= 0,
	TractionControlState_off	= 1,
	TractionControlState_on	= 2,
	TractionControlState_engaged	= 3
} e_TractionControlState;

/*** <<< TYPE-DECLS [TractionControlState] >>> ***/

typedef long	 TractionControlState_t;

/*** <<< FUNC-DECLS [TractionControlState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TractionControlState;
asn_struct_free_f TractionControlState_free;
asn_struct_print_f TractionControlState_print;
asn_constr_check_f TractionControlState_constraint;
ber_type_decoder_f TractionControlState_decode_ber;
der_type_encoder_f TractionControlState_encode_der;
xer_type_decoder_f TractionControlState_decode_xer;
xer_type_encoder_f TractionControlState_encode_xer;

/*** <<< CODE [TractionControlState] >>> ***/

int
TractionControlState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
TractionControlState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
TractionControlState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TractionControlState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TractionControlState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TractionControlState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TractionControlState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TractionControlState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TractionControlState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TractionControlState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TractionControlState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TractionControlState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TractionControlState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TractionControlState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TractionControlState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_TractionControlState_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	2,	"on" },
	{ 3,	7,	"engaged" }
};
static unsigned int asn_MAP_TractionControlState_enum2value_1[] = {
	3,	/* engaged(3) */
	1,	/* off(1) */
	2,	/* on(2) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_TractionControlState_specs_1 = {
	asn_MAP_TractionControlState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_TractionControlState_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_TractionControlState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TractionControlState = {
	"TractionControlState",
	"TractionControlState",
	TractionControlState_free,
	TractionControlState_print,
	TractionControlState_constraint,
	TractionControlState_decode_ber,
	TractionControlState_encode_der,
	TractionControlState_decode_xer,
	TractionControlState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TractionControlState_tags_1,
	sizeof(asn_DEF_TractionControlState_tags_1)
		/sizeof(asn_DEF_TractionControlState_tags_1[0]), /* 1 */
	asn_DEF_TractionControlState_tags_1,	/* Same as above */
	sizeof(asn_DEF_TractionControlState_tags_1)
		/sizeof(asn_DEF_TractionControlState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_TractionControlState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TrailerWeight] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TrailerWeight] >>> ***/

typedef long	 TrailerWeight_t;

/*** <<< FUNC-DECLS [TrailerWeight] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TrailerWeight;
asn_struct_free_f TrailerWeight_free;
asn_struct_print_f TrailerWeight_print;
asn_constr_check_f TrailerWeight_constraint;
ber_type_decoder_f TrailerWeight_decode_ber;
der_type_encoder_f TrailerWeight_encode_der;
xer_type_decoder_f TrailerWeight_decode_xer;
xer_type_encoder_f TrailerWeight_encode_xer;

/*** <<< CODE [TrailerWeight] >>> ***/

int
TrailerWeight_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TrailerWeight_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TrailerWeight_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TrailerWeight_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TrailerWeight_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TrailerWeight_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TrailerWeight_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TrailerWeight_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TrailerWeight_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TrailerWeight_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TrailerWeight_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TrailerWeight_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TrailerWeight_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TrailerWeight_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TrailerWeight] >>> ***/

static ber_tlv_tag_t asn_DEF_TrailerWeight_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TrailerWeight = {
	"TrailerWeight",
	"TrailerWeight",
	TrailerWeight_free,
	TrailerWeight_print,
	TrailerWeight_constraint,
	TrailerWeight_decode_ber,
	TrailerWeight_encode_der,
	TrailerWeight_decode_xer,
	TrailerWeight_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TrailerWeight_tags_1,
	sizeof(asn_DEF_TrailerWeight_tags_1)
		/sizeof(asn_DEF_TrailerWeight_tags_1[0]), /* 1 */
	asn_DEF_TrailerWeight_tags_1,	/* Same as above */
	sizeof(asn_DEF_TrailerWeight_tags_1)
		/sizeof(asn_DEF_TrailerWeight_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [TransitPreEmptionRequest] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [TransitPreEmptionRequest] >>> ***/

typedef enum TransitPreEmptionRequest {
	TransitPreEmptionRequest_typeOne	= 0,
	TransitPreEmptionRequest_typeTwo	= 1,
	TransitPreEmptionRequest_typeThree	= 2,
	TransitPreEmptionRequest_typeFour	= 3
	/*
	 * Enumeration is extensible
	 */
} e_TransitPreEmptionRequest;

/*** <<< TYPE-DECLS [TransitPreEmptionRequest] >>> ***/

typedef long	 TransitPreEmptionRequest_t;

/*** <<< FUNC-DECLS [TransitPreEmptionRequest] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TransitPreEmptionRequest;
asn_struct_free_f TransitPreEmptionRequest_free;
asn_struct_print_f TransitPreEmptionRequest_print;
asn_constr_check_f TransitPreEmptionRequest_constraint;
ber_type_decoder_f TransitPreEmptionRequest_decode_ber;
der_type_encoder_f TransitPreEmptionRequest_encode_der;
xer_type_decoder_f TransitPreEmptionRequest_decode_xer;
xer_type_encoder_f TransitPreEmptionRequest_encode_xer;

/*** <<< CODE [TransitPreEmptionRequest] >>> ***/

int
TransitPreEmptionRequest_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
TransitPreEmptionRequest_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
TransitPreEmptionRequest_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TransitPreEmptionRequest_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TransitPreEmptionRequest_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TransitPreEmptionRequest_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TransitPreEmptionRequest_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TransitPreEmptionRequest_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TransitPreEmptionRequest_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransitPreEmptionRequest_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TransitPreEmptionRequest_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TransitPreEmptionRequest_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TransitPreEmptionRequest_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransitPreEmptionRequest_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TransitPreEmptionRequest] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_TransitPreEmptionRequest_value2enum_1[] = {
	{ 0,	7,	"typeOne" },
	{ 1,	7,	"typeTwo" },
	{ 2,	9,	"typeThree" },
	{ 3,	8,	"typeFour" }
	/* This list is extensible */
};
static unsigned int asn_MAP_TransitPreEmptionRequest_enum2value_1[] = {
	3,	/* typeFour(3) */
	0,	/* typeOne(0) */
	2,	/* typeThree(2) */
	1	/* typeTwo(1) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_TransitPreEmptionRequest_specs_1 = {
	asn_MAP_TransitPreEmptionRequest_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_TransitPreEmptionRequest_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	5,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_TransitPreEmptionRequest_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TransitPreEmptionRequest = {
	"TransitPreEmptionRequest",
	"TransitPreEmptionRequest",
	TransitPreEmptionRequest_free,
	TransitPreEmptionRequest_print,
	TransitPreEmptionRequest_constraint,
	TransitPreEmptionRequest_decode_ber,
	TransitPreEmptionRequest_encode_der,
	TransitPreEmptionRequest_decode_xer,
	TransitPreEmptionRequest_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TransitPreEmptionRequest_tags_1,
	sizeof(asn_DEF_TransitPreEmptionRequest_tags_1)
		/sizeof(asn_DEF_TransitPreEmptionRequest_tags_1[0]), /* 1 */
	asn_DEF_TransitPreEmptionRequest_tags_1,	/* Same as above */
	sizeof(asn_DEF_TransitPreEmptionRequest_tags_1)
		/sizeof(asn_DEF_TransitPreEmptionRequest_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_TransitPreEmptionRequest_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TransitStatus] >>> ***/

#include <BIT_STRING.h>

/*** <<< DEPS [TransitStatus] >>> ***/

typedef enum TransitStatus {
	TransitStatus_none	= 0,
	TransitStatus_anADAuse	= 1,
	TransitStatus_aBikeLoad	= 2,
	TransitStatus_doorOpen	= 3,
	TransitStatus_occM	= 4,
	TransitStatus_occL	= 5
} e_TransitStatus;

/*** <<< TYPE-DECLS [TransitStatus] >>> ***/

typedef BIT_STRING_t	 TransitStatus_t;

/*** <<< FUNC-DECLS [TransitStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TransitStatus;
asn_struct_free_f TransitStatus_free;
asn_struct_print_f TransitStatus_print;
asn_constr_check_f TransitStatus_constraint;
ber_type_decoder_f TransitStatus_decode_ber;
der_type_encoder_f TransitStatus_encode_der;
xer_type_decoder_f TransitStatus_decode_xer;
xer_type_encoder_f TransitStatus_encode_xer;

/*** <<< CODE [TransitStatus] >>> ***/

int
TransitStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 6)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using BIT_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
TransitStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_BIT_STRING.free_struct;
	td->print_struct   = asn_DEF_BIT_STRING.print_struct;
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_BIT_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_BIT_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_BIT_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_BIT_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_BIT_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_BIT_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_BIT_STRING.per_constraints;
	td->elements       = asn_DEF_BIT_STRING.elements;
	td->elements_count = asn_DEF_BIT_STRING.elements_count;
	td->specifics      = asn_DEF_BIT_STRING.specifics;
}

void
TransitStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TransitStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TransitStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TransitStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TransitStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TransitStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TransitStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransitStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TransitStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TransitStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TransitStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransitStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TransitStatus] >>> ***/

static ber_tlv_tag_t asn_DEF_TransitStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (3 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TransitStatus = {
	"TransitStatus",
	"TransitStatus",
	TransitStatus_free,
	TransitStatus_print,
	TransitStatus_constraint,
	TransitStatus_decode_ber,
	TransitStatus_encode_der,
	TransitStatus_decode_xer,
	TransitStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TransitStatus_tags_1,
	sizeof(asn_DEF_TransitStatus_tags_1)
		/sizeof(asn_DEF_TransitStatus_tags_1[0]), /* 1 */
	asn_DEF_TransitStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_TransitStatus_tags_1)
		/sizeof(asn_DEF_TransitStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	0	/* No specifics */
};


/*** <<< INCLUDES [TransmissionState] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [TransmissionState] >>> ***/

typedef enum TransmissionState {
	TransmissionState_neutral	= 0,
	TransmissionState_park	= 1,
	TransmissionState_forwardGears	= 2,
	TransmissionState_reverseGears	= 3,
	TransmissionState_reserved1	= 4,
	TransmissionState_reserved2	= 5,
	TransmissionState_reserved3	= 6,
	TransmissionState_unavailable	= 7
	/*
	 * Enumeration is extensible
	 */
} e_TransmissionState;

/*** <<< TYPE-DECLS [TransmissionState] >>> ***/

typedef long	 TransmissionState_t;

/*** <<< FUNC-DECLS [TransmissionState] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TransmissionState;
asn_struct_free_f TransmissionState_free;
asn_struct_print_f TransmissionState_print;
asn_constr_check_f TransmissionState_constraint;
ber_type_decoder_f TransmissionState_decode_ber;
der_type_encoder_f TransmissionState_encode_der;
xer_type_decoder_f TransmissionState_decode_xer;
xer_type_encoder_f TransmissionState_encode_xer;

/*** <<< CODE [TransmissionState] >>> ***/

int
TransmissionState_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
TransmissionState_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
TransmissionState_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TransmissionState_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TransmissionState_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TransmissionState_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TransmissionState_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TransmissionState_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TransmissionState_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransmissionState_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TransmissionState_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TransmissionState_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TransmissionState_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TransmissionState_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TransmissionState] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_TransmissionState_value2enum_1[] = {
	{ 0,	7,	"neutral" },
	{ 1,	4,	"park" },
	{ 2,	12,	"forwardGears" },
	{ 3,	12,	"reverseGears" },
	{ 4,	9,	"reserved1" },
	{ 5,	9,	"reserved2" },
	{ 6,	9,	"reserved3" },
	{ 7,	11,	"unavailable" }
	/* This list is extensible */
};
static unsigned int asn_MAP_TransmissionState_enum2value_1[] = {
	2,	/* forwardGears(2) */
	0,	/* neutral(0) */
	1,	/* park(1) */
	4,	/* reserved1(4) */
	5,	/* reserved2(5) */
	6,	/* reserved3(6) */
	3,	/* reverseGears(3) */
	7	/* unavailable(7) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_TransmissionState_specs_1 = {
	asn_MAP_TransmissionState_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_TransmissionState_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	9,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_TransmissionState_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TransmissionState = {
	"TransmissionState",
	"TransmissionState",
	TransmissionState_free,
	TransmissionState_print,
	TransmissionState_constraint,
	TransmissionState_decode_ber,
	TransmissionState_encode_der,
	TransmissionState_decode_xer,
	TransmissionState_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TransmissionState_tags_1,
	sizeof(asn_DEF_TransmissionState_tags_1)
		/sizeof(asn_DEF_TransmissionState_tags_1[0]), /* 1 */
	asn_DEF_TransmissionState_tags_1,	/* Same as above */
	sizeof(asn_DEF_TransmissionState_tags_1)
		/sizeof(asn_DEF_TransmissionState_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_TransmissionState_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TravelerInfoType] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [TravelerInfoType] >>> ***/

typedef enum TravelerInfoType {
	TravelerInfoType_unknown	= 0,
	TravelerInfoType_advisory	= 1,
	TravelerInfoType_roadSignage	= 2,
	TravelerInfoType_commercialSignage	= 3
	/*
	 * Enumeration is extensible
	 */
} e_TravelerInfoType;

/*** <<< TYPE-DECLS [TravelerInfoType] >>> ***/

typedef long	 TravelerInfoType_t;

/*** <<< FUNC-DECLS [TravelerInfoType] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TravelerInfoType;
asn_struct_free_f TravelerInfoType_free;
asn_struct_print_f TravelerInfoType_print;
asn_constr_check_f TravelerInfoType_constraint;
ber_type_decoder_f TravelerInfoType_decode_ber;
der_type_encoder_f TravelerInfoType_encode_der;
xer_type_decoder_f TravelerInfoType_decode_xer;
xer_type_encoder_f TravelerInfoType_encode_xer;

/*** <<< CODE [TravelerInfoType] >>> ***/

int
TravelerInfoType_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
TravelerInfoType_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
TravelerInfoType_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TravelerInfoType_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TravelerInfoType_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TravelerInfoType_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TravelerInfoType_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TravelerInfoType_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TravelerInfoType_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TravelerInfoType_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TravelerInfoType_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TravelerInfoType_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TravelerInfoType_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TravelerInfoType_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TravelerInfoType] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_TravelerInfoType_value2enum_1[] = {
	{ 0,	7,	"unknown" },
	{ 1,	8,	"advisory" },
	{ 2,	11,	"roadSignage" },
	{ 3,	17,	"commercialSignage" }
	/* This list is extensible */
};
static unsigned int asn_MAP_TravelerInfoType_enum2value_1[] = {
	1,	/* advisory(1) */
	3,	/* commercialSignage(3) */
	2,	/* roadSignage(2) */
	0	/* unknown(0) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_TravelerInfoType_specs_1 = {
	asn_MAP_TravelerInfoType_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_TravelerInfoType_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	5,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_TravelerInfoType_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TravelerInfoType = {
	"TravelerInfoType",
	"TravelerInfoType",
	TravelerInfoType_free,
	TravelerInfoType_print,
	TravelerInfoType_constraint,
	TravelerInfoType_decode_ber,
	TravelerInfoType_encode_der,
	TravelerInfoType_decode_xer,
	TravelerInfoType_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TravelerInfoType_tags_1,
	sizeof(asn_DEF_TravelerInfoType_tags_1)
		/sizeof(asn_DEF_TravelerInfoType_tags_1[0]), /* 1 */
	asn_DEF_TravelerInfoType_tags_1,	/* Same as above */
	sizeof(asn_DEF_TravelerInfoType_tags_1)
		/sizeof(asn_DEF_TravelerInfoType_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_TravelerInfoType_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TxTime] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [TxTime] >>> ***/

typedef long	 TxTime_t;

/*** <<< FUNC-DECLS [TxTime] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TxTime;
asn_struct_free_f TxTime_free;
asn_struct_print_f TxTime_print;
asn_constr_check_f TxTime_constraint;
ber_type_decoder_f TxTime_decode_ber;
der_type_encoder_f TxTime_encode_der;
xer_type_decoder_f TxTime_decode_xer;
xer_type_encoder_f TxTime_encode_xer;

/*** <<< CODE [TxTime] >>> ***/

int
TxTime_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 20)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
TxTime_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
TxTime_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TxTime_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TxTime_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TxTime_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TxTime_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TxTime_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TxTime_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TxTime_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TxTime_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TxTime_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TxTime_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TxTime_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TxTime] >>> ***/

static ber_tlv_tag_t asn_DEF_TxTime_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TxTime = {
	"TxTime",
	"TxTime",
	TxTime_free,
	TxTime_print,
	TxTime_constraint,
	TxTime_decode_ber,
	TxTime_encode_der,
	TxTime_decode_xer,
	TxTime_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TxTime_tags_1,
	sizeof(asn_DEF_TxTime_tags_1)
		/sizeof(asn_DEF_TxTime_tags_1[0]), /* 1 */
	asn_DEF_TxTime_tags_1,	/* Same as above */
	sizeof(asn_DEF_TxTime_tags_1)
		/sizeof(asn_DEF_TxTime_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [UniqueMSGID] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [UniqueMSGID] >>> ***/

typedef OCTET_STRING_t	 UniqueMSGID_t;

/*** <<< FUNC-DECLS [UniqueMSGID] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_UniqueMSGID;
asn_struct_free_f UniqueMSGID_free;
asn_struct_print_f UniqueMSGID_print;
asn_constr_check_f UniqueMSGID_constraint;
ber_type_decoder_f UniqueMSGID_decode_ber;
der_type_encoder_f UniqueMSGID_encode_der;
xer_type_decoder_f UniqueMSGID_decode_xer;
xer_type_encoder_f UniqueMSGID_encode_xer;

/*** <<< CODE [UniqueMSGID] >>> ***/

int
UniqueMSGID_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 9)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
UniqueMSGID_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
UniqueMSGID_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	UniqueMSGID_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
UniqueMSGID_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	UniqueMSGID_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
UniqueMSGID_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	UniqueMSGID_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
UniqueMSGID_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	UniqueMSGID_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
UniqueMSGID_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	UniqueMSGID_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
UniqueMSGID_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	UniqueMSGID_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [UniqueMSGID] >>> ***/

static ber_tlv_tag_t asn_DEF_UniqueMSGID_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_UniqueMSGID = {
	"UniqueMSGID",
	"UniqueMSGID",
	UniqueMSGID_free,
	UniqueMSGID_print,
	UniqueMSGID_constraint,
	UniqueMSGID_decode_ber,
	UniqueMSGID_encode_der,
	UniqueMSGID_decode_xer,
	UniqueMSGID_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_UniqueMSGID_tags_1,
	sizeof(asn_DEF_UniqueMSGID_tags_1)
		/sizeof(asn_DEF_UniqueMSGID_tags_1[0]), /* 1 */
	asn_DEF_UniqueMSGID_tags_1,	/* Same as above */
	sizeof(asn_DEF_UniqueMSGID_tags_1)
		/sizeof(asn_DEF_UniqueMSGID_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [URL-Base] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [URL-Base] >>> ***/

typedef IA5String_t	 URL_Base_t;

/*** <<< FUNC-DECLS [URL-Base] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_URL_Base;
asn_struct_free_f URL_Base_free;
asn_struct_print_f URL_Base_print;
asn_constr_check_f URL_Base_constraint;
ber_type_decoder_f URL_Base_decode_ber;
der_type_encoder_f URL_Base_encode_der;
xer_type_decoder_f URL_Base_decode_xer;
xer_type_encoder_f URL_Base_encode_xer;

/*** <<< CTABLES [URL-Base] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [URL-Base] >>> ***/

int
URL_Base_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 45)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */
static void
URL_Base_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_IA5String.free_struct;
	td->print_struct   = asn_DEF_IA5String.print_struct;
	td->check_constraints = asn_DEF_IA5String.check_constraints;
	td->ber_decoder    = asn_DEF_IA5String.ber_decoder;
	td->der_encoder    = asn_DEF_IA5String.der_encoder;
	td->xer_decoder    = asn_DEF_IA5String.xer_decoder;
	td->xer_encoder    = asn_DEF_IA5String.xer_encoder;
	td->uper_decoder   = asn_DEF_IA5String.uper_decoder;
	td->uper_encoder   = asn_DEF_IA5String.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_IA5String.per_constraints;
	td->elements       = asn_DEF_IA5String.elements;
	td->elements_count = asn_DEF_IA5String.elements_count;
	td->specifics      = asn_DEF_IA5String.specifics;
}

void
URL_Base_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	URL_Base_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
URL_Base_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Base_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
URL_Base_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	URL_Base_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
URL_Base_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Base_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
URL_Base_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	URL_Base_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
URL_Base_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Base_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [URL-Base] >>> ***/

static ber_tlv_tag_t asn_DEF_URL_Base_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_URL_Base = {
	"URL-Base",
	"URL-Base",
	URL_Base_free,
	URL_Base_print,
	URL_Base_constraint,
	URL_Base_decode_ber,
	URL_Base_encode_der,
	URL_Base_decode_xer,
	URL_Base_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_URL_Base_tags_1,
	sizeof(asn_DEF_URL_Base_tags_1)
		/sizeof(asn_DEF_URL_Base_tags_1[0]), /* 1 */
	asn_DEF_URL_Base_tags_1,	/* Same as above */
	sizeof(asn_DEF_URL_Base_tags_1)
		/sizeof(asn_DEF_URL_Base_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [URL-Link] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [URL-Link] >>> ***/

typedef IA5String_t	 URL_Link_t;

/*** <<< FUNC-DECLS [URL-Link] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_URL_Link;
asn_struct_free_f URL_Link_free;
asn_struct_print_f URL_Link_print;
asn_constr_check_f URL_Link_constraint;
ber_type_decoder_f URL_Link_decode_ber;
der_type_encoder_f URL_Link_encode_der;
xer_type_decoder_f URL_Link_decode_xer;
xer_type_encoder_f URL_Link_encode_xer;

/*** <<< CTABLES [URL-Link] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [URL-Link] >>> ***/

int
URL_Link_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 255)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */
static void
URL_Link_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_IA5String.free_struct;
	td->print_struct   = asn_DEF_IA5String.print_struct;
	td->check_constraints = asn_DEF_IA5String.check_constraints;
	td->ber_decoder    = asn_DEF_IA5String.ber_decoder;
	td->der_encoder    = asn_DEF_IA5String.der_encoder;
	td->xer_decoder    = asn_DEF_IA5String.xer_decoder;
	td->xer_encoder    = asn_DEF_IA5String.xer_encoder;
	td->uper_decoder   = asn_DEF_IA5String.uper_decoder;
	td->uper_encoder   = asn_DEF_IA5String.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_IA5String.per_constraints;
	td->elements       = asn_DEF_IA5String.elements;
	td->elements_count = asn_DEF_IA5String.elements_count;
	td->specifics      = asn_DEF_IA5String.specifics;
}

void
URL_Link_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	URL_Link_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
URL_Link_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Link_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
URL_Link_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	URL_Link_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
URL_Link_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Link_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
URL_Link_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	URL_Link_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
URL_Link_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Link_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [URL-Link] >>> ***/

static ber_tlv_tag_t asn_DEF_URL_Link_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_URL_Link = {
	"URL-Link",
	"URL-Link",
	URL_Link_free,
	URL_Link_print,
	URL_Link_constraint,
	URL_Link_decode_ber,
	URL_Link_encode_der,
	URL_Link_decode_xer,
	URL_Link_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_URL_Link_tags_1,
	sizeof(asn_DEF_URL_Link_tags_1)
		/sizeof(asn_DEF_URL_Link_tags_1[0]), /* 1 */
	asn_DEF_URL_Link_tags_1,	/* Same as above */
	sizeof(asn_DEF_URL_Link_tags_1)
		/sizeof(asn_DEF_URL_Link_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [URL-Short] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [URL-Short] >>> ***/

typedef IA5String_t	 URL_Short_t;

/*** <<< FUNC-DECLS [URL-Short] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_URL_Short;
asn_struct_free_f URL_Short_free;
asn_struct_print_f URL_Short_print;
asn_constr_check_f URL_Short_constraint;
ber_type_decoder_f URL_Short_decode_ber;
der_type_encoder_f URL_Short_encode_der;
xer_type_decoder_f URL_Short_decode_xer;
xer_type_encoder_f URL_Short_encode_xer;

/*** <<< CTABLES [URL-Short] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [URL-Short] >>> ***/

int
URL_Short_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 15)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */
static void
URL_Short_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_IA5String.free_struct;
	td->print_struct   = asn_DEF_IA5String.print_struct;
	td->check_constraints = asn_DEF_IA5String.check_constraints;
	td->ber_decoder    = asn_DEF_IA5String.ber_decoder;
	td->der_encoder    = asn_DEF_IA5String.der_encoder;
	td->xer_decoder    = asn_DEF_IA5String.xer_decoder;
	td->xer_encoder    = asn_DEF_IA5String.xer_encoder;
	td->uper_decoder   = asn_DEF_IA5String.uper_decoder;
	td->uper_encoder   = asn_DEF_IA5String.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_IA5String.per_constraints;
	td->elements       = asn_DEF_IA5String.elements;
	td->elements_count = asn_DEF_IA5String.elements_count;
	td->specifics      = asn_DEF_IA5String.specifics;
}

void
URL_Short_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	URL_Short_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
URL_Short_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Short_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
URL_Short_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	URL_Short_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
URL_Short_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Short_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
URL_Short_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	URL_Short_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
URL_Short_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	URL_Short_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [URL-Short] >>> ***/

static ber_tlv_tag_t asn_DEF_URL_Short_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_URL_Short = {
	"URL-Short",
	"URL-Short",
	URL_Short_free,
	URL_Short_print,
	URL_Short_constraint,
	URL_Short_decode_ber,
	URL_Short_encode_der,
	URL_Short_decode_xer,
	URL_Short_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_URL_Short_tags_1,
	sizeof(asn_DEF_URL_Short_tags_1)
		/sizeof(asn_DEF_URL_Short_tags_1[0]), /* 1 */
	asn_DEF_URL_Short_tags_1,	/* Same as above */
	sizeof(asn_DEF_URL_Short_tags_1)
		/sizeof(asn_DEF_URL_Short_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VehicleHeight] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [VehicleHeight] >>> ***/

typedef long	 VehicleHeight_t;

/*** <<< FUNC-DECLS [VehicleHeight] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleHeight;
asn_struct_free_f VehicleHeight_free;
asn_struct_print_f VehicleHeight_print;
asn_constr_check_f VehicleHeight_constraint;
ber_type_decoder_f VehicleHeight_decode_ber;
der_type_encoder_f VehicleHeight_encode_der;
xer_type_decoder_f VehicleHeight_decode_xer;
xer_type_encoder_f VehicleHeight_encode_xer;

/*** <<< CODE [VehicleHeight] >>> ***/

int
VehicleHeight_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleHeight_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
VehicleHeight_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleHeight_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleHeight_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleHeight_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleHeight_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleHeight_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleHeight_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleHeight_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleHeight_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleHeight_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleHeight_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleHeight_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleHeight] >>> ***/

static ber_tlv_tag_t asn_DEF_VehicleHeight_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleHeight = {
	"VehicleHeight",
	"VehicleHeight",
	VehicleHeight_free,
	VehicleHeight_print,
	VehicleHeight_constraint,
	VehicleHeight_decode_ber,
	VehicleHeight_encode_der,
	VehicleHeight_decode_xer,
	VehicleHeight_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleHeight_tags_1,
	sizeof(asn_DEF_VehicleHeight_tags_1)
		/sizeof(asn_DEF_VehicleHeight_tags_1[0]), /* 1 */
	asn_DEF_VehicleHeight_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleHeight_tags_1)
		/sizeof(asn_DEF_VehicleHeight_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VehicleLaneAttributes] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [VehicleLaneAttributes] >>> ***/

typedef long	 VehicleLaneAttributes_t;

/*** <<< FUNC-DECLS [VehicleLaneAttributes] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleLaneAttributes;
asn_struct_free_f VehicleLaneAttributes_free;
asn_struct_print_f VehicleLaneAttributes_print;
asn_constr_check_f VehicleLaneAttributes_constraint;
ber_type_decoder_f VehicleLaneAttributes_decode_ber;
der_type_encoder_f VehicleLaneAttributes_encode_der;
xer_type_decoder_f VehicleLaneAttributes_decode_xer;
xer_type_encoder_f VehicleLaneAttributes_encode_xer;

/*** <<< CODE [VehicleLaneAttributes] >>> ***/

int
VehicleLaneAttributes_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleLaneAttributes_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
VehicleLaneAttributes_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleLaneAttributes_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleLaneAttributes_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleLaneAttributes_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleLaneAttributes_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleLaneAttributes_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleLaneAttributes_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleLaneAttributes_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleLaneAttributes] >>> ***/

static ber_tlv_tag_t asn_DEF_VehicleLaneAttributes_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleLaneAttributes = {
	"VehicleLaneAttributes",
	"VehicleLaneAttributes",
	VehicleLaneAttributes_free,
	VehicleLaneAttributes_print,
	VehicleLaneAttributes_constraint,
	VehicleLaneAttributes_decode_ber,
	VehicleLaneAttributes_encode_der,
	VehicleLaneAttributes_decode_xer,
	VehicleLaneAttributes_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleLaneAttributes_tags_1,
	sizeof(asn_DEF_VehicleLaneAttributes_tags_1)
		/sizeof(asn_DEF_VehicleLaneAttributes_tags_1[0]), /* 1 */
	asn_DEF_VehicleLaneAttributes_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleLaneAttributes_tags_1)
		/sizeof(asn_DEF_VehicleLaneAttributes_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VehicleLength] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [VehicleLength] >>> ***/

typedef long	 VehicleLength_t;

/*** <<< FUNC-DECLS [VehicleLength] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleLength;
asn_struct_free_f VehicleLength_free;
asn_struct_print_f VehicleLength_print;
asn_constr_check_f VehicleLength_constraint;
ber_type_decoder_f VehicleLength_decode_ber;
der_type_encoder_f VehicleLength_encode_der;
xer_type_decoder_f VehicleLength_decode_xer;
xer_type_encoder_f VehicleLength_encode_xer;

/*** <<< CODE [VehicleLength] >>> ***/

int
VehicleLength_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 16383)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleLength_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
VehicleLength_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleLength_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleLength_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleLength_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleLength_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleLength_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleLength_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleLength_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleLength_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleLength_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleLength_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleLength_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleLength] >>> ***/

static ber_tlv_tag_t asn_DEF_VehicleLength_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleLength = {
	"VehicleLength",
	"VehicleLength",
	VehicleLength_free,
	VehicleLength_print,
	VehicleLength_constraint,
	VehicleLength_decode_ber,
	VehicleLength_encode_der,
	VehicleLength_decode_xer,
	VehicleLength_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleLength_tags_1,
	sizeof(asn_DEF_VehicleLength_tags_1)
		/sizeof(asn_DEF_VehicleLength_tags_1[0]), /* 1 */
	asn_DEF_VehicleLength_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleLength_tags_1)
		/sizeof(asn_DEF_VehicleLength_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VehicleMass] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [VehicleMass] >>> ***/

typedef long	 VehicleMass_t;

/*** <<< FUNC-DECLS [VehicleMass] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleMass;
asn_struct_free_f VehicleMass_free;
asn_struct_print_f VehicleMass_print;
asn_constr_check_f VehicleMass_constraint;
ber_type_decoder_f VehicleMass_decode_ber;
der_type_encoder_f VehicleMass_encode_der;
xer_type_decoder_f VehicleMass_decode_xer;
xer_type_encoder_f VehicleMass_encode_xer;

/*** <<< CODE [VehicleMass] >>> ***/

int
VehicleMass_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleMass_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
VehicleMass_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleMass_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleMass_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleMass_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleMass_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleMass_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleMass_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleMass_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleMass_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleMass_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleMass_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleMass_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleMass] >>> ***/

static ber_tlv_tag_t asn_DEF_VehicleMass_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleMass = {
	"VehicleMass",
	"VehicleMass",
	VehicleMass_free,
	VehicleMass_print,
	VehicleMass_constraint,
	VehicleMass_decode_ber,
	VehicleMass_encode_der,
	VehicleMass_decode_xer,
	VehicleMass_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleMass_tags_1,
	sizeof(asn_DEF_VehicleMass_tags_1)
		/sizeof(asn_DEF_VehicleMass_tags_1[0]), /* 1 */
	asn_DEF_VehicleMass_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleMass_tags_1)
		/sizeof(asn_DEF_VehicleMass_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VehicleRequestStatus] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [VehicleRequestStatus] >>> ***/

typedef OCTET_STRING_t	 VehicleRequestStatus_t;

/*** <<< FUNC-DECLS [VehicleRequestStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleRequestStatus;
asn_struct_free_f VehicleRequestStatus_free;
asn_struct_print_f VehicleRequestStatus_print;
asn_constr_check_f VehicleRequestStatus_constraint;
ber_type_decoder_f VehicleRequestStatus_decode_ber;
der_type_encoder_f VehicleRequestStatus_encode_der;
xer_type_decoder_f VehicleRequestStatus_decode_xer;
xer_type_encoder_f VehicleRequestStatus_encode_xer;

/*** <<< CODE [VehicleRequestStatus] >>> ***/

int
VehicleRequestStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size == 1)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleRequestStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
VehicleRequestStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleRequestStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleRequestStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleRequestStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleRequestStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleRequestStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleRequestStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleRequestStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleRequestStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleRequestStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleRequestStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleRequestStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleRequestStatus] >>> ***/

static ber_tlv_tag_t asn_DEF_VehicleRequestStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleRequestStatus = {
	"VehicleRequestStatus",
	"VehicleRequestStatus",
	VehicleRequestStatus_free,
	VehicleRequestStatus_print,
	VehicleRequestStatus_constraint,
	VehicleRequestStatus_decode_ber,
	VehicleRequestStatus_encode_der,
	VehicleRequestStatus_decode_xer,
	VehicleRequestStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleRequestStatus_tags_1,
	sizeof(asn_DEF_VehicleRequestStatus_tags_1)
		/sizeof(asn_DEF_VehicleRequestStatus_tags_1[0]), /* 1 */
	asn_DEF_VehicleRequestStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleRequestStatus_tags_1)
		/sizeof(asn_DEF_VehicleRequestStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VehicleStatusDeviceTypeTag] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [VehicleStatusDeviceTypeTag] >>> ***/

typedef enum VehicleStatusDeviceTypeTag {
	VehicleStatusDeviceTypeTag_unknown	= 0,
	VehicleStatusDeviceTypeTag_lights	= 1,
	VehicleStatusDeviceTypeTag_wipers	= 2,
	VehicleStatusDeviceTypeTag_brakes	= 3,
	VehicleStatusDeviceTypeTag_stab	= 4,
	VehicleStatusDeviceTypeTag_trac	= 5,
	VehicleStatusDeviceTypeTag_abs	= 6,
	VehicleStatusDeviceTypeTag_sunS	= 7,
	VehicleStatusDeviceTypeTag_rainS	= 8,
	VehicleStatusDeviceTypeTag_airTemp	= 9,
	VehicleStatusDeviceTypeTag_steering	= 10,
	VehicleStatusDeviceTypeTag_vertAccelThres	= 11,
	VehicleStatusDeviceTypeTag_vertAccel	= 12,
	VehicleStatusDeviceTypeTag_hozAccelLong	= 13,
	VehicleStatusDeviceTypeTag_hozAccelLat	= 14,
	VehicleStatusDeviceTypeTag_hozAccelCon	= 15,
	VehicleStatusDeviceTypeTag_accel4way	= 16,
	VehicleStatusDeviceTypeTag_confidenceSet	= 17,
	VehicleStatusDeviceTypeTag_obDist	= 18,
	VehicleStatusDeviceTypeTag_obDirect	= 19,
	VehicleStatusDeviceTypeTag_yaw	= 20,
	VehicleStatusDeviceTypeTag_yawRateCon	= 21,
	VehicleStatusDeviceTypeTag_dateTime	= 22,
	VehicleStatusDeviceTypeTag_fullPos	= 23,
	VehicleStatusDeviceTypeTag_position2D	= 24,
	VehicleStatusDeviceTypeTag_position3D	= 25,
	VehicleStatusDeviceTypeTag_vehicle	= 26,
	VehicleStatusDeviceTypeTag_speedHeadC	= 27,
	VehicleStatusDeviceTypeTag_speedC	= 28
	/*
	 * Enumeration is extensible
	 */
} e_VehicleStatusDeviceTypeTag;

/*** <<< TYPE-DECLS [VehicleStatusDeviceTypeTag] >>> ***/

typedef long	 VehicleStatusDeviceTypeTag_t;

/*** <<< FUNC-DECLS [VehicleStatusDeviceTypeTag] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusDeviceTypeTag;
asn_struct_free_f VehicleStatusDeviceTypeTag_free;
asn_struct_print_f VehicleStatusDeviceTypeTag_print;
asn_constr_check_f VehicleStatusDeviceTypeTag_constraint;
ber_type_decoder_f VehicleStatusDeviceTypeTag_decode_ber;
der_type_encoder_f VehicleStatusDeviceTypeTag_encode_der;
xer_type_decoder_f VehicleStatusDeviceTypeTag_decode_xer;
xer_type_encoder_f VehicleStatusDeviceTypeTag_encode_xer;

/*** <<< CODE [VehicleStatusDeviceTypeTag] >>> ***/

int
VehicleStatusDeviceTypeTag_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
VehicleStatusDeviceTypeTag_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleStatusDeviceTypeTag_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleStatusDeviceTypeTag_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleStatusDeviceTypeTag_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleStatusDeviceTypeTag_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleStatusDeviceTypeTag_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleStatusDeviceTypeTag_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleStatusDeviceTypeTag] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_VehicleStatusDeviceTypeTag_value2enum_1[] = {
	{ 0,	7,	"unknown" },
	{ 1,	6,	"lights" },
	{ 2,	6,	"wipers" },
	{ 3,	6,	"brakes" },
	{ 4,	4,	"stab" },
	{ 5,	4,	"trac" },
	{ 6,	3,	"abs" },
	{ 7,	4,	"sunS" },
	{ 8,	5,	"rainS" },
	{ 9,	7,	"airTemp" },
	{ 10,	8,	"steering" },
	{ 11,	14,	"vertAccelThres" },
	{ 12,	9,	"vertAccel" },
	{ 13,	12,	"hozAccelLong" },
	{ 14,	11,	"hozAccelLat" },
	{ 15,	11,	"hozAccelCon" },
	{ 16,	9,	"accel4way" },
	{ 17,	13,	"confidenceSet" },
	{ 18,	6,	"obDist" },
	{ 19,	8,	"obDirect" },
	{ 20,	3,	"yaw" },
	{ 21,	10,	"yawRateCon" },
	{ 22,	8,	"dateTime" },
	{ 23,	7,	"fullPos" },
	{ 24,	10,	"position2D" },
	{ 25,	10,	"position3D" },
	{ 26,	7,	"vehicle" },
	{ 27,	10,	"speedHeadC" },
	{ 28,	6,	"speedC" }
	/* This list is extensible */
};
static unsigned int asn_MAP_VehicleStatusDeviceTypeTag_enum2value_1[] = {
	6,	/* abs(6) */
	16,	/* accel4way(16) */
	9,	/* airTemp(9) */
	3,	/* brakes(3) */
	17,	/* confidenceSet(17) */
	22,	/* dateTime(22) */
	23,	/* fullPos(23) */
	15,	/* hozAccelCon(15) */
	14,	/* hozAccelLat(14) */
	13,	/* hozAccelLong(13) */
	1,	/* lights(1) */
	19,	/* obDirect(19) */
	18,	/* obDist(18) */
	24,	/* position2D(24) */
	25,	/* position3D(25) */
	8,	/* rainS(8) */
	28,	/* speedC(28) */
	27,	/* speedHeadC(27) */
	4,	/* stab(4) */
	10,	/* steering(10) */
	7,	/* sunS(7) */
	5,	/* trac(5) */
	0,	/* unknown(0) */
	26,	/* vehicle(26) */
	12,	/* vertAccel(12) */
	11,	/* vertAccelThres(11) */
	2,	/* wipers(2) */
	20,	/* yaw(20) */
	21	/* yawRateCon(21) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_VehicleStatusDeviceTypeTag_specs_1 = {
	asn_MAP_VehicleStatusDeviceTypeTag_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_VehicleStatusDeviceTypeTag_enum2value_1,	/* N => "tag"; sorted by N */
	29,	/* Number of elements in the maps */
	30,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_VehicleStatusDeviceTypeTag_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleStatusDeviceTypeTag = {
	"VehicleStatusDeviceTypeTag",
	"VehicleStatusDeviceTypeTag",
	VehicleStatusDeviceTypeTag_free,
	VehicleStatusDeviceTypeTag_print,
	VehicleStatusDeviceTypeTag_constraint,
	VehicleStatusDeviceTypeTag_decode_ber,
	VehicleStatusDeviceTypeTag_encode_der,
	VehicleStatusDeviceTypeTag_decode_xer,
	VehicleStatusDeviceTypeTag_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleStatusDeviceTypeTag_tags_1,
	sizeof(asn_DEF_VehicleStatusDeviceTypeTag_tags_1)
		/sizeof(asn_DEF_VehicleStatusDeviceTypeTag_tags_1[0]), /* 1 */
	asn_DEF_VehicleStatusDeviceTypeTag_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleStatusDeviceTypeTag_tags_1)
		/sizeof(asn_DEF_VehicleStatusDeviceTypeTag_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_VehicleStatusDeviceTypeTag_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleType] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [VehicleType] >>> ***/

typedef enum VehicleType {
	VehicleType_none	= 0,
	VehicleType_unknown	= 1,
	VehicleType_special	= 2,
	VehicleType_moto	= 3,
	VehicleType_car	= 4,
	VehicleType_carOther	= 5,
	VehicleType_bus	= 6,
	VehicleType_axleCnt2	= 7,
	VehicleType_axleCnt3	= 8,
	VehicleType_axleCnt4	= 9,
	VehicleType_axleCnt4Trailer	= 10,
	VehicleType_axleCnt5Trailer	= 11,
	VehicleType_axleCnt6Trailer	= 12,
	VehicleType_axleCnt5MultiTrailer	= 13,
	VehicleType_axleCnt6MultiTrailer	= 14,
	VehicleType_axleCnt7MultiTrailer	= 15
	/*
	 * Enumeration is extensible
	 */
} e_VehicleType;

/*** <<< TYPE-DECLS [VehicleType] >>> ***/

typedef long	 VehicleType_t;

/*** <<< FUNC-DECLS [VehicleType] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleType;
asn_struct_free_f VehicleType_free;
asn_struct_print_f VehicleType_print;
asn_constr_check_f VehicleType_constraint;
ber_type_decoder_f VehicleType_decode_ber;
der_type_encoder_f VehicleType_encode_der;
xer_type_decoder_f VehicleType_decode_xer;
xer_type_encoder_f VehicleType_encode_xer;

/*** <<< CODE [VehicleType] >>> ***/

int
VehicleType_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleType_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
VehicleType_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleType_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleType_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleType_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleType_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleType_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleType_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleType_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleType_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleType_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleType_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleType_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleType] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_VehicleType_value2enum_1[] = {
	{ 0,	4,	"none" },
	{ 1,	7,	"unknown" },
	{ 2,	7,	"special" },
	{ 3,	4,	"moto" },
	{ 4,	3,	"car" },
	{ 5,	8,	"carOther" },
	{ 6,	3,	"bus" },
	{ 7,	8,	"axleCnt2" },
	{ 8,	8,	"axleCnt3" },
	{ 9,	8,	"axleCnt4" },
	{ 10,	15,	"axleCnt4Trailer" },
	{ 11,	15,	"axleCnt5Trailer" },
	{ 12,	15,	"axleCnt6Trailer" },
	{ 13,	20,	"axleCnt5MultiTrailer" },
	{ 14,	20,	"axleCnt6MultiTrailer" },
	{ 15,	20,	"axleCnt7MultiTrailer" }
	/* This list is extensible */
};
static unsigned int asn_MAP_VehicleType_enum2value_1[] = {
	7,	/* axleCnt2(7) */
	8,	/* axleCnt3(8) */
	9,	/* axleCnt4(9) */
	10,	/* axleCnt4Trailer(10) */
	13,	/* axleCnt5MultiTrailer(13) */
	11,	/* axleCnt5Trailer(11) */
	14,	/* axleCnt6MultiTrailer(14) */
	12,	/* axleCnt6Trailer(12) */
	15,	/* axleCnt7MultiTrailer(15) */
	6,	/* bus(6) */
	4,	/* car(4) */
	5,	/* carOther(5) */
	3,	/* moto(3) */
	0,	/* none(0) */
	2,	/* special(2) */
	1	/* unknown(1) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_VehicleType_specs_1 = {
	asn_MAP_VehicleType_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_VehicleType_enum2value_1,	/* N => "tag"; sorted by N */
	16,	/* Number of elements in the maps */
	17,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_VehicleType_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleType = {
	"VehicleType",
	"VehicleType",
	VehicleType_free,
	VehicleType_print,
	VehicleType_constraint,
	VehicleType_decode_ber,
	VehicleType_encode_der,
	VehicleType_decode_xer,
	VehicleType_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleType_tags_1,
	sizeof(asn_DEF_VehicleType_tags_1)
		/sizeof(asn_DEF_VehicleType_tags_1[0]), /* 1 */
	asn_DEF_VehicleType_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleType_tags_1)
		/sizeof(asn_DEF_VehicleType_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_VehicleType_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleWidth] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [VehicleWidth] >>> ***/

typedef long	 VehicleWidth_t;

/*** <<< FUNC-DECLS [VehicleWidth] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleWidth;
asn_struct_free_f VehicleWidth_free;
asn_struct_print_f VehicleWidth_print;
asn_constr_check_f VehicleWidth_constraint;
ber_type_decoder_f VehicleWidth_decode_ber;
der_type_encoder_f VehicleWidth_encode_der;
xer_type_decoder_f VehicleWidth_decode_xer;
xer_type_encoder_f VehicleWidth_encode_xer;

/*** <<< CODE [VehicleWidth] >>> ***/

int
VehicleWidth_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 1023)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleWidth_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
VehicleWidth_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleWidth_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleWidth_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleWidth_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleWidth_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleWidth_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleWidth_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleWidth_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleWidth_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleWidth_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleWidth_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleWidth_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleWidth] >>> ***/

static ber_tlv_tag_t asn_DEF_VehicleWidth_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleWidth = {
	"VehicleWidth",
	"VehicleWidth",
	VehicleWidth_free,
	VehicleWidth_print,
	VehicleWidth_constraint,
	VehicleWidth_decode_ber,
	VehicleWidth_encode_der,
	VehicleWidth_decode_xer,
	VehicleWidth_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleWidth_tags_1,
	sizeof(asn_DEF_VehicleWidth_tags_1)
		/sizeof(asn_DEF_VehicleWidth_tags_1[0]), /* 1 */
	asn_DEF_VehicleWidth_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleWidth_tags_1)
		/sizeof(asn_DEF_VehicleWidth_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VerticalAcceleration] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [VerticalAcceleration] >>> ***/

typedef long	 VerticalAcceleration_t;

/*** <<< FUNC-DECLS [VerticalAcceleration] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VerticalAcceleration;
asn_struct_free_f VerticalAcceleration_free;
asn_struct_print_f VerticalAcceleration_print;
asn_constr_check_f VerticalAcceleration_constraint;
ber_type_decoder_f VerticalAcceleration_decode_ber;
der_type_encoder_f VerticalAcceleration_encode_der;
xer_type_decoder_f VerticalAcceleration_decode_xer;
xer_type_encoder_f VerticalAcceleration_encode_xer;

/*** <<< CODE [VerticalAcceleration] >>> ***/

int
VerticalAcceleration_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -127 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
VerticalAcceleration_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
VerticalAcceleration_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VerticalAcceleration_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VerticalAcceleration_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VerticalAcceleration_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VerticalAcceleration_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VerticalAcceleration_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VerticalAcceleration_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VerticalAcceleration_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VerticalAcceleration_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VerticalAcceleration_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VerticalAcceleration_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VerticalAcceleration_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VerticalAcceleration] >>> ***/

static ber_tlv_tag_t asn_DEF_VerticalAcceleration_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VerticalAcceleration = {
	"VerticalAcceleration",
	"VerticalAcceleration",
	VerticalAcceleration_free,
	VerticalAcceleration_print,
	VerticalAcceleration_constraint,
	VerticalAcceleration_decode_ber,
	VerticalAcceleration_encode_der,
	VerticalAcceleration_decode_xer,
	VerticalAcceleration_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VerticalAcceleration_tags_1,
	sizeof(asn_DEF_VerticalAcceleration_tags_1)
		/sizeof(asn_DEF_VerticalAcceleration_tags_1[0]), /* 1 */
	asn_DEF_VerticalAcceleration_tags_1,	/* Same as above */
	sizeof(asn_DEF_VerticalAcceleration_tags_1)
		/sizeof(asn_DEF_VerticalAcceleration_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VerticalAccelerationThreshold] >>> ***/

#include <BIT_STRING.h>

/*** <<< DEPS [VerticalAccelerationThreshold] >>> ***/

typedef enum VerticalAccelerationThreshold {
	VerticalAccelerationThreshold_allOff	= 0,
	VerticalAccelerationThreshold_leftFront	= 1,
	VerticalAccelerationThreshold_leftRear	= 2,
	VerticalAccelerationThreshold_rightFront	= 4,
	VerticalAccelerationThreshold_rightRear	= 8
} e_VerticalAccelerationThreshold;

/*** <<< TYPE-DECLS [VerticalAccelerationThreshold] >>> ***/

typedef BIT_STRING_t	 VerticalAccelerationThreshold_t;

/*** <<< FUNC-DECLS [VerticalAccelerationThreshold] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VerticalAccelerationThreshold;
asn_struct_free_f VerticalAccelerationThreshold_free;
asn_struct_print_f VerticalAccelerationThreshold_print;
asn_constr_check_f VerticalAccelerationThreshold_constraint;
ber_type_decoder_f VerticalAccelerationThreshold_decode_ber;
der_type_encoder_f VerticalAccelerationThreshold_encode_der;
xer_type_decoder_f VerticalAccelerationThreshold_decode_xer;
xer_type_encoder_f VerticalAccelerationThreshold_encode_xer;

/*** <<< CODE [VerticalAccelerationThreshold] >>> ***/

int
VerticalAccelerationThreshold_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using BIT_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_BIT_STRING.free_struct;
	td->print_struct   = asn_DEF_BIT_STRING.print_struct;
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_BIT_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_BIT_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_BIT_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_BIT_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_BIT_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_BIT_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_BIT_STRING.per_constraints;
	td->elements       = asn_DEF_BIT_STRING.elements;
	td->elements_count = asn_DEF_BIT_STRING.elements_count;
	td->specifics      = asn_DEF_BIT_STRING.specifics;
}

void
VerticalAccelerationThreshold_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VerticalAccelerationThreshold_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VerticalAccelerationThreshold_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VerticalAccelerationThreshold_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VerticalAccelerationThreshold_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VerticalAccelerationThreshold_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VerticalAccelerationThreshold_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VerticalAccelerationThreshold] >>> ***/

static ber_tlv_tag_t asn_DEF_VerticalAccelerationThreshold_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (3 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VerticalAccelerationThreshold = {
	"VerticalAccelerationThreshold",
	"VerticalAccelerationThreshold",
	VerticalAccelerationThreshold_free,
	VerticalAccelerationThreshold_print,
	VerticalAccelerationThreshold_constraint,
	VerticalAccelerationThreshold_decode_ber,
	VerticalAccelerationThreshold_encode_der,
	VerticalAccelerationThreshold_decode_xer,
	VerticalAccelerationThreshold_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VerticalAccelerationThreshold_tags_1,
	sizeof(asn_DEF_VerticalAccelerationThreshold_tags_1)
		/sizeof(asn_DEF_VerticalAccelerationThreshold_tags_1[0]), /* 1 */
	asn_DEF_VerticalAccelerationThreshold_tags_1,	/* Same as above */
	sizeof(asn_DEF_VerticalAccelerationThreshold_tags_1)
		/sizeof(asn_DEF_VerticalAccelerationThreshold_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	0	/* No specifics */
};


/*** <<< INCLUDES [VINstring] >>> ***/

#include <OCTET_STRING.h>

/*** <<< TYPE-DECLS [VINstring] >>> ***/

typedef OCTET_STRING_t	 VINstring_t;

/*** <<< FUNC-DECLS [VINstring] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VINstring;
asn_struct_free_f VINstring_free;
asn_struct_print_f VINstring_print;
asn_constr_check_f VINstring_constraint;
ber_type_decoder_f VINstring_decode_ber;
der_type_encoder_f VINstring_encode_der;
xer_type_decoder_f VINstring_decode_xer;
xer_type_encoder_f VINstring_encode_xer;

/*** <<< CODE [VINstring] >>> ***/

int
VINstring_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 17)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using OCTET_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
VINstring_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_OCTET_STRING.free_struct;
	td->print_struct   = asn_DEF_OCTET_STRING.print_struct;
	td->check_constraints = asn_DEF_OCTET_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_OCTET_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_OCTET_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_OCTET_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_OCTET_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_OCTET_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_OCTET_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_OCTET_STRING.per_constraints;
	td->elements       = asn_DEF_OCTET_STRING.elements;
	td->elements_count = asn_DEF_OCTET_STRING.elements_count;
	td->specifics      = asn_DEF_OCTET_STRING.specifics;
}

void
VINstring_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VINstring_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VINstring_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VINstring_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VINstring_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VINstring_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VINstring_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VINstring_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VINstring_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VINstring_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VINstring_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VINstring_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VINstring] >>> ***/

static ber_tlv_tag_t asn_DEF_VINstring_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VINstring = {
	"VINstring",
	"VINstring",
	VINstring_free,
	VINstring_print,
	VINstring_constraint,
	VINstring_decode_ber,
	VINstring_encode_der,
	VINstring_decode_xer,
	VINstring_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VINstring_tags_1,
	sizeof(asn_DEF_VINstring_tags_1)
		/sizeof(asn_DEF_VINstring_tags_1[0]), /* 1 */
	asn_DEF_VINstring_tags_1,	/* Same as above */
	sizeof(asn_DEF_VINstring_tags_1)
		/sizeof(asn_DEF_VINstring_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [WheelEndElectFault] >>> ***/

#include <BIT_STRING.h>

/*** <<< DEPS [WheelEndElectFault] >>> ***/

typedef enum WheelEndElectFault {
	WheelEndElectFault_bitOne	= 1,
	WheelEndElectFault_bitTwo	= 2,
	WheelEndElectFault_bitThree	= 3,
	WheelEndElectFault_bitFour	= 4
} e_WheelEndElectFault;

/*** <<< TYPE-DECLS [WheelEndElectFault] >>> ***/

typedef BIT_STRING_t	 WheelEndElectFault_t;

/*** <<< FUNC-DECLS [WheelEndElectFault] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WheelEndElectFault;
asn_struct_free_f WheelEndElectFault_free;
asn_struct_print_f WheelEndElectFault_print;
asn_constr_check_f WheelEndElectFault_constraint;
ber_type_decoder_f WheelEndElectFault_decode_ber;
der_type_encoder_f WheelEndElectFault_encode_der;
xer_type_decoder_f WheelEndElectFault_decode_xer;
xer_type_encoder_f WheelEndElectFault_encode_xer;

/*** <<< CODE [WheelEndElectFault] >>> ***/

int
WheelEndElectFault_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using BIT_STRING,
 * so here we adjust the DEF accordingly.
 */
static void
WheelEndElectFault_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_BIT_STRING.free_struct;
	td->print_struct   = asn_DEF_BIT_STRING.print_struct;
	td->check_constraints = asn_DEF_BIT_STRING.check_constraints;
	td->ber_decoder    = asn_DEF_BIT_STRING.ber_decoder;
	td->der_encoder    = asn_DEF_BIT_STRING.der_encoder;
	td->xer_decoder    = asn_DEF_BIT_STRING.xer_decoder;
	td->xer_encoder    = asn_DEF_BIT_STRING.xer_encoder;
	td->uper_decoder   = asn_DEF_BIT_STRING.uper_decoder;
	td->uper_encoder   = asn_DEF_BIT_STRING.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_BIT_STRING.per_constraints;
	td->elements       = asn_DEF_BIT_STRING.elements;
	td->elements_count = asn_DEF_BIT_STRING.elements_count;
	td->specifics      = asn_DEF_BIT_STRING.specifics;
}

void
WheelEndElectFault_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	WheelEndElectFault_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
WheelEndElectFault_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	WheelEndElectFault_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
WheelEndElectFault_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	WheelEndElectFault_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
WheelEndElectFault_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WheelEndElectFault_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
WheelEndElectFault_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	WheelEndElectFault_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
WheelEndElectFault_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WheelEndElectFault_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [WheelEndElectFault] >>> ***/

static ber_tlv_tag_t asn_DEF_WheelEndElectFault_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (3 << 2))
};
asn_TYPE_descriptor_t asn_DEF_WheelEndElectFault = {
	"WheelEndElectFault",
	"WheelEndElectFault",
	WheelEndElectFault_free,
	WheelEndElectFault_print,
	WheelEndElectFault_constraint,
	WheelEndElectFault_decode_ber,
	WheelEndElectFault_encode_der,
	WheelEndElectFault_decode_xer,
	WheelEndElectFault_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WheelEndElectFault_tags_1,
	sizeof(asn_DEF_WheelEndElectFault_tags_1)
		/sizeof(asn_DEF_WheelEndElectFault_tags_1[0]), /* 1 */
	asn_DEF_WheelEndElectFault_tags_1,	/* Same as above */
	sizeof(asn_DEF_WheelEndElectFault_tags_1)
		/sizeof(asn_DEF_WheelEndElectFault_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	0	/* No specifics */
};


/*** <<< INCLUDES [WheelSensorStatus] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [WheelSensorStatus] >>> ***/

typedef enum WheelSensorStatus {
	WheelSensorStatus_off	= 0,
	WheelSensorStatus_on	= 1,
	WheelSensorStatus_notDefined	= 2,
	WheelSensorStatus_notSupoprted	= 3
} e_WheelSensorStatus;

/*** <<< TYPE-DECLS [WheelSensorStatus] >>> ***/

typedef long	 WheelSensorStatus_t;

/*** <<< FUNC-DECLS [WheelSensorStatus] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WheelSensorStatus;
asn_struct_free_f WheelSensorStatus_free;
asn_struct_print_f WheelSensorStatus_print;
asn_constr_check_f WheelSensorStatus_constraint;
ber_type_decoder_f WheelSensorStatus_decode_ber;
der_type_encoder_f WheelSensorStatus_encode_der;
xer_type_decoder_f WheelSensorStatus_decode_xer;
xer_type_encoder_f WheelSensorStatus_encode_xer;

/*** <<< CODE [WheelSensorStatus] >>> ***/

int
WheelSensorStatus_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
WheelSensorStatus_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
WheelSensorStatus_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	WheelSensorStatus_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
WheelSensorStatus_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	WheelSensorStatus_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
WheelSensorStatus_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	WheelSensorStatus_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
WheelSensorStatus_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WheelSensorStatus_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
WheelSensorStatus_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	WheelSensorStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
WheelSensorStatus_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WheelSensorStatus_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [WheelSensorStatus] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_WheelSensorStatus_value2enum_1[] = {
	{ 0,	3,	"off" },
	{ 1,	2,	"on" },
	{ 2,	10,	"notDefined" },
	{ 3,	12,	"notSupoprted" }
};
static unsigned int asn_MAP_WheelSensorStatus_enum2value_1[] = {
	2,	/* notDefined(2) */
	3,	/* notSupoprted(3) */
	0,	/* off(0) */
	1	/* on(1) */
};
static asn_INTEGER_specifics_t asn_SPC_WheelSensorStatus_specs_1 = {
	asn_MAP_WheelSensorStatus_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_WheelSensorStatus_enum2value_1,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_WheelSensorStatus_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_WheelSensorStatus = {
	"WheelSensorStatus",
	"WheelSensorStatus",
	WheelSensorStatus_free,
	WheelSensorStatus_print,
	WheelSensorStatus_constraint,
	WheelSensorStatus_decode_ber,
	WheelSensorStatus_encode_der,
	WheelSensorStatus_decode_xer,
	WheelSensorStatus_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WheelSensorStatus_tags_1,
	sizeof(asn_DEF_WheelSensorStatus_tags_1)
		/sizeof(asn_DEF_WheelSensorStatus_tags_1[0]), /* 1 */
	asn_DEF_WheelSensorStatus_tags_1,	/* Same as above */
	sizeof(asn_DEF_WheelSensorStatus_tags_1)
		/sizeof(asn_DEF_WheelSensorStatus_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_WheelSensorStatus_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [WiperRate] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [WiperRate] >>> ***/

typedef long	 WiperRate_t;

/*** <<< FUNC-DECLS [WiperRate] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WiperRate;
asn_struct_free_f WiperRate_free;
asn_struct_print_f WiperRate_print;
asn_constr_check_f WiperRate_constraint;
ber_type_decoder_f WiperRate_decode_ber;
der_type_encoder_f WiperRate_encode_der;
xer_type_decoder_f WiperRate_decode_xer;
xer_type_encoder_f WiperRate_encode_xer;

/*** <<< CODE [WiperRate] >>> ***/

int
WiperRate_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 127)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
WiperRate_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
WiperRate_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	WiperRate_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
WiperRate_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	WiperRate_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
WiperRate_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	WiperRate_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
WiperRate_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WiperRate_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
WiperRate_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	WiperRate_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
WiperRate_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WiperRate_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [WiperRate] >>> ***/

static ber_tlv_tag_t asn_DEF_WiperRate_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_WiperRate = {
	"WiperRate",
	"WiperRate",
	WiperRate_free,
	WiperRate_print,
	WiperRate_constraint,
	WiperRate_decode_ber,
	WiperRate_encode_der,
	WiperRate_decode_xer,
	WiperRate_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WiperRate_tags_1,
	sizeof(asn_DEF_WiperRate_tags_1)
		/sizeof(asn_DEF_WiperRate_tags_1[0]), /* 1 */
	asn_DEF_WiperRate_tags_1,	/* Same as above */
	sizeof(asn_DEF_WiperRate_tags_1)
		/sizeof(asn_DEF_WiperRate_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [WiperStatusFront] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [WiperStatusFront] >>> ***/

typedef enum WiperStatusFront {
	WiperStatusFront_unavailable	= 0,
	WiperStatusFront_off	= 1,
	WiperStatusFront_intermittent	= 2,
	WiperStatusFront_low	= 3,
	WiperStatusFront_high	= 4,
	WiperStatusFront_washerInUse	= 126,
	WiperStatusFront_automaticPresent	= 127
	/*
	 * Enumeration is extensible
	 */
} e_WiperStatusFront;

/*** <<< TYPE-DECLS [WiperStatusFront] >>> ***/

typedef long	 WiperStatusFront_t;

/*** <<< FUNC-DECLS [WiperStatusFront] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WiperStatusFront;
asn_struct_free_f WiperStatusFront_free;
asn_struct_print_f WiperStatusFront_print;
asn_constr_check_f WiperStatusFront_constraint;
ber_type_decoder_f WiperStatusFront_decode_ber;
der_type_encoder_f WiperStatusFront_encode_der;
xer_type_decoder_f WiperStatusFront_decode_xer;
xer_type_encoder_f WiperStatusFront_encode_xer;

/*** <<< CODE [WiperStatusFront] >>> ***/

int
WiperStatusFront_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
WiperStatusFront_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
WiperStatusFront_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	WiperStatusFront_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
WiperStatusFront_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	WiperStatusFront_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
WiperStatusFront_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	WiperStatusFront_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
WiperStatusFront_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WiperStatusFront_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
WiperStatusFront_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	WiperStatusFront_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
WiperStatusFront_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WiperStatusFront_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [WiperStatusFront] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_WiperStatusFront_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	12,	"intermittent" },
	{ 3,	3,	"low" },
	{ 4,	4,	"high" },
	{ 126,	11,	"washerInUse" },
	{ 127,	16,	"automaticPresent" }
	/* This list is extensible */
};
static unsigned int asn_MAP_WiperStatusFront_enum2value_1[] = {
	6,	/* automaticPresent(127) */
	4,	/* high(4) */
	2,	/* intermittent(2) */
	3,	/* low(3) */
	1,	/* off(1) */
	0,	/* unavailable(0) */
	5	/* washerInUse(126) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_WiperStatusFront_specs_1 = {
	asn_MAP_WiperStatusFront_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_WiperStatusFront_enum2value_1,	/* N => "tag"; sorted by N */
	7,	/* Number of elements in the maps */
	8,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_WiperStatusFront_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_WiperStatusFront = {
	"WiperStatusFront",
	"WiperStatusFront",
	WiperStatusFront_free,
	WiperStatusFront_print,
	WiperStatusFront_constraint,
	WiperStatusFront_decode_ber,
	WiperStatusFront_encode_der,
	WiperStatusFront_decode_xer,
	WiperStatusFront_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WiperStatusFront_tags_1,
	sizeof(asn_DEF_WiperStatusFront_tags_1)
		/sizeof(asn_DEF_WiperStatusFront_tags_1[0]), /* 1 */
	asn_DEF_WiperStatusFront_tags_1,	/* Same as above */
	sizeof(asn_DEF_WiperStatusFront_tags_1)
		/sizeof(asn_DEF_WiperStatusFront_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_WiperStatusFront_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [WiperStatusRear] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [WiperStatusRear] >>> ***/

typedef enum WiperStatusRear {
	WiperStatusRear_unavailable	= 0,
	WiperStatusRear_off	= 1,
	WiperStatusRear_intermittent	= 2,
	WiperStatusRear_low	= 3,
	WiperStatusRear_high	= 4,
	WiperStatusRear_washerInUse	= 126,
	WiperStatusRear_automaticPresent	= 127
	/*
	 * Enumeration is extensible
	 */
} e_WiperStatusRear;

/*** <<< TYPE-DECLS [WiperStatusRear] >>> ***/

typedef long	 WiperStatusRear_t;

/*** <<< FUNC-DECLS [WiperStatusRear] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_WiperStatusRear;
asn_struct_free_f WiperStatusRear_free;
asn_struct_print_f WiperStatusRear_print;
asn_constr_check_f WiperStatusRear_constraint;
ber_type_decoder_f WiperStatusRear_decode_ber;
der_type_encoder_f WiperStatusRear_encode_der;
xer_type_decoder_f WiperStatusRear_decode_xer;
xer_type_encoder_f WiperStatusRear_encode_xer;

/*** <<< CODE [WiperStatusRear] >>> ***/

int
WiperStatusRear_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
WiperStatusRear_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
WiperStatusRear_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	WiperStatusRear_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
WiperStatusRear_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	WiperStatusRear_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
WiperStatusRear_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	WiperStatusRear_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
WiperStatusRear_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WiperStatusRear_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
WiperStatusRear_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	WiperStatusRear_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
WiperStatusRear_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	WiperStatusRear_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [WiperStatusRear] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_WiperStatusRear_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	3,	"off" },
	{ 2,	12,	"intermittent" },
	{ 3,	3,	"low" },
	{ 4,	4,	"high" },
	{ 126,	11,	"washerInUse" },
	{ 127,	16,	"automaticPresent" }
	/* This list is extensible */
};
static unsigned int asn_MAP_WiperStatusRear_enum2value_1[] = {
	6,	/* automaticPresent(127) */
	4,	/* high(4) */
	2,	/* intermittent(2) */
	3,	/* low(3) */
	1,	/* off(1) */
	0,	/* unavailable(0) */
	5	/* washerInUse(126) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_WiperStatusRear_specs_1 = {
	asn_MAP_WiperStatusRear_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_WiperStatusRear_enum2value_1,	/* N => "tag"; sorted by N */
	7,	/* Number of elements in the maps */
	8,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_WiperStatusRear_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_WiperStatusRear = {
	"WiperStatusRear",
	"WiperStatusRear",
	WiperStatusRear_free,
	WiperStatusRear_print,
	WiperStatusRear_constraint,
	WiperStatusRear_decode_ber,
	WiperStatusRear_encode_der,
	WiperStatusRear_decode_xer,
	WiperStatusRear_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_WiperStatusRear_tags_1,
	sizeof(asn_DEF_WiperStatusRear_tags_1)
		/sizeof(asn_DEF_WiperStatusRear_tags_1[0]), /* 1 */
	asn_DEF_WiperStatusRear_tags_1,	/* Same as above */
	sizeof(asn_DEF_WiperStatusRear_tags_1)
		/sizeof(asn_DEF_WiperStatusRear_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_WiperStatusRear_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [YawRate] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [YawRate] >>> ***/

typedef long	 YawRate_t;

/*** <<< FUNC-DECLS [YawRate] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_YawRate;
asn_struct_free_f YawRate_free;
asn_struct_print_f YawRate_print;
asn_constr_check_f YawRate_constraint;
ber_type_decoder_f YawRate_decode_ber;
der_type_encoder_f YawRate_encode_der;
xer_type_decoder_f YawRate_decode_xer;
xer_type_encoder_f YawRate_encode_xer;

/*** <<< CODE [YawRate] >>> ***/

int
YawRate_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -32767 && value <= 32767)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
YawRate_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
YawRate_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	YawRate_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
YawRate_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	YawRate_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
YawRate_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	YawRate_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
YawRate_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	YawRate_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
YawRate_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	YawRate_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
YawRate_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	YawRate_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [YawRate] >>> ***/

static ber_tlv_tag_t asn_DEF_YawRate_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_YawRate = {
	"YawRate",
	"YawRate",
	YawRate_free,
	YawRate_print,
	YawRate_constraint,
	YawRate_decode_ber,
	YawRate_encode_der,
	YawRate_decode_xer,
	YawRate_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_YawRate_tags_1,
	sizeof(asn_DEF_YawRate_tags_1)
		/sizeof(asn_DEF_YawRate_tags_1[0]), /* 1 */
	asn_DEF_YawRate_tags_1,	/* Same as above */
	sizeof(asn_DEF_YawRate_tags_1)
		/sizeof(asn_DEF_YawRate_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [YawRateConfidence] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [YawRateConfidence] >>> ***/

typedef enum YawRateConfidence {
	YawRateConfidence_unavailable	= 0,
	YawRateConfidence_degSec_100_00	= 1,
	YawRateConfidence_degSec_010_00	= 2,
	YawRateConfidence_degSec_005_00	= 3,
	YawRateConfidence_degSec_001_00	= 4,
	YawRateConfidence_degSec_000_10	= 5,
	YawRateConfidence_degSec_000_05	= 6,
	YawRateConfidence_degSec_000_01	= 7
} e_YawRateConfidence;

/*** <<< TYPE-DECLS [YawRateConfidence] >>> ***/

typedef long	 YawRateConfidence_t;

/*** <<< FUNC-DECLS [YawRateConfidence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_YawRateConfidence;
asn_struct_free_f YawRateConfidence_free;
asn_struct_print_f YawRateConfidence_print;
asn_constr_check_f YawRateConfidence_constraint;
ber_type_decoder_f YawRateConfidence_decode_ber;
der_type_encoder_f YawRateConfidence_encode_der;
xer_type_decoder_f YawRateConfidence_decode_xer;
xer_type_encoder_f YawRateConfidence_encode_xer;

/*** <<< CODE [YawRateConfidence] >>> ***/

int
YawRateConfidence_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
YawRateConfidence_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
YawRateConfidence_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	YawRateConfidence_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
YawRateConfidence_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	YawRateConfidence_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
YawRateConfidence_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	YawRateConfidence_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
YawRateConfidence_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	YawRateConfidence_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
YawRateConfidence_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	YawRateConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
YawRateConfidence_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	YawRateConfidence_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [YawRateConfidence] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_YawRateConfidence_value2enum_1[] = {
	{ 0,	11,	"unavailable" },
	{ 1,	13,	"degSec-100-00" },
	{ 2,	13,	"degSec-010-00" },
	{ 3,	13,	"degSec-005-00" },
	{ 4,	13,	"degSec-001-00" },
	{ 5,	13,	"degSec-000-10" },
	{ 6,	13,	"degSec-000-05" },
	{ 7,	13,	"degSec-000-01" }
};
static unsigned int asn_MAP_YawRateConfidence_enum2value_1[] = {
	7,	/* degSec-000-01(7) */
	6,	/* degSec-000-05(6) */
	5,	/* degSec-000-10(5) */
	4,	/* degSec-001-00(4) */
	3,	/* degSec-005-00(3) */
	2,	/* degSec-010-00(2) */
	1,	/* degSec-100-00(1) */
	0	/* unavailable(0) */
};
static asn_INTEGER_specifics_t asn_SPC_YawRateConfidence_specs_1 = {
	asn_MAP_YawRateConfidence_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_YawRateConfidence_enum2value_1,	/* N => "tag"; sorted by N */
	8,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_YawRateConfidence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_YawRateConfidence = {
	"YawRateConfidence",
	"YawRateConfidence",
	YawRateConfidence_free,
	YawRateConfidence_print,
	YawRateConfidence_constraint,
	YawRateConfidence_decode_ber,
	YawRateConfidence_encode_der,
	YawRateConfidence_decode_xer,
	YawRateConfidence_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_YawRateConfidence_tags_1,
	sizeof(asn_DEF_YawRateConfidence_tags_1)
		/sizeof(asn_DEF_YawRateConfidence_tags_1[0]), /* 1 */
	asn_DEF_YawRateConfidence_tags_1,	/* Same as above */
	sizeof(asn_DEF_YawRateConfidence_tags_1)
		/sizeof(asn_DEF_YawRateConfidence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_YawRateConfidence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [EssMobileFriction] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [EssMobileFriction] >>> ***/

typedef long	 EssMobileFriction_t;

/*** <<< FUNC-DECLS [EssMobileFriction] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EssMobileFriction;
asn_struct_free_f EssMobileFriction_free;
asn_struct_print_f EssMobileFriction_print;
asn_constr_check_f EssMobileFriction_constraint;
ber_type_decoder_f EssMobileFriction_decode_ber;
der_type_encoder_f EssMobileFriction_encode_der;
xer_type_decoder_f EssMobileFriction_decode_xer;
xer_type_encoder_f EssMobileFriction_encode_xer;

/*** <<< CODE [EssMobileFriction] >>> ***/

int
EssMobileFriction_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 101)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
EssMobileFriction_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
EssMobileFriction_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EssMobileFriction_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EssMobileFriction_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EssMobileFriction_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EssMobileFriction_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EssMobileFriction_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EssMobileFriction_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssMobileFriction_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EssMobileFriction_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EssMobileFriction_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EssMobileFriction_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssMobileFriction_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EssMobileFriction] >>> ***/

static ber_tlv_tag_t asn_DEF_EssMobileFriction_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EssMobileFriction = {
	"EssMobileFriction",
	"EssMobileFriction",
	EssMobileFriction_free,
	EssMobileFriction_print,
	EssMobileFriction_constraint,
	EssMobileFriction_decode_ber,
	EssMobileFriction_encode_der,
	EssMobileFriction_decode_xer,
	EssMobileFriction_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EssMobileFriction_tags_1,
	sizeof(asn_DEF_EssMobileFriction_tags_1)
		/sizeof(asn_DEF_EssMobileFriction_tags_1[0]), /* 1 */
	asn_DEF_EssMobileFriction_tags_1,	/* Same as above */
	sizeof(asn_DEF_EssMobileFriction_tags_1)
		/sizeof(asn_DEF_EssMobileFriction_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [EssPrecipRate] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [EssPrecipRate] >>> ***/

typedef long	 EssPrecipRate_t;

/*** <<< FUNC-DECLS [EssPrecipRate] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EssPrecipRate;
asn_struct_free_f EssPrecipRate_free;
asn_struct_print_f EssPrecipRate_print;
asn_constr_check_f EssPrecipRate_constraint;
ber_type_decoder_f EssPrecipRate_decode_ber;
der_type_encoder_f EssPrecipRate_encode_der;
xer_type_decoder_f EssPrecipRate_decode_xer;
xer_type_encoder_f EssPrecipRate_encode_xer;

/*** <<< CODE [EssPrecipRate] >>> ***/

int
EssPrecipRate_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
EssPrecipRate_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
EssPrecipRate_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EssPrecipRate_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EssPrecipRate_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipRate_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EssPrecipRate_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EssPrecipRate_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EssPrecipRate_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipRate_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EssPrecipRate_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EssPrecipRate_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EssPrecipRate_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipRate_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EssPrecipRate] >>> ***/

static ber_tlv_tag_t asn_DEF_EssPrecipRate_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EssPrecipRate = {
	"EssPrecipRate",
	"EssPrecipRate",
	EssPrecipRate_free,
	EssPrecipRate_print,
	EssPrecipRate_constraint,
	EssPrecipRate_decode_ber,
	EssPrecipRate_encode_der,
	EssPrecipRate_decode_xer,
	EssPrecipRate_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EssPrecipRate_tags_1,
	sizeof(asn_DEF_EssPrecipRate_tags_1)
		/sizeof(asn_DEF_EssPrecipRate_tags_1[0]), /* 1 */
	asn_DEF_EssPrecipRate_tags_1,	/* Same as above */
	sizeof(asn_DEF_EssPrecipRate_tags_1)
		/sizeof(asn_DEF_EssPrecipRate_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [EssPrecipSituation] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [EssPrecipSituation] >>> ***/

typedef enum EssPrecipSituation {
	EssPrecipSituation_other	= 1,
	EssPrecipSituation_unknown	= 2,
	EssPrecipSituation_noPrecipitation	= 3,
	EssPrecipSituation_unidentifiedSlight	= 4,
	EssPrecipSituation_unidentifiedModerate	= 5,
	EssPrecipSituation_unidentifiedHeavy	= 6,
	EssPrecipSituation_snowSlight	= 7,
	EssPrecipSituation_snowModerate	= 8,
	EssPrecipSituation_snowHeavy	= 9,
	EssPrecipSituation_rainSlight	= 10,
	EssPrecipSituation_rainModerate	= 11,
	EssPrecipSituation_rainHeavy	= 12,
	EssPrecipSituation_frozenPrecipitationSlight	= 13,
	EssPrecipSituation_frozenPrecipitationModerate	= 14,
	EssPrecipSituation_frozenPrecipitationHeavy	= 15
} e_EssPrecipSituation;

/*** <<< TYPE-DECLS [EssPrecipSituation] >>> ***/

typedef long	 EssPrecipSituation_t;

/*** <<< FUNC-DECLS [EssPrecipSituation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EssPrecipSituation;
asn_struct_free_f EssPrecipSituation_free;
asn_struct_print_f EssPrecipSituation_print;
asn_constr_check_f EssPrecipSituation_constraint;
ber_type_decoder_f EssPrecipSituation_decode_ber;
der_type_encoder_f EssPrecipSituation_encode_der;
xer_type_decoder_f EssPrecipSituation_decode_xer;
xer_type_encoder_f EssPrecipSituation_encode_xer;

/*** <<< CODE [EssPrecipSituation] >>> ***/

int
EssPrecipSituation_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
EssPrecipSituation_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
EssPrecipSituation_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EssPrecipSituation_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EssPrecipSituation_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipSituation_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EssPrecipSituation_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EssPrecipSituation_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EssPrecipSituation_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipSituation_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EssPrecipSituation_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EssPrecipSituation_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EssPrecipSituation_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipSituation_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EssPrecipSituation] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_EssPrecipSituation_value2enum_1[] = {
	{ 1,	5,	"other" },
	{ 2,	7,	"unknown" },
	{ 3,	15,	"noPrecipitation" },
	{ 4,	18,	"unidentifiedSlight" },
	{ 5,	20,	"unidentifiedModerate" },
	{ 6,	17,	"unidentifiedHeavy" },
	{ 7,	10,	"snowSlight" },
	{ 8,	12,	"snowModerate" },
	{ 9,	9,	"snowHeavy" },
	{ 10,	10,	"rainSlight" },
	{ 11,	12,	"rainModerate" },
	{ 12,	9,	"rainHeavy" },
	{ 13,	25,	"frozenPrecipitationSlight" },
	{ 14,	27,	"frozenPrecipitationModerate" },
	{ 15,	24,	"frozenPrecipitationHeavy" }
};
static unsigned int asn_MAP_EssPrecipSituation_enum2value_1[] = {
	14,	/* frozenPrecipitationHeavy(15) */
	13,	/* frozenPrecipitationModerate(14) */
	12,	/* frozenPrecipitationSlight(13) */
	2,	/* noPrecipitation(3) */
	0,	/* other(1) */
	11,	/* rainHeavy(12) */
	10,	/* rainModerate(11) */
	9,	/* rainSlight(10) */
	8,	/* snowHeavy(9) */
	7,	/* snowModerate(8) */
	6,	/* snowSlight(7) */
	5,	/* unidentifiedHeavy(6) */
	4,	/* unidentifiedModerate(5) */
	3,	/* unidentifiedSlight(4) */
	1	/* unknown(2) */
};
static asn_INTEGER_specifics_t asn_SPC_EssPrecipSituation_specs_1 = {
	asn_MAP_EssPrecipSituation_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_EssPrecipSituation_enum2value_1,	/* N => "tag"; sorted by N */
	15,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_EssPrecipSituation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EssPrecipSituation = {
	"EssPrecipSituation",
	"EssPrecipSituation",
	EssPrecipSituation_free,
	EssPrecipSituation_print,
	EssPrecipSituation_constraint,
	EssPrecipSituation_decode_ber,
	EssPrecipSituation_encode_der,
	EssPrecipSituation_decode_xer,
	EssPrecipSituation_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EssPrecipSituation_tags_1,
	sizeof(asn_DEF_EssPrecipSituation_tags_1)
		/sizeof(asn_DEF_EssPrecipSituation_tags_1[0]), /* 1 */
	asn_DEF_EssPrecipSituation_tags_1,	/* Same as above */
	sizeof(asn_DEF_EssPrecipSituation_tags_1)
		/sizeof(asn_DEF_EssPrecipSituation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_EssPrecipSituation_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [EssPrecipYesNo] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [EssPrecipYesNo] >>> ***/

typedef enum EssPrecipYesNo {
	EssPrecipYesNo_precip	= 1,
	EssPrecipYesNo_noPrecip	= 2,
	EssPrecipYesNo_error	= 3
} e_EssPrecipYesNo;

/*** <<< TYPE-DECLS [EssPrecipYesNo] >>> ***/

typedef long	 EssPrecipYesNo_t;

/*** <<< FUNC-DECLS [EssPrecipYesNo] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EssPrecipYesNo;
asn_struct_free_f EssPrecipYesNo_free;
asn_struct_print_f EssPrecipYesNo_print;
asn_constr_check_f EssPrecipYesNo_constraint;
ber_type_decoder_f EssPrecipYesNo_decode_ber;
der_type_encoder_f EssPrecipYesNo_encode_der;
xer_type_decoder_f EssPrecipYesNo_decode_xer;
xer_type_encoder_f EssPrecipYesNo_encode_xer;

/*** <<< CODE [EssPrecipYesNo] >>> ***/

int
EssPrecipYesNo_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
EssPrecipYesNo_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
EssPrecipYesNo_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EssPrecipYesNo_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EssPrecipYesNo_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipYesNo_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EssPrecipYesNo_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EssPrecipYesNo_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EssPrecipYesNo_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipYesNo_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EssPrecipYesNo_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EssPrecipYesNo_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EssPrecipYesNo_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssPrecipYesNo_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EssPrecipYesNo] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_EssPrecipYesNo_value2enum_1[] = {
	{ 1,	6,	"precip" },
	{ 2,	8,	"noPrecip" },
	{ 3,	5,	"error" }
};
static unsigned int asn_MAP_EssPrecipYesNo_enum2value_1[] = {
	2,	/* error(3) */
	1,	/* noPrecip(2) */
	0	/* precip(1) */
};
static asn_INTEGER_specifics_t asn_SPC_EssPrecipYesNo_specs_1 = {
	asn_MAP_EssPrecipYesNo_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_EssPrecipYesNo_enum2value_1,	/* N => "tag"; sorted by N */
	3,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_EssPrecipYesNo_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EssPrecipYesNo = {
	"EssPrecipYesNo",
	"EssPrecipYesNo",
	EssPrecipYesNo_free,
	EssPrecipYesNo_print,
	EssPrecipYesNo_constraint,
	EssPrecipYesNo_decode_ber,
	EssPrecipYesNo_encode_der,
	EssPrecipYesNo_decode_xer,
	EssPrecipYesNo_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EssPrecipYesNo_tags_1,
	sizeof(asn_DEF_EssPrecipYesNo_tags_1)
		/sizeof(asn_DEF_EssPrecipYesNo_tags_1[0]), /* 1 */
	asn_DEF_EssPrecipYesNo_tags_1,	/* Same as above */
	sizeof(asn_DEF_EssPrecipYesNo_tags_1)
		/sizeof(asn_DEF_EssPrecipYesNo_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_EssPrecipYesNo_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [EssSolarRadiation] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [EssSolarRadiation] >>> ***/

typedef long	 EssSolarRadiation_t;

/*** <<< FUNC-DECLS [EssSolarRadiation] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_EssSolarRadiation;
asn_struct_free_f EssSolarRadiation_free;
asn_struct_print_f EssSolarRadiation_print;
asn_constr_check_f EssSolarRadiation_constraint;
ber_type_decoder_f EssSolarRadiation_decode_ber;
der_type_encoder_f EssSolarRadiation_encode_der;
xer_type_decoder_f EssSolarRadiation_decode_xer;
xer_type_encoder_f EssSolarRadiation_encode_xer;

/*** <<< CODE [EssSolarRadiation] >>> ***/

int
EssSolarRadiation_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
EssSolarRadiation_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
EssSolarRadiation_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	EssSolarRadiation_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
EssSolarRadiation_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	EssSolarRadiation_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
EssSolarRadiation_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	EssSolarRadiation_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
EssSolarRadiation_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssSolarRadiation_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
EssSolarRadiation_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	EssSolarRadiation_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
EssSolarRadiation_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	EssSolarRadiation_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [EssSolarRadiation] >>> ***/

static ber_tlv_tag_t asn_DEF_EssSolarRadiation_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_EssSolarRadiation = {
	"EssSolarRadiation",
	"EssSolarRadiation",
	EssSolarRadiation_free,
	EssSolarRadiation_print,
	EssSolarRadiation_constraint,
	EssSolarRadiation_decode_ber,
	EssSolarRadiation_encode_der,
	EssSolarRadiation_decode_xer,
	EssSolarRadiation_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_EssSolarRadiation_tags_1,
	sizeof(asn_DEF_EssSolarRadiation_tags_1)
		/sizeof(asn_DEF_EssSolarRadiation_tags_1[0]), /* 1 */
	asn_DEF_EssSolarRadiation_tags_1,	/* Same as above */
	sizeof(asn_DEF_EssSolarRadiation_tags_1)
		/sizeof(asn_DEF_EssSolarRadiation_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [IncidentResponseEquipment] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [IncidentResponseEquipment] >>> ***/

typedef enum IncidentResponseEquipment {
	IncidentResponseEquipment_ground_fire_suppression	= 9985,
	IncidentResponseEquipment_heavy_ground_equipment	= 9986,
	IncidentResponseEquipment_aircraft	= 9988,
	IncidentResponseEquipment_marine_equipment	= 9989,
	IncidentResponseEquipment_support_equipment	= 9990,
	IncidentResponseEquipment_medical_rescue_unit	= 9991,
	IncidentResponseEquipment_other	= 9993,
	IncidentResponseEquipment_ground_fire_suppression_other	= 9994,
	IncidentResponseEquipment_engine	= 9995,
	IncidentResponseEquipment_truck_or_aerial	= 9996,
	IncidentResponseEquipment_quint	= 9997,
	IncidentResponseEquipment_tanker_pumper_combination	= 9998,
	IncidentResponseEquipment_brush_truck	= 10000,
	IncidentResponseEquipment_aircraft_rescue_firefighting	= 10001,
	IncidentResponseEquipment_heavy_ground_equipment_other	= 10004,
	IncidentResponseEquipment_dozer_or_plow	= 10005,
	IncidentResponseEquipment_tractor	= 10006,
	IncidentResponseEquipment_tanker_or_tender	= 10008,
	IncidentResponseEquipment_aircraft_other	= 10024,
	IncidentResponseEquipment_aircraft_fixed_wing_tanker	= 10025,
	IncidentResponseEquipment_helitanker	= 10026,
	IncidentResponseEquipment_helicopter	= 10027,
	IncidentResponseEquipment_marine_equipment_other	= 10034,
	IncidentResponseEquipment_fire_boat_with_pump	= 10035,
	IncidentResponseEquipment_boat_no_pump	= 10036,
	IncidentResponseEquipment_support_apparatus_other	= 10044,
	IncidentResponseEquipment_breathing_apparatus_support	= 10045,
	IncidentResponseEquipment_light_and_air_unit	= 10046,
	IncidentResponseEquipment_medical_rescue_unit_other	= 10054,
	IncidentResponseEquipment_rescue_unit	= 10055,
	IncidentResponseEquipment_urban_search_rescue_unit	= 10056,
	IncidentResponseEquipment_high_angle_rescue	= 10057,
	IncidentResponseEquipment_crash_fire_rescue	= 10058,
	IncidentResponseEquipment_bLS_unit	= 10059,
	IncidentResponseEquipment_aLS_unit	= 10060,
	IncidentResponseEquipment_mobile_command_post	= 10075,
	IncidentResponseEquipment_chief_officer_car	= 10076,
	IncidentResponseEquipment_hAZMAT_unit	= 10077,
	IncidentResponseEquipment_type_i_hand_crew	= 10078,
	IncidentResponseEquipment_type_ii_hand_crew	= 10079,
	IncidentResponseEquipment_privately_owned_vehicle	= 10083,
	IncidentResponseEquipment_other_apparatus_resource	= 10084,
	IncidentResponseEquipment_ambulance	= 10085,
	IncidentResponseEquipment_bomb_squad_van	= 10086,
	IncidentResponseEquipment_combine_harvester	= 10087,
	IncidentResponseEquipment_construction_vehicle	= 10088,
	IncidentResponseEquipment_farm_tractor	= 10089,
	IncidentResponseEquipment_grass_cutting_machines	= 10090,
	IncidentResponseEquipment_hAZMAT_containment_tow	= 10091,
	IncidentResponseEquipment_heavy_tow	= 10092,
	IncidentResponseEquipment_light_tow	= 10094,
	IncidentResponseEquipment_flatbed_tow	= 10114,
	IncidentResponseEquipment_hedge_cutting_machines	= 10093,
	IncidentResponseEquipment_mobile_crane	= 10095,
	IncidentResponseEquipment_refuse_collection_vehicle	= 10096,
	IncidentResponseEquipment_resurfacing_vehicle	= 10097,
	IncidentResponseEquipment_road_sweeper	= 10098,
	IncidentResponseEquipment_roadside_litter_collection_crews	= 10099,
	IncidentResponseEquipment_salvage_vehicle	= 10100,
	IncidentResponseEquipment_sand_truck	= 10101,
	IncidentResponseEquipment_snowplow	= 10102,
	IncidentResponseEquipment_steam_roller	= 10103,
	IncidentResponseEquipment_swat_team_van	= 10104,
	IncidentResponseEquipment_track_laying_vehicle	= 10105,
	IncidentResponseEquipment_unknown_vehicle	= 10106,
	IncidentResponseEquipment_white_lining_vehicle	= 10107,
	IncidentResponseEquipment_dump_truck	= 10108,
	IncidentResponseEquipment_supervisor_vehicle	= 10109,
	IncidentResponseEquipment_snow_blower	= 10110,
	IncidentResponseEquipment_rotary_snow_blower	= 10111,
	IncidentResponseEquipment_road_grader	= 10112,
	IncidentResponseEquipment_steam_truck	= 10113
	/*
	 * Enumeration is extensible
	 */
} e_IncidentResponseEquipment;

/*** <<< TYPE-DECLS [IncidentResponseEquipment] >>> ***/

typedef long	 IncidentResponseEquipment_t;

/*** <<< FUNC-DECLS [IncidentResponseEquipment] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_IncidentResponseEquipment;
asn_struct_free_f IncidentResponseEquipment_free;
asn_struct_print_f IncidentResponseEquipment_print;
asn_constr_check_f IncidentResponseEquipment_constraint;
ber_type_decoder_f IncidentResponseEquipment_decode_ber;
der_type_encoder_f IncidentResponseEquipment_encode_der;
xer_type_decoder_f IncidentResponseEquipment_decode_xer;
xer_type_encoder_f IncidentResponseEquipment_encode_xer;

/*** <<< CODE [IncidentResponseEquipment] >>> ***/

int
IncidentResponseEquipment_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
IncidentResponseEquipment_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
IncidentResponseEquipment_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	IncidentResponseEquipment_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
IncidentResponseEquipment_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	IncidentResponseEquipment_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
IncidentResponseEquipment_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	IncidentResponseEquipment_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
IncidentResponseEquipment_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	IncidentResponseEquipment_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
IncidentResponseEquipment_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	IncidentResponseEquipment_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
IncidentResponseEquipment_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	IncidentResponseEquipment_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [IncidentResponseEquipment] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_IncidentResponseEquipment_value2enum_1[] = {
	{ 9985,	23,	"ground-fire-suppression" },
	{ 9986,	22,	"heavy-ground-equipment" },
	{ 9988,	8,	"aircraft" },
	{ 9989,	16,	"marine-equipment" },
	{ 9990,	17,	"support-equipment" },
	{ 9991,	19,	"medical-rescue-unit" },
	{ 9993,	5,	"other" },
	{ 9994,	29,	"ground-fire-suppression-other" },
	{ 9995,	6,	"engine" },
	{ 9996,	15,	"truck-or-aerial" },
	{ 9997,	5,	"quint" },
	{ 9998,	25,	"tanker-pumper-combination" },
	{ 10000,	11,	"brush-truck" },
	{ 10001,	28,	"aircraft-rescue-firefighting" },
	{ 10004,	28,	"heavy-ground-equipment-other" },
	{ 10005,	13,	"dozer-or-plow" },
	{ 10006,	7,	"tractor" },
	{ 10008,	16,	"tanker-or-tender" },
	{ 10024,	14,	"aircraft-other" },
	{ 10025,	26,	"aircraft-fixed-wing-tanker" },
	{ 10026,	10,	"helitanker" },
	{ 10027,	10,	"helicopter" },
	{ 10034,	22,	"marine-equipment-other" },
	{ 10035,	19,	"fire-boat-with-pump" },
	{ 10036,	12,	"boat-no-pump" },
	{ 10044,	23,	"support-apparatus-other" },
	{ 10045,	27,	"breathing-apparatus-support" },
	{ 10046,	18,	"light-and-air-unit" },
	{ 10054,	25,	"medical-rescue-unit-other" },
	{ 10055,	11,	"rescue-unit" },
	{ 10056,	24,	"urban-search-rescue-unit" },
	{ 10057,	17,	"high-angle-rescue" },
	{ 10058,	17,	"crash-fire-rescue" },
	{ 10059,	8,	"bLS-unit" },
	{ 10060,	8,	"aLS-unit" },
	{ 10075,	19,	"mobile-command-post" },
	{ 10076,	17,	"chief-officer-car" },
	{ 10077,	11,	"hAZMAT-unit" },
	{ 10078,	16,	"type-i-hand-crew" },
	{ 10079,	17,	"type-ii-hand-crew" },
	{ 10083,	23,	"privately-owned-vehicle" },
	{ 10084,	24,	"other-apparatus-resource" },
	{ 10085,	9,	"ambulance" },
	{ 10086,	14,	"bomb-squad-van" },
	{ 10087,	17,	"combine-harvester" },
	{ 10088,	20,	"construction-vehicle" },
	{ 10089,	12,	"farm-tractor" },
	{ 10090,	22,	"grass-cutting-machines" },
	{ 10091,	22,	"hAZMAT-containment-tow" },
	{ 10092,	9,	"heavy-tow" },
	{ 10093,	22,	"hedge-cutting-machines" },
	{ 10094,	9,	"light-tow" },
	{ 10095,	12,	"mobile-crane" },
	{ 10096,	25,	"refuse-collection-vehicle" },
	{ 10097,	19,	"resurfacing-vehicle" },
	{ 10098,	12,	"road-sweeper" },
	{ 10099,	32,	"roadside-litter-collection-crews" },
	{ 10100,	15,	"salvage-vehicle" },
	{ 10101,	10,	"sand-truck" },
	{ 10102,	8,	"snowplow" },
	{ 10103,	12,	"steam-roller" },
	{ 10104,	13,	"swat-team-van" },
	{ 10105,	20,	"track-laying-vehicle" },
	{ 10106,	15,	"unknown-vehicle" },
	{ 10107,	20,	"white-lining-vehicle" },
	{ 10108,	10,	"dump-truck" },
	{ 10109,	18,	"supervisor-vehicle" },
	{ 10110,	11,	"snow-blower" },
	{ 10111,	18,	"rotary-snow-blower" },
	{ 10112,	11,	"road-grader" },
	{ 10113,	11,	"steam-truck" },
	{ 10114,	11,	"flatbed-tow" }
	/* This list is extensible */
};
static unsigned int asn_MAP_IncidentResponseEquipment_enum2value_1[] = {
	34,	/* aLS-unit(10060) */
	2,	/* aircraft(9988) */
	19,	/* aircraft-fixed-wing-tanker(10025) */
	18,	/* aircraft-other(10024) */
	13,	/* aircraft-rescue-firefighting(10001) */
	42,	/* ambulance(10085) */
	33,	/* bLS-unit(10059) */
	24,	/* boat-no-pump(10036) */
	43,	/* bomb-squad-van(10086) */
	26,	/* breathing-apparatus-support(10045) */
	12,	/* brush-truck(10000) */
	36,	/* chief-officer-car(10076) */
	44,	/* combine-harvester(10087) */
	45,	/* construction-vehicle(10088) */
	32,	/* crash-fire-rescue(10058) */
	15,	/* dozer-or-plow(10005) */
	65,	/* dump-truck(10108) */
	8,	/* engine(9995) */
	46,	/* farm-tractor(10089) */
	23,	/* fire-boat-with-pump(10035) */
	71,	/* flatbed-tow(10114) */
	47,	/* grass-cutting-machines(10090) */
	0,	/* ground-fire-suppression(9985) */
	7,	/* ground-fire-suppression-other(9994) */
	48,	/* hAZMAT-containment-tow(10091) */
	37,	/* hAZMAT-unit(10077) */
	1,	/* heavy-ground-equipment(9986) */
	14,	/* heavy-ground-equipment-other(10004) */
	49,	/* heavy-tow(10092) */
	50,	/* hedge-cutting-machines(10093) */
	21,	/* helicopter(10027) */
	20,	/* helitanker(10026) */
	31,	/* high-angle-rescue(10057) */
	27,	/* light-and-air-unit(10046) */
	51,	/* light-tow(10094) */
	3,	/* marine-equipment(9989) */
	22,	/* marine-equipment-other(10034) */
	5,	/* medical-rescue-unit(9991) */
	28,	/* medical-rescue-unit-other(10054) */
	35,	/* mobile-command-post(10075) */
	52,	/* mobile-crane(10095) */
	6,	/* other(9993) */
	41,	/* other-apparatus-resource(10084) */
	40,	/* privately-owned-vehicle(10083) */
	10,	/* quint(9997) */
	53,	/* refuse-collection-vehicle(10096) */
	29,	/* rescue-unit(10055) */
	54,	/* resurfacing-vehicle(10097) */
	69,	/* road-grader(10112) */
	55,	/* road-sweeper(10098) */
	56,	/* roadside-litter-collection-crews(10099) */
	68,	/* rotary-snow-blower(10111) */
	57,	/* salvage-vehicle(10100) */
	58,	/* sand-truck(10101) */
	67,	/* snow-blower(10110) */
	59,	/* snowplow(10102) */
	60,	/* steam-roller(10103) */
	70,	/* steam-truck(10113) */
	66,	/* supervisor-vehicle(10109) */
	25,	/* support-apparatus-other(10044) */
	4,	/* support-equipment(9990) */
	61,	/* swat-team-van(10104) */
	17,	/* tanker-or-tender(10008) */
	11,	/* tanker-pumper-combination(9998) */
	62,	/* track-laying-vehicle(10105) */
	16,	/* tractor(10006) */
	9,	/* truck-or-aerial(9996) */
	38,	/* type-i-hand-crew(10078) */
	39,	/* type-ii-hand-crew(10079) */
	63,	/* unknown-vehicle(10106) */
	30,	/* urban-search-rescue-unit(10056) */
	64	/* white-lining-vehicle(10107) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_IncidentResponseEquipment_specs_1 = {
	asn_MAP_IncidentResponseEquipment_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_IncidentResponseEquipment_enum2value_1,	/* N => "tag"; sorted by N */
	72,	/* Number of elements in the maps */
	73,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_IncidentResponseEquipment_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_IncidentResponseEquipment = {
	"IncidentResponseEquipment",
	"IncidentResponseEquipment",
	IncidentResponseEquipment_free,
	IncidentResponseEquipment_print,
	IncidentResponseEquipment_constraint,
	IncidentResponseEquipment_decode_ber,
	IncidentResponseEquipment_encode_der,
	IncidentResponseEquipment_decode_xer,
	IncidentResponseEquipment_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_IncidentResponseEquipment_tags_1,
	sizeof(asn_DEF_IncidentResponseEquipment_tags_1)
		/sizeof(asn_DEF_IncidentResponseEquipment_tags_1[0]), /* 1 */
	asn_DEF_IncidentResponseEquipment_tags_1,	/* Same as above */
	sizeof(asn_DEF_IncidentResponseEquipment_tags_1)
		/sizeof(asn_DEF_IncidentResponseEquipment_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_IncidentResponseEquipment_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ITIScodes] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ITIScodes] >>> ***/

typedef long	 ITIScodes_t;

/*** <<< FUNC-DECLS [ITIScodes] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ITIScodes;
asn_struct_free_f ITIScodes_free;
asn_struct_print_f ITIScodes_print;
asn_constr_check_f ITIScodes_constraint;
ber_type_decoder_f ITIScodes_decode_ber;
der_type_encoder_f ITIScodes_encode_der;
xer_type_decoder_f ITIScodes_decode_xer;
xer_type_encoder_f ITIScodes_encode_xer;

/*** <<< CODE [ITIScodes] >>> ***/

int
ITIScodes_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65565)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */
static void
ITIScodes_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeInteger.free_struct;
	td->print_struct   = asn_DEF_NativeInteger.print_struct;
	td->check_constraints = asn_DEF_NativeInteger.check_constraints;
	td->ber_decoder    = asn_DEF_NativeInteger.ber_decoder;
	td->der_encoder    = asn_DEF_NativeInteger.der_encoder;
	td->xer_decoder    = asn_DEF_NativeInteger.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeInteger.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeInteger.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeInteger.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeInteger.per_constraints;
	td->elements       = asn_DEF_NativeInteger.elements;
	td->elements_count = asn_DEF_NativeInteger.elements_count;
	td->specifics      = asn_DEF_NativeInteger.specifics;
}

void
ITIScodes_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ITIScodes_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ITIScodes_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ITIScodes_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ITIScodes_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ITIScodes_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ITIScodes_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ITIScodes_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ITIScodes_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ITIScodes_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ITIScodes_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ITIScodes_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ITIScodes] >>> ***/

static ber_tlv_tag_t asn_DEF_ITIScodes_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ITIScodes = {
	"ITIScodes",
	"ITIScodes",
	ITIScodes_free,
	ITIScodes_print,
	ITIScodes_constraint,
	ITIScodes_decode_ber,
	ITIScodes_encode_der,
	ITIScodes_decode_xer,
	ITIScodes_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ITIScodes_tags_1,
	sizeof(asn_DEF_ITIScodes_tags_1)
		/sizeof(asn_DEF_ITIScodes_tags_1[0]), /* 1 */
	asn_DEF_ITIScodes_tags_1,	/* Same as above */
	sizeof(asn_DEF_ITIScodes_tags_1)
		/sizeof(asn_DEF_ITIScodes_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ITIScodesAndText] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include "ITIScodes.h"
#include "ITIStext.h"
#include <constr_CHOICE.h>
#include <constr_SEQUENCE.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< DEPS [ITIScodesAndText] >>> ***/

typedef enum item_PR {
	item_PR_NOTHING,	/* No components present */
	item_PR_itis,
	item_PR_text
} item_PR;

/*** <<< TYPE-DECLS [ITIScodesAndText] >>> ***/

typedef struct ITIScodesAndText {
	A_SEQUENCE_OF(struct Member {
		struct item {
			item_PR present;
			union item_u {
				ITIScodes_t	 itis;
				ITIStext_t	 text;
			} choice;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} item;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ITIScodesAndText_t;

/*** <<< FUNC-DECLS [ITIScodesAndText] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ITIScodesAndText;

/*** <<< STAT-DEFS [ITIScodesAndText] >>> ***/

static asn_TYPE_member_t asn_MBR_item_3[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.itis),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIScodes,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "itis"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct item, choice.text),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ITIStext,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "text"
		},
};
static asn_TYPE_tag2member_t asn_MAP_item_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* itis */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* text */
};
static asn_CHOICE_specifics_t asn_SPC_item_specs_3 = {
	sizeof(struct item),
	offsetof(struct item, _asn_ctx),
	offsetof(struct item, present),
	sizeof(((struct item *)0)->present),
	asn_MAP_item_tag2el_3,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_item_3 = {
	"item",
	"item",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_item_3,
	2,	/* Elements count */
	&asn_SPC_item_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, item),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_item_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "item"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* item */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_2 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_2,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_2,
	1,	/* Elements count */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_ITIScodesAndText_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_ITIScodesAndText_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_ITIScodesAndText_specs_1 = {
	sizeof(struct ITIScodesAndText),
	offsetof(struct ITIScodesAndText, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_ITIScodesAndText = {
	"ITIScodesAndText",
	"ITIScodesAndText",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ITIScodesAndText_tags_1,
	sizeof(asn_DEF_ITIScodesAndText_tags_1)
		/sizeof(asn_DEF_ITIScodesAndText_tags_1[0]), /* 1 */
	asn_DEF_ITIScodesAndText_tags_1,	/* Same as above */
	sizeof(asn_DEF_ITIScodesAndText_tags_1)
		/sizeof(asn_DEF_ITIScodesAndText_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ITIScodesAndText_1,
	1,	/* Single element */
	&asn_SPC_ITIScodesAndText_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ITIStext] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [ITIStext] >>> ***/

typedef IA5String_t	 ITIStext_t;

/*** <<< FUNC-DECLS [ITIStext] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ITIStext;
asn_struct_free_f ITIStext_free;
asn_struct_print_f ITIStext_print;
asn_constr_check_f ITIStext_constraint;
ber_type_decoder_f ITIStext_decode_ber;
der_type_encoder_f ITIStext_encode_der;
xer_type_decoder_f ITIStext_decode_xer;
xer_type_encoder_f ITIStext_encode_xer;

/*** <<< CTABLES [ITIStext] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [ITIStext] >>> ***/

int
ITIStext_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 500)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		_ASN_CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */
static void
ITIStext_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_IA5String.free_struct;
	td->print_struct   = asn_DEF_IA5String.print_struct;
	td->check_constraints = asn_DEF_IA5String.check_constraints;
	td->ber_decoder    = asn_DEF_IA5String.ber_decoder;
	td->der_encoder    = asn_DEF_IA5String.der_encoder;
	td->xer_decoder    = asn_DEF_IA5String.xer_decoder;
	td->xer_encoder    = asn_DEF_IA5String.xer_encoder;
	td->uper_decoder   = asn_DEF_IA5String.uper_decoder;
	td->uper_encoder   = asn_DEF_IA5String.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_IA5String.per_constraints;
	td->elements       = asn_DEF_IA5String.elements;
	td->elements_count = asn_DEF_IA5String.elements_count;
	td->specifics      = asn_DEF_IA5String.specifics;
}

void
ITIStext_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ITIStext_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ITIStext_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ITIStext_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ITIStext_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ITIStext_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ITIStext_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ITIStext_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ITIStext_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ITIStext_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ITIStext_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ITIStext_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ITIStext] >>> ***/

static ber_tlv_tag_t asn_DEF_ITIStext_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ITIStext = {
	"ITIStext",
	"ITIStext",
	ITIStext_free,
	ITIStext_print,
	ITIStext_constraint,
	ITIStext_decode_ber,
	ITIStext_encode_der,
	ITIStext_decode_xer,
	ITIStext_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ITIStext_tags_1,
	sizeof(asn_DEF_ITIStext_tags_1)
		/sizeof(asn_DEF_ITIStext_tags_1[0]), /* 1 */
	asn_DEF_ITIStext_tags_1,	/* Same as above */
	sizeof(asn_DEF_ITIStext_tags_1)
		/sizeof(asn_DEF_ITIStext_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ResponderGroupAffected] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [ResponderGroupAffected] >>> ***/

typedef enum ResponderGroupAffected {
	ResponderGroupAffected_emergency_vehicle_units	= 9729,
	ResponderGroupAffected_federal_law_enforcement_units	= 9730,
	ResponderGroupAffected_state_police_units	= 9731,
	ResponderGroupAffected_county_police_units	= 9732,
	ResponderGroupAffected_local_police_units	= 9733,
	ResponderGroupAffected_ambulance_units	= 9734,
	ResponderGroupAffected_rescue_units	= 9735,
	ResponderGroupAffected_fire_units	= 9736,
	ResponderGroupAffected_hAZMAT_units	= 9737,
	ResponderGroupAffected_light_tow_unit	= 9738,
	ResponderGroupAffected_heavy_tow_unit	= 9739,
	ResponderGroupAffected_freeway_service_patrols	= 9740,
	ResponderGroupAffected_transportation_response_units	= 9741,
	ResponderGroupAffected_private_contractor_response_units	= 9742
	/*
	 * Enumeration is extensible
	 */
} e_ResponderGroupAffected;

/*** <<< TYPE-DECLS [ResponderGroupAffected] >>> ***/

typedef long	 ResponderGroupAffected_t;

/*** <<< FUNC-DECLS [ResponderGroupAffected] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ResponderGroupAffected;
asn_struct_free_f ResponderGroupAffected_free;
asn_struct_print_f ResponderGroupAffected_print;
asn_constr_check_f ResponderGroupAffected_constraint;
ber_type_decoder_f ResponderGroupAffected_decode_ber;
der_type_encoder_f ResponderGroupAffected_encode_der;
xer_type_decoder_f ResponderGroupAffected_decode_xer;
xer_type_encoder_f ResponderGroupAffected_encode_xer;

/*** <<< CODE [ResponderGroupAffected] >>> ***/

int
ResponderGroupAffected_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
ResponderGroupAffected_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
ResponderGroupAffected_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	ResponderGroupAffected_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
ResponderGroupAffected_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	ResponderGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
ResponderGroupAffected_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	ResponderGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
ResponderGroupAffected_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ResponderGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
ResponderGroupAffected_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	ResponderGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
ResponderGroupAffected_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	ResponderGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [ResponderGroupAffected] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_ResponderGroupAffected_value2enum_1[] = {
	{ 9729,	23,	"emergency-vehicle-units" },
	{ 9730,	29,	"federal-law-enforcement-units" },
	{ 9731,	18,	"state-police-units" },
	{ 9732,	19,	"county-police-units" },
	{ 9733,	18,	"local-police-units" },
	{ 9734,	15,	"ambulance-units" },
	{ 9735,	12,	"rescue-units" },
	{ 9736,	10,	"fire-units" },
	{ 9737,	12,	"hAZMAT-units" },
	{ 9738,	14,	"light-tow-unit" },
	{ 9739,	14,	"heavy-tow-unit" },
	{ 9740,	23,	"freeway-service-patrols" },
	{ 9741,	29,	"transportation-response-units" },
	{ 9742,	33,	"private-contractor-response-units" }
	/* This list is extensible */
};
static unsigned int asn_MAP_ResponderGroupAffected_enum2value_1[] = {
	5,	/* ambulance-units(9734) */
	3,	/* county-police-units(9732) */
	0,	/* emergency-vehicle-units(9729) */
	1,	/* federal-law-enforcement-units(9730) */
	7,	/* fire-units(9736) */
	11,	/* freeway-service-patrols(9740) */
	8,	/* hAZMAT-units(9737) */
	10,	/* heavy-tow-unit(9739) */
	9,	/* light-tow-unit(9738) */
	4,	/* local-police-units(9733) */
	13,	/* private-contractor-response-units(9742) */
	6,	/* rescue-units(9735) */
	2,	/* state-police-units(9731) */
	12	/* transportation-response-units(9741) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_ResponderGroupAffected_specs_1 = {
	asn_MAP_ResponderGroupAffected_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_ResponderGroupAffected_enum2value_1,	/* N => "tag"; sorted by N */
	14,	/* Number of elements in the maps */
	15,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_ResponderGroupAffected_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ResponderGroupAffected = {
	"ResponderGroupAffected",
	"ResponderGroupAffected",
	ResponderGroupAffected_free,
	ResponderGroupAffected_print,
	ResponderGroupAffected_constraint,
	ResponderGroupAffected_decode_ber,
	ResponderGroupAffected_encode_der,
	ResponderGroupAffected_decode_xer,
	ResponderGroupAffected_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ResponderGroupAffected_tags_1,
	sizeof(asn_DEF_ResponderGroupAffected_tags_1)
		/sizeof(asn_DEF_ResponderGroupAffected_tags_1[0]), /* 1 */
	asn_DEF_ResponderGroupAffected_tags_1,	/* Same as above */
	sizeof(asn_DEF_ResponderGroupAffected_tags_1)
		/sizeof(asn_DEF_ResponderGroupAffected_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ResponderGroupAffected_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [VehicleGroupAffected] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [VehicleGroupAffected] >>> ***/

typedef enum VehicleGroupAffected {
	VehicleGroupAffected_all_vehicles	= 9217,
	VehicleGroupAffected_bicycles	= 9218,
	VehicleGroupAffected_motorcycles	= 9219,
	VehicleGroupAffected_cars	= 9220,
	VehicleGroupAffected_light_vehicles	= 9221,
	VehicleGroupAffected_cars_and_light_vehicles	= 9222,
	VehicleGroupAffected_cars_with_trailers	= 9223,
	VehicleGroupAffected_cars_with_recreational_trailers	= 9224,
	VehicleGroupAffected_vehicles_with_trailers	= 9225,
	VehicleGroupAffected_heavy_vehicles	= 9226,
	VehicleGroupAffected_trucks	= 9227,
	VehicleGroupAffected_buses	= 9228,
	VehicleGroupAffected_articulated_buses	= 9229,
	VehicleGroupAffected_school_buses	= 9230,
	VehicleGroupAffected_vehicles_with_semi_trailers	= 9231,
	VehicleGroupAffected_vehicles_with_double_trailers	= 9232,
	VehicleGroupAffected_high_profile_vehicles	= 9233,
	VehicleGroupAffected_wide_vehicles	= 9234,
	VehicleGroupAffected_long_vehicles	= 9235,
	VehicleGroupAffected_hazardous_loads	= 9236,
	VehicleGroupAffected_exceptional_loads	= 9237,
	VehicleGroupAffected_abnormal_loads	= 9238,
	VehicleGroupAffected_convoys	= 9239,
	VehicleGroupAffected_maintenance_vehicles	= 9240,
	VehicleGroupAffected_delivery_vehicles	= 9241,
	VehicleGroupAffected_vehicles_with_even_numbered_license_plates	= 9242,
	VehicleGroupAffected_vehicles_with_odd_numbered_license_plates	= 9243,
	VehicleGroupAffected_vehicles_with_parking_permits	= 9244,
	VehicleGroupAffected_vehicles_with_catalytic_converters	= 9245,
	VehicleGroupAffected_vehicles_without_catalytic_converters	= 9246,
	VehicleGroupAffected_gas_powered_vehicles	= 9247,
	VehicleGroupAffected_diesel_powered_vehicles	= 9248,
	VehicleGroupAffected_lPG_vehicles	= 9249,
	VehicleGroupAffected_military_convoys	= 9250,
	VehicleGroupAffected_military_vehicles	= 9251
	/*
	 * Enumeration is extensible
	 */
} e_VehicleGroupAffected;

/*** <<< TYPE-DECLS [VehicleGroupAffected] >>> ***/

typedef long	 VehicleGroupAffected_t;

/*** <<< FUNC-DECLS [VehicleGroupAffected] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VehicleGroupAffected;
asn_struct_free_f VehicleGroupAffected_free;
asn_struct_print_f VehicleGroupAffected_print;
asn_constr_check_f VehicleGroupAffected_constraint;
ber_type_decoder_f VehicleGroupAffected_decode_ber;
der_type_encoder_f VehicleGroupAffected_encode_der;
xer_type_decoder_f VehicleGroupAffected_decode_xer;
xer_type_encoder_f VehicleGroupAffected_encode_xer;

/*** <<< CODE [VehicleGroupAffected] >>> ***/

int
VehicleGroupAffected_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
VehicleGroupAffected_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

void
VehicleGroupAffected_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	VehicleGroupAffected_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
VehicleGroupAffected_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
VehicleGroupAffected_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	VehicleGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
VehicleGroupAffected_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
VehicleGroupAffected_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	VehicleGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
VehicleGroupAffected_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	VehicleGroupAffected_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [VehicleGroupAffected] >>> ***/

static asn_INTEGER_enum_map_t asn_MAP_VehicleGroupAffected_value2enum_1[] = {
	{ 9217,	12,	"all-vehicles" },
	{ 9218,	8,	"bicycles" },
	{ 9219,	11,	"motorcycles" },
	{ 9220,	4,	"cars" },
	{ 9221,	14,	"light-vehicles" },
	{ 9222,	23,	"cars-and-light-vehicles" },
	{ 9223,	18,	"cars-with-trailers" },
	{ 9224,	31,	"cars-with-recreational-trailers" },
	{ 9225,	22,	"vehicles-with-trailers" },
	{ 9226,	14,	"heavy-vehicles" },
	{ 9227,	6,	"trucks" },
	{ 9228,	5,	"buses" },
	{ 9229,	17,	"articulated-buses" },
	{ 9230,	12,	"school-buses" },
	{ 9231,	27,	"vehicles-with-semi-trailers" },
	{ 9232,	29,	"vehicles-with-double-trailers" },
	{ 9233,	21,	"high-profile-vehicles" },
	{ 9234,	13,	"wide-vehicles" },
	{ 9235,	13,	"long-vehicles" },
	{ 9236,	15,	"hazardous-loads" },
	{ 9237,	17,	"exceptional-loads" },
	{ 9238,	14,	"abnormal-loads" },
	{ 9239,	7,	"convoys" },
	{ 9240,	20,	"maintenance-vehicles" },
	{ 9241,	17,	"delivery-vehicles" },
	{ 9242,	42,	"vehicles-with-even-numbered-license-plates" },
	{ 9243,	41,	"vehicles-with-odd-numbered-license-plates" },
	{ 9244,	29,	"vehicles-with-parking-permits" },
	{ 9245,	34,	"vehicles-with-catalytic-converters" },
	{ 9246,	37,	"vehicles-without-catalytic-converters" },
	{ 9247,	20,	"gas-powered-vehicles" },
	{ 9248,	23,	"diesel-powered-vehicles" },
	{ 9249,	12,	"lPG-vehicles" },
	{ 9250,	16,	"military-convoys" },
	{ 9251,	17,	"military-vehicles" }
	/* This list is extensible */
};
static unsigned int asn_MAP_VehicleGroupAffected_enum2value_1[] = {
	21,	/* abnormal-loads(9238) */
	0,	/* all-vehicles(9217) */
	12,	/* articulated-buses(9229) */
	1,	/* bicycles(9218) */
	11,	/* buses(9228) */
	3,	/* cars(9220) */
	5,	/* cars-and-light-vehicles(9222) */
	7,	/* cars-with-recreational-trailers(9224) */
	6,	/* cars-with-trailers(9223) */
	22,	/* convoys(9239) */
	24,	/* delivery-vehicles(9241) */
	31,	/* diesel-powered-vehicles(9248) */
	20,	/* exceptional-loads(9237) */
	30,	/* gas-powered-vehicles(9247) */
	19,	/* hazardous-loads(9236) */
	9,	/* heavy-vehicles(9226) */
	16,	/* high-profile-vehicles(9233) */
	32,	/* lPG-vehicles(9249) */
	4,	/* light-vehicles(9221) */
	18,	/* long-vehicles(9235) */
	23,	/* maintenance-vehicles(9240) */
	33,	/* military-convoys(9250) */
	34,	/* military-vehicles(9251) */
	2,	/* motorcycles(9219) */
	13,	/* school-buses(9230) */
	10,	/* trucks(9227) */
	28,	/* vehicles-with-catalytic-converters(9245) */
	15,	/* vehicles-with-double-trailers(9232) */
	25,	/* vehicles-with-even-numbered-license-plates(9242) */
	26,	/* vehicles-with-odd-numbered-license-plates(9243) */
	27,	/* vehicles-with-parking-permits(9244) */
	14,	/* vehicles-with-semi-trailers(9231) */
	8,	/* vehicles-with-trailers(9225) */
	29,	/* vehicles-without-catalytic-converters(9246) */
	17	/* wide-vehicles(9234) */
	/* This list is extensible */
};
static asn_INTEGER_specifics_t asn_SPC_VehicleGroupAffected_specs_1 = {
	asn_MAP_VehicleGroupAffected_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_VehicleGroupAffected_enum2value_1,	/* N => "tag"; sorted by N */
	35,	/* Number of elements in the maps */
	36,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_VehicleGroupAffected_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VehicleGroupAffected = {
	"VehicleGroupAffected",
	"VehicleGroupAffected",
	VehicleGroupAffected_free,
	VehicleGroupAffected_print,
	VehicleGroupAffected_constraint,
	VehicleGroupAffected_decode_ber,
	VehicleGroupAffected_encode_der,
	VehicleGroupAffected_decode_xer,
	VehicleGroupAffected_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_VehicleGroupAffected_tags_1,
	sizeof(asn_DEF_VehicleGroupAffected_tags_1)
		/sizeof(asn_DEF_VehicleGroupAffected_tags_1[0]), /* 1 */
	asn_DEF_VehicleGroupAffected_tags_1,	/* Same as above */
	sizeof(asn_DEF_VehicleGroupAffected_tags_1)
		/sizeof(asn_DEF_VehicleGroupAffected_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	&asn_SPC_VehicleGroupAffected_specs_1	/* Additional specs */
};

